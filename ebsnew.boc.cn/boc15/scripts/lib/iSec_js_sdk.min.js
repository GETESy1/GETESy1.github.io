! function(t, e) {
    "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.iSec_js_sdk = e() : t.iSec_js_sdk = e()
}(this, (function() {
    return function(t) {
        var e = {};

        function r(n) {
            if (e[n]) return e[n].exports;
            var i = e[n] = {
                i: n,
                l: !1,
                exports: {}
            };
            return t[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports
        }
        return r.m = t, r.c = e, r.d = function(t, e, n) {
            r.o(t, e) || Object.defineProperty(t, e, {
                enumerable: !0,
                get: n
            })
        }, r.r = function(t) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(t, "__esModule", {
                value: !0
            })
        }, r.t = function(t, e) {
            if (1 & e && (t = r(t)), 8 & e) return t;
            if (4 & e && "object" == typeof t && t && t.__esModule) return t;
            var n = Object.create(null);
            if (r.r(n), Object.defineProperty(n, "default", {
                    enumerable: !0,
                    value: t
                }), 2 & e && "string" != typeof t)
                for (var i in t) r.d(n, i, function(e) {
                    return t[e]
                }.bind(null, i));
            return n
        }, r.n = function(t) {
            var e = t && t.__esModule ? function() {
                return t.default
            } : function() {
                return t
            };
            return r.d(e, "a", e), e
        }, r.o = function(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e)
        }, r.p = "", r(r.s = 201)
    }([function(t, e, r) {
        (function(e) {
            var r = function(t) {
                return t && t.Math == Math && t
            };
            t.exports = r("object" == typeof globalThis && globalThis) || r("object" == typeof window && window) || r("object" == typeof self && self) || r("object" == typeof e && e) || function() {
                return this
            }() || Function("return this")()
        }).call(this, r(52))
    }, function(t, e) {
        var r = Function.prototype,
            n = r.bind,
            i = r.call,
            s = n && n.bind(i);
        t.exports = n ? function(t) {
            return t && s(i, t)
        } : function(t) {
            return t && function() {
                return i.apply(t, arguments)
            }
        }
    }, function(t, e, r) {
        "use strict";
        (function(t) {
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <http://feross.org>
             * @license  MIT
             */
            var n = r(252),
                i = r(253),
                s = r(254);

            function a() {
                return u.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
            }

            function o(t, e) {
                if (a() < e) throw new RangeError("Invalid typed array length");
                return u.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = u.prototype : (null === t && (t = new u(e)), t.length = e), t
            }

            function u(t, e, r) {
                if (!(u.TYPED_ARRAY_SUPPORT || this instanceof u)) return new u(t, e, r);
                if ("number" == typeof t) {
                    if ("string" == typeof e) throw new Error("If encoding is specified then the first argument must be a string");
                    return l(this, t)
                }
                return c(this, t, e, r)
            }

            function c(t, e, r, n) {
                if ("number" == typeof e) throw new TypeError('"value" argument must not be a number');
                return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function(t, e, r, n) {
                    if (e.byteLength, r < 0 || e.byteLength < r) throw new RangeError("'offset' is out of bounds");
                    if (e.byteLength < r + (n || 0)) throw new RangeError("'length' is out of bounds");
                    e = void 0 === r && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, r) : new Uint8Array(e, r, n);
                    u.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = u.prototype : t = f(t, e);
                    return t
                }(t, e, r, n) : "string" == typeof e ? function(t, e, r) {
                    "string" == typeof r && "" !== r || (r = "utf8");
                    if (!u.isEncoding(r)) throw new TypeError('"encoding" must be a valid string encoding');
                    var n = 0 | d(e, r),
                        i = (t = o(t, n)).write(e, r);
                    i !== n && (t = t.slice(0, i));
                    return t
                }(t, e, r) : function(t, e) {
                    if (u.isBuffer(e)) {
                        var r = 0 | p(e.length);
                        return 0 === (t = o(t, r)).length || e.copy(t, 0, 0, r), t
                    }
                    if (e) {
                        if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" != typeof e.length || (n = e.length) != n ? o(t, 0) : f(t, e);
                        if ("Buffer" === e.type && s(e.data)) return f(t, e.data)
                    }
                    var n;
                    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
                }(t, e)
            }

            function h(t) {
                if ("number" != typeof t) throw new TypeError('"size" argument must be a number');
                if (t < 0) throw new RangeError('"size" argument must not be negative')
            }

            function l(t, e) {
                if (h(e), t = o(t, e < 0 ? 0 : 0 | p(e)), !u.TYPED_ARRAY_SUPPORT)
                    for (var r = 0; r < e; ++r) t[r] = 0;
                return t
            }

            function f(t, e) {
                var r = e.length < 0 ? 0 : 0 | p(e.length);
                t = o(t, r);
                for (var n = 0; n < r; n += 1) t[n] = 255 & e[n];
                return t
            }

            function p(t) {
                if (t >= a()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a().toString(16) + " bytes");
                return 0 | t
            }

            function d(t, e) {
                if (u.isBuffer(t)) return t.length;
                if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
                "string" != typeof t && (t = "" + t);
                var r = t.length;
                if (0 === r) return 0;
                for (var n = !1;;) switch (e) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return r;
                    case "utf8":
                    case "utf-8":
                    case void 0:
                        return H(t).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * r;
                    case "hex":
                        return r >>> 1;
                    case "base64":
                        return j(t).length;
                    default:
                        if (n) return H(t).length;
                        e = ("" + e).toLowerCase(), n = !0
                }
            }

            function g(t, e, r) {
                var n = !1;
                if ((void 0 === e || e < 0) && (e = 0), e > this.length) return "";
                if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return "";
                if ((r >>>= 0) <= (e >>>= 0)) return "";
                for (t || (t = "utf8");;) switch (t) {
                    case "hex":
                        return F(this, e, r);
                    case "utf8":
                    case "utf-8":
                        return x(this, e, r);
                    case "ascii":
                        return I(this, e, r);
                    case "latin1":
                    case "binary":
                        return B(this, e, r);
                    case "base64":
                        return T(this, e, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return R(this, e, r);
                    default:
                        if (n) throw new TypeError("Unknown encoding: " + t);
                        t = (t + "").toLowerCase(), n = !0
                }
            }

            function y(t, e, r) {
                var n = t[e];
                t[e] = t[r], t[r] = n
            }

            function v(t, e, r, n, i) {
                if (0 === t.length) return -1;
                if ("string" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, isNaN(r) && (r = i ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
                    if (i) return -1;
                    r = t.length - 1
                } else if (r < 0) {
                    if (!i) return -1;
                    r = 0
                }
                if ("string" == typeof e && (e = u.from(e, n)), u.isBuffer(e)) return 0 === e.length ? -1 : m(t, e, r, n, i);
                if ("number" == typeof e) return e &= 255, u.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : m(t, [e], r, n, i);
                throw new TypeError("val must be string, number or Buffer")
            }

            function m(t, e, r, n, i) {
                var s, a = 1,
                    o = t.length,
                    u = e.length;
                if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                    if (t.length < 2 || e.length < 2) return -1;
                    a = 2, o /= 2, u /= 2, r /= 2
                }

                function c(t, e) {
                    return 1 === a ? t[e] : t.readUInt16BE(e * a)
                }
                if (i) {
                    var h = -1;
                    for (s = r; s < o; s++)
                        if (c(t, s) === c(e, -1 === h ? 0 : s - h)) {
                            if (-1 === h && (h = s), s - h + 1 === u) return h * a
                        } else -1 !== h && (s -= s - h), h = -1
                } else
                    for (r + u > o && (r = o - u), s = r; s >= 0; s--) {
                        for (var l = !0, f = 0; f < u; f++)
                            if (c(t, s + f) !== c(e, f)) {
                                l = !1;
                                break
                            }
                        if (l) return s
                    }
                return -1
            }

            function E(t, e, r, n) {
                r = Number(r) || 0;
                var i = t.length - r;
                n ? (n = Number(n)) > i && (n = i) : n = i;
                var s = e.length;
                if (s % 2 != 0) throw new TypeError("Invalid hex string");
                n > s / 2 && (n = s / 2);
                for (var a = 0; a < n; ++a) {
                    var o = parseInt(e.substr(2 * a, 2), 16);
                    if (isNaN(o)) return a;
                    t[r + a] = o
                }
                return a
            }

            function S(t, e, r, n) {
                return M(H(e, t.length - r), t, r, n)
            }

            function b(t, e, r, n) {
                return M(function(t) {
                    for (var e = [], r = 0; r < t.length; ++r) e.push(255 & t.charCodeAt(r));
                    return e
                }(e), t, r, n)
            }

            function C(t, e, r, n) {
                return b(t, e, r, n)
            }

            function A(t, e, r, n) {
                return M(j(e), t, r, n)
            }

            function w(t, e, r, n) {
                return M(function(t, e) {
                    for (var r, n, i, s = [], a = 0; a < t.length && !((e -= 2) < 0); ++a) r = t.charCodeAt(a), n = r >> 8, i = r % 256, s.push(i), s.push(n);
                    return s
                }(e, t.length - r), t, r, n)
            }

            function T(t, e, r) {
                return 0 === e && r === t.length ? n.fromByteArray(t) : n.fromByteArray(t.slice(e, r))
            }

            function x(t, e, r) {
                r = Math.min(t.length, r);
                for (var n = [], i = e; i < r;) {
                    var s, a, o, u, c = t[i],
                        h = null,
                        l = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
                    if (i + l <= r) switch (l) {
                        case 1:
                            c < 128 && (h = c);
                            break;
                        case 2:
                            128 == (192 & (s = t[i + 1])) && (u = (31 & c) << 6 | 63 & s) > 127 && (h = u);
                            break;
                        case 3:
                            s = t[i + 1], a = t[i + 2], 128 == (192 & s) && 128 == (192 & a) && (u = (15 & c) << 12 | (63 & s) << 6 | 63 & a) > 2047 && (u < 55296 || u > 57343) && (h = u);
                            break;
                        case 4:
                            s = t[i + 1], a = t[i + 2], o = t[i + 3], 128 == (192 & s) && 128 == (192 & a) && 128 == (192 & o) && (u = (15 & c) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) > 65535 && u < 1114112 && (h = u)
                    }
                    null === h ? (h = 65533, l = 1) : h > 65535 && (h -= 65536, n.push(h >>> 10 & 1023 | 55296), h = 56320 | 1023 & h), n.push(h), i += l
                }
                return function(t) {
                    var e = t.length;
                    if (e <= 4096) return String.fromCharCode.apply(String, t);
                    var r = "",
                        n = 0;
                    for (; n < e;) r += String.fromCharCode.apply(String, t.slice(n, n += 4096));
                    return r
                }(n)
            }
            e.Buffer = u, e.SlowBuffer = function(t) {
                +t != t && (t = 0);
                return u.alloc(+t)
            }, e.INSPECT_MAX_BYTES = 50, u.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : function() {
                try {
                    var t = new Uint8Array(1);
                    return t.__proto__ = {
                        __proto__: Uint8Array.prototype,
                        foo: function() {
                            return 42
                        }
                    }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength
                } catch (t) {
                    return !1
                }
            }(), e.kMaxLength = a(), u.poolSize = 8192, u._augment = function(t) {
                return t.__proto__ = u.prototype, t
            }, u.from = function(t, e, r) {
                return c(null, t, e, r)
            }, u.TYPED_ARRAY_SUPPORT && (u.prototype.__proto__ = Uint8Array.prototype, u.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && u[Symbol.species] === u && Object.defineProperty(u, Symbol.species, {
                value: null,
                configurable: !0
            })), u.alloc = function(t, e, r) {
                return function(t, e, r, n) {
                    return h(e), e <= 0 ? o(t, e) : void 0 !== r ? "string" == typeof n ? o(t, e).fill(r, n) : o(t, e).fill(r) : o(t, e)
                }(null, t, e, r)
            }, u.allocUnsafe = function(t) {
                return l(null, t)
            }, u.allocUnsafeSlow = function(t) {
                return l(null, t)
            }, u.isBuffer = function(t) {
                return !(null == t || !t._isBuffer)
            }, u.compare = function(t, e) {
                if (!u.isBuffer(t) || !u.isBuffer(e)) throw new TypeError("Arguments must be Buffers");
                if (t === e) return 0;
                for (var r = t.length, n = e.length, i = 0, s = Math.min(r, n); i < s; ++i)
                    if (t[i] !== e[i]) {
                        r = t[i], n = e[i];
                        break
                    }
                return r < n ? -1 : n < r ? 1 : 0
            }, u.isEncoding = function(t) {
                switch (String(t).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1
                }
            }, u.concat = function(t, e) {
                if (!s(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === t.length) return u.alloc(0);
                var r;
                if (void 0 === e)
                    for (e = 0, r = 0; r < t.length; ++r) e += t[r].length;
                var n = u.allocUnsafe(e),
                    i = 0;
                for (r = 0; r < t.length; ++r) {
                    var a = t[r];
                    if (!u.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers');
                    a.copy(n, i), i += a.length
                }
                return n
            }, u.byteLength = d, u.prototype._isBuffer = !0, u.prototype.swap16 = function() {
                var t = this.length;
                if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (var e = 0; e < t; e += 2) y(this, e, e + 1);
                return this
            }, u.prototype.swap32 = function() {
                var t = this.length;
                if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (var e = 0; e < t; e += 4) y(this, e, e + 3), y(this, e + 1, e + 2);
                return this
            }, u.prototype.swap64 = function() {
                var t = this.length;
                if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (var e = 0; e < t; e += 8) y(this, e, e + 7), y(this, e + 1, e + 6), y(this, e + 2, e + 5), y(this, e + 3, e + 4);
                return this
            }, u.prototype.toString = function() {
                var t = 0 | this.length;
                return 0 === t ? "" : 0 === arguments.length ? x(this, 0, t) : g.apply(this, arguments)
            }, u.prototype.equals = function(t) {
                if (!u.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                return this === t || 0 === u.compare(this, t)
            }, u.prototype.inspect = function() {
                var t = "",
                    r = e.INSPECT_MAX_BYTES;
                return this.length > 0 && (t = this.toString("hex", 0, r).match(/.{2}/g).join(" "), this.length > r && (t += " ... ")), "<Buffer " + t + ">"
            }, u.prototype.compare = function(t, e, r, n, i) {
                if (!u.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                if (void 0 === e && (e = 0), void 0 === r && (r = t ? t.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), e < 0 || r > t.length || n < 0 || i > this.length) throw new RangeError("out of range index");
                if (n >= i && e >= r) return 0;
                if (n >= i) return -1;
                if (e >= r) return 1;
                if (this === t) return 0;
                for (var s = (i >>>= 0) - (n >>>= 0), a = (r >>>= 0) - (e >>>= 0), o = Math.min(s, a), c = this.slice(n, i), h = t.slice(e, r), l = 0; l < o; ++l)
                    if (c[l] !== h[l]) {
                        s = c[l], a = h[l];
                        break
                    }
                return s < a ? -1 : a < s ? 1 : 0
            }, u.prototype.includes = function(t, e, r) {
                return -1 !== this.indexOf(t, e, r)
            }, u.prototype.indexOf = function(t, e, r) {
                return v(this, t, e, r, !0)
            }, u.prototype.lastIndexOf = function(t, e, r) {
                return v(this, t, e, r, !1)
            }, u.prototype.write = function(t, e, r, n) {
                if (void 0 === e) n = "utf8", r = this.length, e = 0;
                else if (void 0 === r && "string" == typeof e) n = e, r = this.length, e = 0;
                else {
                    if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    e |= 0, isFinite(r) ? (r |= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0)
                }
                var i = this.length - e;
                if ((void 0 === r || r > i) && (r = i), t.length > 0 && (r < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                n || (n = "utf8");
                for (var s = !1;;) switch (n) {
                    case "hex":
                        return E(this, t, e, r);
                    case "utf8":
                    case "utf-8":
                        return S(this, t, e, r);
                    case "ascii":
                        return b(this, t, e, r);
                    case "latin1":
                    case "binary":
                        return C(this, t, e, r);
                    case "base64":
                        return A(this, t, e, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return w(this, t, e, r);
                    default:
                        if (s) throw new TypeError("Unknown encoding: " + n);
                        n = ("" + n).toLowerCase(), s = !0
                }
            }, u.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            };

            function I(t, e, r) {
                var n = "";
                r = Math.min(t.length, r);
                for (var i = e; i < r; ++i) n += String.fromCharCode(127 & t[i]);
                return n
            }

            function B(t, e, r) {
                var n = "";
                r = Math.min(t.length, r);
                for (var i = e; i < r; ++i) n += String.fromCharCode(t[i]);
                return n
            }

            function F(t, e, r) {
                var n = t.length;
                (!e || e < 0) && (e = 0), (!r || r < 0 || r > n) && (r = n);
                for (var i = "", s = e; s < r; ++s) i += V(t[s]);
                return i
            }

            function R(t, e, r) {
                for (var n = t.slice(e, r), i = "", s = 0; s < n.length; s += 2) i += String.fromCharCode(n[s] + 256 * n[s + 1]);
                return i
            }

            function D(t, e, r) {
                if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
                if (t + e > r) throw new RangeError("Trying to access beyond buffer length")
            }

            function N(t, e, r, n, i, s) {
                if (!u.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (e > i || e < s) throw new RangeError('"value" argument is out of bounds');
                if (r + n > t.length) throw new RangeError("Index out of range")
            }

            function _(t, e, r, n) {
                e < 0 && (e = 65535 + e + 1);
                for (var i = 0, s = Math.min(t.length - r, 2); i < s; ++i) t[r + i] = (e & 255 << 8 * (n ? i : 1 - i)) >>> 8 * (n ? i : 1 - i)
            }

            function P(t, e, r, n) {
                e < 0 && (e = 4294967295 + e + 1);
                for (var i = 0, s = Math.min(t.length - r, 4); i < s; ++i) t[r + i] = e >>> 8 * (n ? i : 3 - i) & 255
            }

            function k(t, e, r, n, i, s) {
                if (r + n > t.length) throw new RangeError("Index out of range");
                if (r < 0) throw new RangeError("Index out of range")
            }

            function L(t, e, r, n, s) {
                return s || k(t, 0, r, 4), i.write(t, e, r, n, 23, 4), r + 4
            }

            function O(t, e, r, n, s) {
                return s || k(t, 0, r, 8), i.write(t, e, r, n, 52, 8), r + 8
            }
            u.prototype.slice = function(t, e) {
                var r, n = this.length;
                if ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (e = void 0 === e ? n : ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), e < t && (e = t), u.TYPED_ARRAY_SUPPORT)(r = this.subarray(t, e)).__proto__ = u.prototype;
                else {
                    var i = e - t;
                    r = new u(i, void 0);
                    for (var s = 0; s < i; ++s) r[s] = this[s + t]
                }
                return r
            }, u.prototype.readUIntLE = function(t, e, r) {
                t |= 0, e |= 0, r || D(t, e, this.length);
                for (var n = this[t], i = 1, s = 0; ++s < e && (i *= 256);) n += this[t + s] * i;
                return n
            }, u.prototype.readUIntBE = function(t, e, r) {
                t |= 0, e |= 0, r || D(t, e, this.length);
                for (var n = this[t + --e], i = 1; e > 0 && (i *= 256);) n += this[t + --e] * i;
                return n
            }, u.prototype.readUInt8 = function(t, e) {
                return e || D(t, 1, this.length), this[t]
            }, u.prototype.readUInt16LE = function(t, e) {
                return e || D(t, 2, this.length), this[t] | this[t + 1] << 8
            }, u.prototype.readUInt16BE = function(t, e) {
                return e || D(t, 2, this.length), this[t] << 8 | this[t + 1]
            }, u.prototype.readUInt32LE = function(t, e) {
                return e || D(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
            }, u.prototype.readUInt32BE = function(t, e) {
                return e || D(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
            }, u.prototype.readIntLE = function(t, e, r) {
                t |= 0, e |= 0, r || D(t, e, this.length);
                for (var n = this[t], i = 1, s = 0; ++s < e && (i *= 256);) n += this[t + s] * i;
                return n >= (i *= 128) && (n -= Math.pow(2, 8 * e)), n
            }, u.prototype.readIntBE = function(t, e, r) {
                t |= 0, e |= 0, r || D(t, e, this.length);
                for (var n = e, i = 1, s = this[t + --n]; n > 0 && (i *= 256);) s += this[t + --n] * i;
                return s >= (i *= 128) && (s -= Math.pow(2, 8 * e)), s
            }, u.prototype.readInt8 = function(t, e) {
                return e || D(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
            }, u.prototype.readInt16LE = function(t, e) {
                e || D(t, 2, this.length);
                var r = this[t] | this[t + 1] << 8;
                return 32768 & r ? 4294901760 | r : r
            }, u.prototype.readInt16BE = function(t, e) {
                e || D(t, 2, this.length);
                var r = this[t + 1] | this[t] << 8;
                return 32768 & r ? 4294901760 | r : r
            }, u.prototype.readInt32LE = function(t, e) {
                return e || D(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
            }, u.prototype.readInt32BE = function(t, e) {
                return e || D(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
            }, u.prototype.readFloatLE = function(t, e) {
                return e || D(t, 4, this.length), i.read(this, t, !0, 23, 4)
            }, u.prototype.readFloatBE = function(t, e) {
                return e || D(t, 4, this.length), i.read(this, t, !1, 23, 4)
            }, u.prototype.readDoubleLE = function(t, e) {
                return e || D(t, 8, this.length), i.read(this, t, !0, 52, 8)
            }, u.prototype.readDoubleBE = function(t, e) {
                return e || D(t, 8, this.length), i.read(this, t, !1, 52, 8)
            }, u.prototype.writeUIntLE = function(t, e, r, n) {
                (t = +t, e |= 0, r |= 0, n) || N(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
                var i = 1,
                    s = 0;
                for (this[e] = 255 & t; ++s < r && (i *= 256);) this[e + s] = t / i & 255;
                return e + r
            }, u.prototype.writeUIntBE = function(t, e, r, n) {
                (t = +t, e |= 0, r |= 0, n) || N(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
                var i = r - 1,
                    s = 1;
                for (this[e + i] = 255 & t; --i >= 0 && (s *= 256);) this[e + i] = t / s & 255;
                return e + r
            }, u.prototype.writeUInt8 = function(t, e, r) {
                return t = +t, e |= 0, r || N(this, t, e, 1, 255, 0), u.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1
            }, u.prototype.writeUInt16LE = function(t, e, r) {
                return t = +t, e |= 0, r || N(this, t, e, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : _(this, t, e, !0), e + 2
            }, u.prototype.writeUInt16BE = function(t, e, r) {
                return t = +t, e |= 0, r || N(this, t, e, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : _(this, t, e, !1), e + 2
            }, u.prototype.writeUInt32LE = function(t, e, r) {
                return t = +t, e |= 0, r || N(this, t, e, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : P(this, t, e, !0), e + 4
            }, u.prototype.writeUInt32BE = function(t, e, r) {
                return t = +t, e |= 0, r || N(this, t, e, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : P(this, t, e, !1), e + 4
            }, u.prototype.writeIntLE = function(t, e, r, n) {
                if (t = +t, e |= 0, !n) {
                    var i = Math.pow(2, 8 * r - 1);
                    N(this, t, e, r, i - 1, -i)
                }
                var s = 0,
                    a = 1,
                    o = 0;
                for (this[e] = 255 & t; ++s < r && (a *= 256);) t < 0 && 0 === o && 0 !== this[e + s - 1] && (o = 1), this[e + s] = (t / a >> 0) - o & 255;
                return e + r
            }, u.prototype.writeIntBE = function(t, e, r, n) {
                if (t = +t, e |= 0, !n) {
                    var i = Math.pow(2, 8 * r - 1);
                    N(this, t, e, r, i - 1, -i)
                }
                var s = r - 1,
                    a = 1,
                    o = 0;
                for (this[e + s] = 255 & t; --s >= 0 && (a *= 256);) t < 0 && 0 === o && 0 !== this[e + s + 1] && (o = 1), this[e + s] = (t / a >> 0) - o & 255;
                return e + r
            }, u.prototype.writeInt8 = function(t, e, r) {
                return t = +t, e |= 0, r || N(this, t, e, 1, 127, -128), u.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1
            }, u.prototype.writeInt16LE = function(t, e, r) {
                return t = +t, e |= 0, r || N(this, t, e, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : _(this, t, e, !0), e + 2
            }, u.prototype.writeInt16BE = function(t, e, r) {
                return t = +t, e |= 0, r || N(this, t, e, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : _(this, t, e, !1), e + 2
            }, u.prototype.writeInt32LE = function(t, e, r) {
                return t = +t, e |= 0, r || N(this, t, e, 4, 2147483647, -2147483648), u.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : P(this, t, e, !0), e + 4
            }, u.prototype.writeInt32BE = function(t, e, r) {
                return t = +t, e |= 0, r || N(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : P(this, t, e, !1), e + 4
            }, u.prototype.writeFloatLE = function(t, e, r) {
                return L(this, t, e, !0, r)
            }, u.prototype.writeFloatBE = function(t, e, r) {
                return L(this, t, e, !1, r)
            }, u.prototype.writeDoubleLE = function(t, e, r) {
                return O(this, t, e, !0, r)
            }, u.prototype.writeDoubleBE = function(t, e, r) {
                return O(this, t, e, !1, r)
            }, u.prototype.copy = function(t, e, r, n) {
                if (r || (r = 0), n || 0 === n || (n = this.length), e >= t.length && (e = t.length), e || (e = 0), n > 0 && n < r && (n = r), n === r) return 0;
                if (0 === t.length || 0 === this.length) return 0;
                if (e < 0) throw new RangeError("targetStart out of bounds");
                if (r < 0 || r >= this.length) throw new RangeError("sourceStart out of bounds");
                if (n < 0) throw new RangeError("sourceEnd out of bounds");
                n > this.length && (n = this.length), t.length - e < n - r && (n = t.length - e + r);
                var i, s = n - r;
                if (this === t && r < e && e < n)
                    for (i = s - 1; i >= 0; --i) t[i + e] = this[i + r];
                else if (s < 1e3 || !u.TYPED_ARRAY_SUPPORT)
                    for (i = 0; i < s; ++i) t[i + e] = this[i + r];
                else Uint8Array.prototype.set.call(t, this.subarray(r, r + s), e);
                return s
            }, u.prototype.fill = function(t, e, r, n) {
                if ("string" == typeof t) {
                    if ("string" == typeof e ? (n = e, e = 0, r = this.length) : "string" == typeof r && (n = r, r = this.length), 1 === t.length) {
                        var i = t.charCodeAt(0);
                        i < 256 && (t = i)
                    }
                    if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
                    if ("string" == typeof n && !u.isEncoding(n)) throw new TypeError("Unknown encoding: " + n)
                } else "number" == typeof t && (t &= 255);
                if (e < 0 || this.length < e || this.length < r) throw new RangeError("Out of range index");
                if (r <= e) return this;
                var s;
                if (e >>>= 0, r = void 0 === r ? this.length : r >>> 0, t || (t = 0), "number" == typeof t)
                    for (s = e; s < r; ++s) this[s] = t;
                else {
                    var a = u.isBuffer(t) ? t : H(new u(t, n).toString()),
                        o = a.length;
                    for (s = 0; s < r - e; ++s) this[s + e] = a[s % o]
                }
                return this
            };
            var U = /[^+\/0-9A-Za-z-_]/g;

            function V(t) {
                return t < 16 ? "0" + t.toString(16) : t.toString(16)
            }

            function H(t, e) {
                var r;
                e = e || 1 / 0;
                for (var n = t.length, i = null, s = [], a = 0; a < n; ++a) {
                    if ((r = t.charCodeAt(a)) > 55295 && r < 57344) {
                        if (!i) {
                            if (r > 56319) {
                                (e -= 3) > -1 && s.push(239, 191, 189);
                                continue
                            }
                            if (a + 1 === n) {
                                (e -= 3) > -1 && s.push(239, 191, 189);
                                continue
                            }
                            i = r;
                            continue
                        }
                        if (r < 56320) {
                            (e -= 3) > -1 && s.push(239, 191, 189), i = r;
                            continue
                        }
                        r = 65536 + (i - 55296 << 10 | r - 56320)
                    } else i && (e -= 3) > -1 && s.push(239, 191, 189);
                    if (i = null, r < 128) {
                        if ((e -= 1) < 0) break;
                        s.push(r)
                    } else if (r < 2048) {
                        if ((e -= 2) < 0) break;
                        s.push(r >> 6 | 192, 63 & r | 128)
                    } else if (r < 65536) {
                        if ((e -= 3) < 0) break;
                        s.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128)
                    } else {
                        if (!(r < 1114112)) throw new Error("Invalid code point");
                        if ((e -= 4) < 0) break;
                        s.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128)
                    }
                }
                return s
            }

            function j(t) {
                return n.toByteArray(function(t) {
                    if ((t = function(t) {
                            return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
                        }(t).replace(U, "")).length < 2) return "";
                    for (; t.length % 4 != 0;) t += "=";
                    return t
                }(t))
            }

            function M(t, e, r, n) {
                for (var i = 0; i < n && !(i + r >= e.length || i >= t.length); ++i) e[i + r] = t[i];
                return i
            }
        }).call(this, r(52))
    }, function(t, e) {
        t.exports = function(t) {
            try {
                return !!t()
            } catch (t) {
                return !0
            }
        }
    }, function(t, e, r) {
        (function(e) {
            var n;
            t.exports = (n = n || function(t, n) {
                var i;
                if ("undefined" != typeof window && window.crypto && (i = window.crypto), "undefined" != typeof self && self.crypto && (i = self.crypto), "undefined" != typeof globalThis && globalThis.crypto && (i = globalThis.crypto), !i && "undefined" != typeof window && window.msCrypto && (i = window.msCrypto), !i && void 0 !== e && e.crypto && (i = e.crypto), !i) try {
                    i = r(207)
                } catch (t) {}
                var s = function() {
                        if (i) {
                            if ("function" == typeof i.getRandomValues) try {
                                return i.getRandomValues(new Uint32Array(1))[0]
                            } catch (t) {}
                            if ("function" == typeof i.randomBytes) try {
                                return i.randomBytes(4).readInt32LE()
                            } catch (t) {}
                        }
                        throw new Error("Native crypto module could not be used to get secure random number.")
                    },
                    a = Object.create || function() {
                        function t() {}
                        return function(e) {
                            var r;
                            return t.prototype = e, r = new t, t.prototype = null, r
                        }
                    }(),
                    o = {},
                    u = o.lib = {},
                    c = u.Base = {
                        extend: function(t) {
                            var e = a(this);
                            return t && e.mixIn(t), e.hasOwnProperty("init") && this.init !== e.init || (e.init = function() {
                                e.$super.init.apply(this, arguments)
                            }), e.init.prototype = e, e.$super = this, e
                        },
                        create: function() {
                            var t = this.extend();
                            return t.init.apply(t, arguments), t
                        },
                        init: function() {},
                        mixIn: function(t) {
                            for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]);
                            t.hasOwnProperty("toString") && (this.toString = t.toString)
                        },
                        clone: function() {
                            return this.init.prototype.extend(this)
                        }
                    },
                    h = u.WordArray = c.extend({
                        init: function(t, e) {
                            t = this.words = t || [], this.sigBytes = null != e ? e : 4 * t.length
                        },
                        toString: function(t) {
                            return (t || f).stringify(this)
                        },
                        concat: function(t) {
                            var e = this.words,
                                r = t.words,
                                n = this.sigBytes,
                                i = t.sigBytes;
                            if (this.clamp(), n % 4)
                                for (var s = 0; s < i; s++) {
                                    var a = r[s >>> 2] >>> 24 - s % 4 * 8 & 255;
                                    e[n + s >>> 2] |= a << 24 - (n + s) % 4 * 8
                                } else
                                    for (var o = 0; o < i; o += 4) e[n + o >>> 2] = r[o >>> 2];
                            return this.sigBytes += i, this
                        },
                        clamp: function() {
                            var e = this.words,
                                r = this.sigBytes;
                            e[r >>> 2] &= 4294967295 << 32 - r % 4 * 8, e.length = t.ceil(r / 4)
                        },
                        clone: function() {
                            var t = c.clone.call(this);
                            return t.words = this.words.slice(0), t
                        },
                        random: function(t) {
                            for (var e = [], r = 0; r < t; r += 4) e.push(s());
                            return new h.init(e, t)
                        }
                    }),
                    l = o.enc = {},
                    f = l.Hex = {
                        stringify: function(t) {
                            for (var e = t.words, r = t.sigBytes, n = [], i = 0; i < r; i++) {
                                var s = e[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                                n.push((s >>> 4).toString(16)), n.push((15 & s).toString(16))
                            }
                            return n.join("")
                        },
                        parse: function(t) {
                            for (var e = t.length, r = [], n = 0; n < e; n += 2) r[n >>> 3] |= parseInt(t.substr(n, 2), 16) << 24 - n % 8 * 4;
                            return new h.init(r, e / 2)
                        }
                    },
                    p = l.Latin1 = {
                        stringify: function(t) {
                            for (var e = t.words, r = t.sigBytes, n = [], i = 0; i < r; i++) {
                                var s = e[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                                n.push(String.fromCharCode(s))
                            }
                            return n.join("")
                        },
                        parse: function(t) {
                            for (var e = t.length, r = [], n = 0; n < e; n++) r[n >>> 2] |= (255 & t.charCodeAt(n)) << 24 - n % 4 * 8;
                            return new h.init(r, e)
                        }
                    },
                    d = l.Utf8 = {
                        stringify: function(t) {
                            try {
                                return decodeURIComponent(escape(p.stringify(t)))
                            } catch (t) {
                                throw new Error("Malformed UTF-8 data")
                            }
                        },
                        parse: function(t) {
                            return p.parse(unescape(encodeURIComponent(t)))
                        }
                    },
                    g = u.BufferedBlockAlgorithm = c.extend({
                        reset: function() {
                            this._data = new h.init, this._nDataBytes = 0
                        },
                        _append: function(t) {
                            "string" == typeof t && (t = d.parse(t)), this._data.concat(t), this._nDataBytes += t.sigBytes
                        },
                        _process: function(e) {
                            var r, n = this._data,
                                i = n.words,
                                s = n.sigBytes,
                                a = this.blockSize,
                                o = s / (4 * a),
                                u = (o = e ? t.ceil(o) : t.max((0 | o) - this._minBufferSize, 0)) * a,
                                c = t.min(4 * u, s);
                            if (u) {
                                for (var l = 0; l < u; l += a) this._doProcessBlock(i, l);
                                r = i.splice(0, u), n.sigBytes -= c
                            }
                            return new h.init(r, c)
                        },
                        clone: function() {
                            var t = c.clone.call(this);
                            return t._data = this._data.clone(), t
                        },
                        _minBufferSize: 0
                    }),
                    y = (u.Hasher = g.extend({
                        cfg: c.extend(),
                        init: function(t) {
                            this.cfg = this.cfg.extend(t), this.reset()
                        },
                        reset: function() {
                            g.reset.call(this), this._doReset()
                        },
                        update: function(t) {
                            return this._append(t), this._process(), this
                        },
                        finalize: function(t) {
                            return t && this._append(t), this._doFinalize()
                        },
                        blockSize: 16,
                        _createHelper: function(t) {
                            return function(e, r) {
                                return new t.init(r).finalize(e)
                            }
                        },
                        _createHmacHelper: function(t) {
                            return function(e, r) {
                                return new y.HMAC.init(t, r).finalize(e)
                            }
                        }
                    }), o.algo = {});
                return o
            }(Math), n)
        }).call(this, r(52))
    }, function(t, e, r) {
        var n = r(0),
            i = r(53).f,
            s = r(24),
            a = r(19),
            o = r(132),
            u = r(158),
            c = r(86);
        t.exports = function(t, e) {
            var r, h, l, f, p, d = t.target,
                g = t.global,
                y = t.stat;
            if (r = g ? n : y ? n[d] || o(d, {}) : (n[d] || {}).prototype)
                for (h in e) {
                    if (f = e[h], l = t.noTargetGet ? (p = i(r, h)) && p.value : r[h], !c(g ? h : d + (y ? "." : "#") + h, t.forced) && void 0 !== l) {
                        if (typeof f == typeof l) continue;
                        u(f, l)
                    }(t.sham || l && l.sham) && s(f, "sham", !0), a(r, h, f, t)
                }
        }
    }, function(t, e, r) {
        (function() {
            var e;

            function r(t, e, r) {
                null != t && ("number" == typeof t ? this.fromNumber(t, e, r) : null == e && "string" != typeof t ? this.fromString(t, 256) : this.fromString(t, e))
            }

            function n() {
                return new r(null)
            }
            var i = "undefined" != typeof navigator;
            i && "Microsoft Internet Explorer" == navigator.appName ? (r.prototype.am = function(t, e, r, n, i, s) {
                for (var a = 32767 & e, o = e >> 15; --s >= 0;) {
                    var u = 32767 & this[t],
                        c = this[t++] >> 15,
                        h = o * u + c * a;
                    i = ((u = a * u + ((32767 & h) << 15) + r[n] + (1073741823 & i)) >>> 30) + (h >>> 15) + o * c + (i >>> 30), r[n++] = 1073741823 & u
                }
                return i
            }, e = 30) : i && "Netscape" != navigator.appName ? (r.prototype.am = function(t, e, r, n, i, s) {
                for (; --s >= 0;) {
                    var a = e * this[t++] + r[n] + i;
                    i = Math.floor(a / 67108864), r[n++] = 67108863 & a
                }
                return i
            }, e = 26) : (r.prototype.am = function(t, e, r, n, i, s) {
                for (var a = 16383 & e, o = e >> 14; --s >= 0;) {
                    var u = 16383 & this[t],
                        c = this[t++] >> 14,
                        h = o * u + c * a;
                    i = ((u = a * u + ((16383 & h) << 14) + r[n] + i) >> 28) + (h >> 14) + o * c, r[n++] = 268435455 & u
                }
                return i
            }, e = 28), r.prototype.DB = e, r.prototype.DM = (1 << e) - 1, r.prototype.DV = 1 << e;
            r.prototype.FV = Math.pow(2, 52), r.prototype.F1 = 52 - e, r.prototype.F2 = 2 * e - 52;
            var s, a, o = new Array;
            for (s = "0".charCodeAt(0), a = 0; a <= 9; ++a) o[s++] = a;
            for (s = "a".charCodeAt(0), a = 10; a < 36; ++a) o[s++] = a;
            for (s = "A".charCodeAt(0), a = 10; a < 36; ++a) o[s++] = a;

            function u(t) {
                return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(t)
            }

            function c(t, e) {
                var r = o[t.charCodeAt(e)];
                return null == r ? -1 : r
            }

            function h(t) {
                var e = n();
                return e.fromInt(t), e
            }

            function l(t) {
                var e, r = 1;
                return 0 != (e = t >>> 16) && (t = e, r += 16), 0 != (e = t >> 8) && (t = e, r += 8), 0 != (e = t >> 4) && (t = e, r += 4), 0 != (e = t >> 2) && (t = e, r += 2), 0 != (e = t >> 1) && (t = e, r += 1), r
            }

            function f(t) {
                this.m = t
            }

            function p(t) {
                this.m = t, this.mp = t.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << t.DB - 15) - 1, this.mt2 = 2 * t.t
            }

            function d(t, e) {
                return t & e
            }

            function g(t, e) {
                return t | e
            }

            function y(t, e) {
                return t ^ e
            }

            function v(t, e) {
                return t & ~e
            }

            function m(t) {
                if (0 == t) return -1;
                var e = 0;
                return 0 == (65535 & t) && (t >>= 16, e += 16), 0 == (255 & t) && (t >>= 8, e += 8), 0 == (15 & t) && (t >>= 4, e += 4), 0 == (3 & t) && (t >>= 2, e += 2), 0 == (1 & t) && ++e, e
            }

            function E(t) {
                for (var e = 0; 0 != t;) t &= t - 1, ++e;
                return e
            }

            function S() {}

            function b(t) {
                return t
            }

            function C(t) {
                this.r2 = n(), this.q3 = n(), r.ONE.dlShiftTo(2 * t.t, this.r2), this.mu = this.r2.divide(t), this.m = t
            }
            f.prototype.convert = function(t) {
                return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t
            }, f.prototype.revert = function(t) {
                return t
            }, f.prototype.reduce = function(t) {
                t.divRemTo(this.m, null, t)
            }, f.prototype.mulTo = function(t, e, r) {
                t.multiplyTo(e, r), this.reduce(r)
            }, f.prototype.sqrTo = function(t, e) {
                t.squareTo(e), this.reduce(e)
            }, p.prototype.convert = function(t) {
                var e = n();
                return t.abs().dlShiftTo(this.m.t, e), e.divRemTo(this.m, null, e), t.s < 0 && e.compareTo(r.ZERO) > 0 && this.m.subTo(e, e), e
            }, p.prototype.revert = function(t) {
                var e = n();
                return t.copyTo(e), this.reduce(e), e
            }, p.prototype.reduce = function(t) {
                for (; t.t <= this.mt2;) t[t.t++] = 0;
                for (var e = 0; e < this.m.t; ++e) {
                    var r = 32767 & t[e],
                        n = r * this.mpl + ((r * this.mph + (t[e] >> 15) * this.mpl & this.um) << 15) & t.DM;
                    for (t[r = e + this.m.t] += this.m.am(0, n, t, e, 0, this.m.t); t[r] >= t.DV;) t[r] -= t.DV, t[++r]++
                }
                t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t)
            }, p.prototype.mulTo = function(t, e, r) {
                t.multiplyTo(e, r), this.reduce(r)
            }, p.prototype.sqrTo = function(t, e) {
                t.squareTo(e), this.reduce(e)
            }, r.prototype.copyTo = function(t) {
                for (var e = this.t - 1; e >= 0; --e) t[e] = this[e];
                t.t = this.t, t.s = this.s
            }, r.prototype.fromInt = function(t) {
                this.t = 1, this.s = t < 0 ? -1 : 0, t > 0 ? this[0] = t : t < -1 ? this[0] = t + this.DV : this.t = 0
            }, r.prototype.fromString = function(t, e) {
                var n;
                if (16 == e) n = 4;
                else if (8 == e) n = 3;
                else if (256 == e) n = 8;
                else if (2 == e) n = 1;
                else if (32 == e) n = 5;
                else {
                    if (4 != e) return void this.fromRadix(t, e);
                    n = 2
                }
                this.t = 0, this.s = 0;
                for (var i = t.length, s = !1, a = 0; --i >= 0;) {
                    var o = 8 == n ? 255 & t[i] : c(t, i);
                    o < 0 ? "-" == t.charAt(i) && (s = !0) : (s = !1, 0 == a ? this[this.t++] = o : a + n > this.DB ? (this[this.t - 1] |= (o & (1 << this.DB - a) - 1) << a, this[this.t++] = o >> this.DB - a) : this[this.t - 1] |= o << a, (a += n) >= this.DB && (a -= this.DB))
                }
                8 == n && 0 != (128 & t[0]) && (this.s = -1, a > 0 && (this[this.t - 1] |= (1 << this.DB - a) - 1 << a)), this.clamp(), s && r.ZERO.subTo(this, this)
            }, r.prototype.clamp = function() {
                for (var t = this.s & this.DM; this.t > 0 && this[this.t - 1] == t;) --this.t
            }, r.prototype.dlShiftTo = function(t, e) {
                var r;
                for (r = this.t - 1; r >= 0; --r) e[r + t] = this[r];
                for (r = t - 1; r >= 0; --r) e[r] = 0;
                e.t = this.t + t, e.s = this.s
            }, r.prototype.drShiftTo = function(t, e) {
                for (var r = t; r < this.t; ++r) e[r - t] = this[r];
                e.t = Math.max(this.t - t, 0), e.s = this.s
            }, r.prototype.lShiftTo = function(t, e) {
                var r, n = t % this.DB,
                    i = this.DB - n,
                    s = (1 << i) - 1,
                    a = Math.floor(t / this.DB),
                    o = this.s << n & this.DM;
                for (r = this.t - 1; r >= 0; --r) e[r + a + 1] = this[r] >> i | o, o = (this[r] & s) << n;
                for (r = a - 1; r >= 0; --r) e[r] = 0;
                e[a] = o, e.t = this.t + a + 1, e.s = this.s, e.clamp()
            }, r.prototype.rShiftTo = function(t, e) {
                e.s = this.s;
                var r = Math.floor(t / this.DB);
                if (r >= this.t) e.t = 0;
                else {
                    var n = t % this.DB,
                        i = this.DB - n,
                        s = (1 << n) - 1;
                    e[0] = this[r] >> n;
                    for (var a = r + 1; a < this.t; ++a) e[a - r - 1] |= (this[a] & s) << i, e[a - r] = this[a] >> n;
                    n > 0 && (e[this.t - r - 1] |= (this.s & s) << i), e.t = this.t - r, e.clamp()
                }
            }, r.prototype.subTo = function(t, e) {
                for (var r = 0, n = 0, i = Math.min(t.t, this.t); r < i;) n += this[r] - t[r], e[r++] = n & this.DM, n >>= this.DB;
                if (t.t < this.t) {
                    for (n -= t.s; r < this.t;) n += this[r], e[r++] = n & this.DM, n >>= this.DB;
                    n += this.s
                } else {
                    for (n += this.s; r < t.t;) n -= t[r], e[r++] = n & this.DM, n >>= this.DB;
                    n -= t.s
                }
                e.s = n < 0 ? -1 : 0, n < -1 ? e[r++] = this.DV + n : n > 0 && (e[r++] = n), e.t = r, e.clamp()
            }, r.prototype.multiplyTo = function(t, e) {
                var n = this.abs(),
                    i = t.abs(),
                    s = n.t;
                for (e.t = s + i.t; --s >= 0;) e[s] = 0;
                for (s = 0; s < i.t; ++s) e[s + n.t] = n.am(0, i[s], e, s, 0, n.t);
                e.s = 0, e.clamp(), this.s != t.s && r.ZERO.subTo(e, e)
            }, r.prototype.squareTo = function(t) {
                for (var e = this.abs(), r = t.t = 2 * e.t; --r >= 0;) t[r] = 0;
                for (r = 0; r < e.t - 1; ++r) {
                    var n = e.am(r, e[r], t, 2 * r, 0, 1);
                    (t[r + e.t] += e.am(r + 1, 2 * e[r], t, 2 * r + 1, n, e.t - r - 1)) >= e.DV && (t[r + e.t] -= e.DV, t[r + e.t + 1] = 1)
                }
                t.t > 0 && (t[t.t - 1] += e.am(r, e[r], t, 2 * r, 0, 1)), t.s = 0, t.clamp()
            }, r.prototype.divRemTo = function(t, e, i) {
                var s = t.abs();
                if (!(s.t <= 0)) {
                    var a = this.abs();
                    if (a.t < s.t) return null != e && e.fromInt(0), void(null != i && this.copyTo(i));
                    null == i && (i = n());
                    var o = n(),
                        u = this.s,
                        c = t.s,
                        h = this.DB - l(s[s.t - 1]);
                    h > 0 ? (s.lShiftTo(h, o), a.lShiftTo(h, i)) : (s.copyTo(o), a.copyTo(i));
                    var f = o.t,
                        p = o[f - 1];
                    if (0 != p) {
                        var d = p * (1 << this.F1) + (f > 1 ? o[f - 2] >> this.F2 : 0),
                            g = this.FV / d,
                            y = (1 << this.F1) / d,
                            v = 1 << this.F2,
                            m = i.t,
                            E = m - f,
                            S = null == e ? n() : e;
                        for (o.dlShiftTo(E, S), i.compareTo(S) >= 0 && (i[i.t++] = 1, i.subTo(S, i)), r.ONE.dlShiftTo(f, S), S.subTo(o, o); o.t < f;) o[o.t++] = 0;
                        for (; --E >= 0;) {
                            var b = i[--m] == p ? this.DM : Math.floor(i[m] * g + (i[m - 1] + v) * y);
                            if ((i[m] += o.am(0, b, i, E, 0, f)) < b)
                                for (o.dlShiftTo(E, S), i.subTo(S, i); i[m] < --b;) i.subTo(S, i)
                        }
                        null != e && (i.drShiftTo(f, e), u != c && r.ZERO.subTo(e, e)), i.t = f, i.clamp(), h > 0 && i.rShiftTo(h, i), u < 0 && r.ZERO.subTo(i, i)
                    }
                }
            }, r.prototype.invDigit = function() {
                if (this.t < 1) return 0;
                var t = this[0];
                if (0 == (1 & t)) return 0;
                var e = 3 & t;
                return (e = (e = (e = (e = e * (2 - (15 & t) * e) & 15) * (2 - (255 & t) * e) & 255) * (2 - ((65535 & t) * e & 65535)) & 65535) * (2 - t * e % this.DV) % this.DV) > 0 ? this.DV - e : -e
            }, r.prototype.isEven = function() {
                return 0 == (this.t > 0 ? 1 & this[0] : this.s)
            }, r.prototype.exp = function(t, e) {
                if (t > 4294967295 || t < 1) return r.ONE;
                var i = n(),
                    s = n(),
                    a = e.convert(this),
                    o = l(t) - 1;
                for (a.copyTo(i); --o >= 0;)
                    if (e.sqrTo(i, s), (t & 1 << o) > 0) e.mulTo(s, a, i);
                    else {
                        var u = i;
                        i = s, s = u
                    }
                return e.revert(i)
            }, r.prototype.toString = function(t) {
                if (this.s < 0) return "-" + this.negate().toString(t);
                var e;
                if (16 == t) e = 4;
                else if (8 == t) e = 3;
                else if (2 == t) e = 1;
                else if (32 == t) e = 5;
                else {
                    if (4 != t) return this.toRadix(t);
                    e = 2
                }
                var r, n = (1 << e) - 1,
                    i = !1,
                    s = "",
                    a = this.t,
                    o = this.DB - a * this.DB % e;
                if (a-- > 0)
                    for (o < this.DB && (r = this[a] >> o) > 0 && (i = !0, s = u(r)); a >= 0;) o < e ? (r = (this[a] & (1 << o) - 1) << e - o, r |= this[--a] >> (o += this.DB - e)) : (r = this[a] >> (o -= e) & n, o <= 0 && (o += this.DB, --a)), r > 0 && (i = !0), i && (s += u(r));
                return i ? s : "0"
            }, r.prototype.negate = function() {
                var t = n();
                return r.ZERO.subTo(this, t), t
            }, r.prototype.abs = function() {
                return this.s < 0 ? this.negate() : this
            }, r.prototype.compareTo = function(t) {
                var e = this.s - t.s;
                if (0 != e) return e;
                var r = this.t;
                if (0 != (e = r - t.t)) return this.s < 0 ? -e : e;
                for (; --r >= 0;)
                    if (0 != (e = this[r] - t[r])) return e;
                return 0
            }, r.prototype.bitLength = function() {
                return this.t <= 0 ? 0 : this.DB * (this.t - 1) + l(this[this.t - 1] ^ this.s & this.DM)
            }, r.prototype.mod = function(t) {
                var e = n();
                return this.abs().divRemTo(t, null, e), this.s < 0 && e.compareTo(r.ZERO) > 0 && t.subTo(e, e), e
            }, r.prototype.modPowInt = function(t, e) {
                var r;
                return r = t < 256 || e.isEven() ? new f(e) : new p(e), this.exp(t, r)
            }, r.ZERO = h(0), r.ONE = h(1), S.prototype.convert = b, S.prototype.revert = b, S.prototype.mulTo = function(t, e, r) {
                t.multiplyTo(e, r)
            }, S.prototype.sqrTo = function(t, e) {
                t.squareTo(e)
            }, C.prototype.convert = function(t) {
                if (t.s < 0 || t.t > 2 * this.m.t) return t.mod(this.m);
                if (t.compareTo(this.m) < 0) return t;
                var e = n();
                return t.copyTo(e), this.reduce(e), e
            }, C.prototype.revert = function(t) {
                return t
            }, C.prototype.reduce = function(t) {
                for (t.drShiftTo(this.m.t - 1, this.r2), t.t > this.m.t + 1 && (t.t = this.m.t + 1, t.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t.compareTo(this.r2) < 0;) t.dAddOffset(1, this.m.t + 1);
                for (t.subTo(this.r2, t); t.compareTo(this.m) >= 0;) t.subTo(this.m, t)
            }, C.prototype.mulTo = function(t, e, r) {
                t.multiplyTo(e, r), this.reduce(r)
            }, C.prototype.sqrTo = function(t, e) {
                t.squareTo(e), this.reduce(e)
            };
            var A, w, T, x = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997],
                I = (1 << 26) / x[x.length - 1];

            function B() {
                var t;
                t = (new Date).getTime(), w[T++] ^= 255 & t, w[T++] ^= t >> 8 & 255, w[T++] ^= t >> 16 & 255, w[T++] ^= t >> 24 & 255, T >= k && (T -= k)
            }
            if (r.prototype.chunkSize = function(t) {
                    return Math.floor(Math.LN2 * this.DB / Math.log(t))
                }, r.prototype.toRadix = function(t) {
                    if (null == t && (t = 10), 0 == this.signum() || t < 2 || t > 36) return "0";
                    var e = this.chunkSize(t),
                        r = Math.pow(t, e),
                        i = h(r),
                        s = n(),
                        a = n(),
                        o = "";
                    for (this.divRemTo(i, s, a); s.signum() > 0;) o = (r + a.intValue()).toString(t).substr(1) + o, s.divRemTo(i, s, a);
                    return a.intValue().toString(t) + o
                }, r.prototype.fromRadix = function(t, e) {
                    this.fromInt(0), null == e && (e = 10);
                    for (var n = this.chunkSize(e), i = Math.pow(e, n), s = !1, a = 0, o = 0, u = 0; u < t.length; ++u) {
                        var h = c(t, u);
                        h < 0 ? "-" == t.charAt(u) && 0 == this.signum() && (s = !0) : (o = e * o + h, ++a >= n && (this.dMultiply(i), this.dAddOffset(o, 0), a = 0, o = 0))
                    }
                    a > 0 && (this.dMultiply(Math.pow(e, a)), this.dAddOffset(o, 0)), s && r.ZERO.subTo(this, this)
                }, r.prototype.fromNumber = function(t, e, n) {
                    if ("number" == typeof e)
                        if (t < 2) this.fromInt(1);
                        else
                            for (this.fromNumber(t, n), this.testBit(t - 1) || this.bitwiseTo(r.ONE.shiftLeft(t - 1), g, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e);) this.dAddOffset(2, 0), this.bitLength() > t && this.subTo(r.ONE.shiftLeft(t - 1), this);
                    else {
                        var i = new Array,
                            s = 7 & t;
                        i.length = 1 + (t >> 3), e.nextBytes(i), s > 0 ? i[0] &= (1 << s) - 1 : i[0] = 0, this.fromString(i, 256)
                    }
                }, r.prototype.bitwiseTo = function(t, e, r) {
                    var n, i, s = Math.min(t.t, this.t);
                    for (n = 0; n < s; ++n) r[n] = e(this[n], t[n]);
                    if (t.t < this.t) {
                        for (i = t.s & this.DM, n = s; n < this.t; ++n) r[n] = e(this[n], i);
                        r.t = this.t
                    } else {
                        for (i = this.s & this.DM, n = s; n < t.t; ++n) r[n] = e(i, t[n]);
                        r.t = t.t
                    }
                    r.s = e(this.s, t.s), r.clamp()
                }, r.prototype.changeBit = function(t, e) {
                    var n = r.ONE.shiftLeft(t);
                    return this.bitwiseTo(n, e, n), n
                }, r.prototype.addTo = function(t, e) {
                    for (var r = 0, n = 0, i = Math.min(t.t, this.t); r < i;) n += this[r] + t[r], e[r++] = n & this.DM, n >>= this.DB;
                    if (t.t < this.t) {
                        for (n += t.s; r < this.t;) n += this[r], e[r++] = n & this.DM, n >>= this.DB;
                        n += this.s
                    } else {
                        for (n += this.s; r < t.t;) n += t[r], e[r++] = n & this.DM, n >>= this.DB;
                        n += t.s
                    }
                    e.s = n < 0 ? -1 : 0, n > 0 ? e[r++] = n : n < -1 && (e[r++] = this.DV + n), e.t = r, e.clamp()
                }, r.prototype.dMultiply = function(t) {
                    this[this.t] = this.am(0, t - 1, this, 0, 0, this.t), ++this.t, this.clamp()
                }, r.prototype.dAddOffset = function(t, e) {
                    if (0 != t) {
                        for (; this.t <= e;) this[this.t++] = 0;
                        for (this[e] += t; this[e] >= this.DV;) this[e] -= this.DV, ++e >= this.t && (this[this.t++] = 0), ++this[e]
                    }
                }, r.prototype.multiplyLowerTo = function(t, e, r) {
                    var n, i = Math.min(this.t + t.t, e);
                    for (r.s = 0, r.t = i; i > 0;) r[--i] = 0;
                    for (n = r.t - this.t; i < n; ++i) r[i + this.t] = this.am(0, t[i], r, i, 0, this.t);
                    for (n = Math.min(t.t, e); i < n; ++i) this.am(0, t[i], r, i, 0, e - i);
                    r.clamp()
                }, r.prototype.multiplyUpperTo = function(t, e, r) {
                    --e;
                    var n = r.t = this.t + t.t - e;
                    for (r.s = 0; --n >= 0;) r[n] = 0;
                    for (n = Math.max(e - this.t, 0); n < t.t; ++n) r[this.t + n - e] = this.am(e - n, t[n], r, 0, 0, this.t + n - e);
                    r.clamp(), r.drShiftTo(1, r)
                }, r.prototype.modInt = function(t) {
                    if (t <= 0) return 0;
                    var e = this.DV % t,
                        r = this.s < 0 ? t - 1 : 0;
                    if (this.t > 0)
                        if (0 == e) r = this[0] % t;
                        else
                            for (var n = this.t - 1; n >= 0; --n) r = (e * r + this[n]) % t;
                    return r
                }, r.prototype.millerRabin = function(t) {
                    var e = this.subtract(r.ONE),
                        i = e.getLowestSetBit();
                    if (i <= 0) return !1;
                    var s = e.shiftRight(i);
                    (t = t + 1 >> 1) > x.length && (t = x.length);
                    for (var a = n(), o = 0; o < t; ++o) {
                        a.fromInt(x[Math.floor(Math.random() * x.length)]);
                        var u = a.modPow(s, this);
                        if (0 != u.compareTo(r.ONE) && 0 != u.compareTo(e)) {
                            for (var c = 1; c++ < i && 0 != u.compareTo(e);)
                                if (0 == (u = u.modPowInt(2, this)).compareTo(r.ONE)) return !1;
                            if (0 != u.compareTo(e)) return !1
                        }
                    }
                    return !0
                }, r.prototype.clone = function() {
                    var t = n();
                    return this.copyTo(t), t
                }, r.prototype.intValue = function() {
                    if (this.s < 0) {
                        if (1 == this.t) return this[0] - this.DV;
                        if (0 == this.t) return -1
                    } else {
                        if (1 == this.t) return this[0];
                        if (0 == this.t) return 0
                    }
                    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0]
                }, r.prototype.byteValue = function() {
                    return 0 == this.t ? this.s : this[0] << 24 >> 24
                }, r.prototype.shortValue = function() {
                    return 0 == this.t ? this.s : this[0] << 16 >> 16
                }, r.prototype.signum = function() {
                    return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this[0] <= 0 ? 0 : 1
                }, r.prototype.toByteArray = function() {
                    var t = this.t,
                        e = new Array;
                    e[0] = this.s;
                    var r, n = this.DB - t * this.DB % 8,
                        i = 0;
                    if (t-- > 0)
                        for (n < this.DB && (r = this[t] >> n) != (this.s & this.DM) >> n && (e[i++] = r | this.s << this.DB - n); t >= 0;) n < 8 ? (r = (this[t] & (1 << n) - 1) << 8 - n, r |= this[--t] >> (n += this.DB - 8)) : (r = this[t] >> (n -= 8) & 255, n <= 0 && (n += this.DB, --t)), 0 != (128 & r) && (r |= -256), 0 == i && (128 & this.s) != (128 & r) && ++i, (i > 0 || r != this.s) && (e[i++] = r);
                    return e
                }, r.prototype.equals = function(t) {
                    return 0 == this.compareTo(t)
                }, r.prototype.min = function(t) {
                    return this.compareTo(t) < 0 ? this : t
                }, r.prototype.max = function(t) {
                    return this.compareTo(t) > 0 ? this : t
                }, r.prototype.and = function(t) {
                    var e = n();
                    return this.bitwiseTo(t, d, e), e
                }, r.prototype.or = function(t) {
                    var e = n();
                    return this.bitwiseTo(t, g, e), e
                }, r.prototype.xor = function(t) {
                    var e = n();
                    return this.bitwiseTo(t, y, e), e
                }, r.prototype.andNot = function(t) {
                    var e = n();
                    return this.bitwiseTo(t, v, e), e
                }, r.prototype.not = function() {
                    for (var t = n(), e = 0; e < this.t; ++e) t[e] = this.DM & ~this[e];
                    return t.t = this.t, t.s = ~this.s, t
                }, r.prototype.shiftLeft = function(t) {
                    var e = n();
                    return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e), e
                }, r.prototype.shiftRight = function(t) {
                    var e = n();
                    return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e), e
                }, r.prototype.getLowestSetBit = function() {
                    for (var t = 0; t < this.t; ++t)
                        if (0 != this[t]) return t * this.DB + m(this[t]);
                    return this.s < 0 ? this.t * this.DB : -1
                }, r.prototype.bitCount = function() {
                    for (var t = 0, e = this.s & this.DM, r = 0; r < this.t; ++r) t += E(this[r] ^ e);
                    return t
                }, r.prototype.testBit = function(t) {
                    var e = Math.floor(t / this.DB);
                    return e >= this.t ? 0 != this.s : 0 != (this[e] & 1 << t % this.DB)
                }, r.prototype.setBit = function(t) {
                    return this.changeBit(t, g)
                }, r.prototype.clearBit = function(t) {
                    return this.changeBit(t, v)
                }, r.prototype.flipBit = function(t) {
                    return this.changeBit(t, y)
                }, r.prototype.add = function(t) {
                    var e = n();
                    return this.addTo(t, e), e
                }, r.prototype.subtract = function(t) {
                    var e = n();
                    return this.subTo(t, e), e
                }, r.prototype.multiply = function(t) {
                    var e = n();
                    return this.multiplyTo(t, e), e
                }, r.prototype.divide = function(t) {
                    var e = n();
                    return this.divRemTo(t, e, null), e
                }, r.prototype.remainder = function(t) {
                    var e = n();
                    return this.divRemTo(t, null, e), e
                }, r.prototype.divideAndRemainder = function(t) {
                    var e = n(),
                        r = n();
                    return this.divRemTo(t, e, r), new Array(e, r)
                }, r.prototype.modPow = function(t, e) {
                    var r, i, s = t.bitLength(),
                        a = h(1);
                    if (s <= 0) return a;
                    r = s < 18 ? 1 : s < 48 ? 3 : s < 144 ? 4 : s < 768 ? 5 : 6, i = s < 8 ? new f(e) : e.isEven() ? new C(e) : new p(e);
                    var o = new Array,
                        u = 3,
                        c = r - 1,
                        d = (1 << r) - 1;
                    if (o[1] = i.convert(this), r > 1) {
                        var g = n();
                        for (i.sqrTo(o[1], g); u <= d;) o[u] = n(), i.mulTo(g, o[u - 2], o[u]), u += 2
                    }
                    var y, v, m = t.t - 1,
                        E = !0,
                        S = n();
                    for (s = l(t[m]) - 1; m >= 0;) {
                        for (s >= c ? y = t[m] >> s - c & d : (y = (t[m] & (1 << s + 1) - 1) << c - s, m > 0 && (y |= t[m - 1] >> this.DB + s - c)), u = r; 0 == (1 & y);) y >>= 1, --u;
                        if ((s -= u) < 0 && (s += this.DB, --m), E) o[y].copyTo(a), E = !1;
                        else {
                            for (; u > 1;) i.sqrTo(a, S), i.sqrTo(S, a), u -= 2;
                            u > 0 ? i.sqrTo(a, S) : (v = a, a = S, S = v), i.mulTo(S, o[y], a)
                        }
                        for (; m >= 0 && 0 == (t[m] & 1 << s);) i.sqrTo(a, S), v = a, a = S, S = v, --s < 0 && (s = this.DB - 1, --m)
                    }
                    return i.revert(a)
                }, r.prototype.modInverse = function(t) {
                    var e = t.isEven();
                    if (this.isEven() && e || 0 == t.signum()) return r.ZERO;
                    for (var n = t.clone(), i = this.clone(), s = h(1), a = h(0), o = h(0), u = h(1); 0 != n.signum();) {
                        for (; n.isEven();) n.rShiftTo(1, n), e ? (s.isEven() && a.isEven() || (s.addTo(this, s), a.subTo(t, a)), s.rShiftTo(1, s)) : a.isEven() || a.subTo(t, a), a.rShiftTo(1, a);
                        for (; i.isEven();) i.rShiftTo(1, i), e ? (o.isEven() && u.isEven() || (o.addTo(this, o), u.subTo(t, u)), o.rShiftTo(1, o)) : u.isEven() || u.subTo(t, u), u.rShiftTo(1, u);
                        n.compareTo(i) >= 0 ? (n.subTo(i, n), e && s.subTo(o, s), a.subTo(u, a)) : (i.subTo(n, i), e && o.subTo(s, o), u.subTo(a, u))
                    }
                    return 0 != i.compareTo(r.ONE) ? r.ZERO : u.compareTo(t) >= 0 ? u.subtract(t) : u.signum() < 0 ? (u.addTo(t, u), u.signum() < 0 ? u.add(t) : u) : u
                }, r.prototype.pow = function(t) {
                    return this.exp(t, new S)
                }, r.prototype.gcd = function(t) {
                    var e = this.s < 0 ? this.negate() : this.clone(),
                        r = t.s < 0 ? t.negate() : t.clone();
                    if (e.compareTo(r) < 0) {
                        var n = e;
                        e = r, r = n
                    }
                    var i = e.getLowestSetBit(),
                        s = r.getLowestSetBit();
                    if (s < 0) return e;
                    for (i < s && (s = i), s > 0 && (e.rShiftTo(s, e), r.rShiftTo(s, r)); e.signum() > 0;)(i = e.getLowestSetBit()) > 0 && e.rShiftTo(i, e), (i = r.getLowestSetBit()) > 0 && r.rShiftTo(i, r), e.compareTo(r) >= 0 ? (e.subTo(r, e), e.rShiftTo(1, e)) : (r.subTo(e, r), r.rShiftTo(1, r));
                    return s > 0 && r.lShiftTo(s, r), r
                }, r.prototype.isProbablePrime = function(t) {
                    var e, r = this.abs();
                    if (1 == r.t && r[0] <= x[x.length - 1]) {
                        for (e = 0; e < x.length; ++e)
                            if (r[0] == x[e]) return !0;
                        return !1
                    }
                    if (r.isEven()) return !1;
                    for (e = 1; e < x.length;) {
                        for (var n = x[e], i = e + 1; i < x.length && n < I;) n *= x[i++];
                        for (n = r.modInt(n); e < i;)
                            if (n % x[e++] == 0) return !1
                    }
                    return r.millerRabin(t)
                }, r.prototype.square = function() {
                    var t = n();
                    return this.squareTo(t), t
                }, r.prototype.Barrett = C, null == w) {
                var F;
                if (w = new Array, T = 0, "undefined" != typeof window && window.crypto)
                    if (window.crypto.getRandomValues) {
                        var R = new Uint8Array(32);
                        for (window.crypto.getRandomValues(R), F = 0; F < 32; ++F) w[T++] = R[F]
                    } else if ("Netscape" == navigator.appName && navigator.appVersion < "5") {
                    var D = window.crypto.random(32);
                    for (F = 0; F < D.length; ++F) w[T++] = 255 & D.charCodeAt(F)
                }
                for (; T < k;) F = Math.floor(65536 * Math.random()), w[T++] = F >>> 8, w[T++] = 255 & F;
                T = 0, B()
            }

            function N() {
                if (null == A) {
                    for (B(), (A = new P).init(w), T = 0; T < w.length; ++T) w[T] = 0;
                    T = 0
                }
                return A.next()
            }

            function _() {}

            function P() {
                this.i = 0, this.j = 0, this.S = new Array
            }
            _.prototype.nextBytes = function(t) {
                var e;
                for (e = 0; e < t.length; ++e) t[e] = N()
            }, P.prototype.init = function(t) {
                var e, r, n;
                for (e = 0; e < 256; ++e) this.S[e] = e;
                for (r = 0, e = 0; e < 256; ++e) r = r + this.S[e] + t[e % t.length] & 255, n = this.S[e], this.S[e] = this.S[r], this.S[r] = n;
                this.i = 0, this.j = 0
            }, P.prototype.next = function() {
                var t;
                return this.i = this.i + 1 & 255, this.j = this.j + this.S[this.i] & 255, t = this.S[this.i], this.S[this.i] = this.S[this.j], this.S[this.j] = t, this.S[t + this.S[this.i] & 255]
            };
            var k = 256;
            t.exports = {
                default: r,
                BigInteger: r,
                SecureRandom: _
            }
        }).call(this)
    }, function(t, e, r) {
        var n = r(0),
            i = r(80),
            s = r(12),
            a = r(81),
            o = r(130),
            u = r(156),
            c = i("wks"),
            h = n.Symbol,
            l = h && h.for,
            f = u ? h : h && h.withoutSetter || a;
        t.exports = function(t) {
            if (!s(c, t) || !o && "string" != typeof c[t]) {
                var e = "Symbol." + t;
                o && s(h, t) ? c[t] = h[t] : c[t] = u && l ? l(e) : f(e)
            }
            return c[t]
        }
    }, function(t, e, r) {
        "use strict";
        var n, i, s, a = r(142),
            o = r(13),
            u = r(0),
            c = r(9),
            h = r(14),
            l = r(12),
            f = r(46),
            p = r(64),
            d = r(24),
            g = r(19),
            y = r(16).f,
            v = r(29),
            m = r(71),
            E = r(48),
            S = r(7),
            b = r(81),
            C = u.Int8Array,
            A = C && C.prototype,
            w = u.Uint8ClampedArray,
            T = w && w.prototype,
            x = C && m(C),
            I = A && m(A),
            B = Object.prototype,
            F = u.TypeError,
            R = S("toStringTag"),
            D = b("TYPED_ARRAY_TAG"),
            N = b("TYPED_ARRAY_CONSTRUCTOR"),
            _ = a && !!E && "Opera" !== f(u.opera),
            P = !1,
            k = {
                Int8Array: 1,
                Uint8Array: 1,
                Uint8ClampedArray: 1,
                Int16Array: 2,
                Uint16Array: 2,
                Int32Array: 4,
                Uint32Array: 4,
                Float32Array: 4,
                Float64Array: 8
            },
            L = {
                BigInt64Array: 8,
                BigUint64Array: 8
            },
            O = function(t) {
                if (!h(t)) return !1;
                var e = f(t);
                return l(k, e) || l(L, e)
            };
        for (n in k)(s = (i = u[n]) && i.prototype) ? d(s, N, i) : _ = !1;
        for (n in L)(s = (i = u[n]) && i.prototype) && d(s, N, i);
        if ((!_ || !c(x) || x === Function.prototype) && (x = function() {
                throw F("Incorrect invocation")
            }, _))
            for (n in k) u[n] && E(u[n], x);
        if ((!_ || !I || I === B) && (I = x.prototype, _))
            for (n in k) u[n] && E(u[n].prototype, I);
        if (_ && m(T) !== I && E(T, I), o && !l(I, R))
            for (n in P = !0, y(I, R, {
                    get: function() {
                        return h(this) ? this[D] : void 0
                    }
                }), k) u[n] && d(u[n], D, n);
        t.exports = {
            NATIVE_ARRAY_BUFFER_VIEWS: _,
            TYPED_ARRAY_CONSTRUCTOR: N,
            TYPED_ARRAY_TAG: P && D,
            aTypedArray: function(t) {
                if (O(t)) return t;
                throw F("Target is not a typed array")
            },
            aTypedArrayConstructor: function(t) {
                if (c(t) && (!E || v(x, t))) return t;
                throw F(p(t) + " is not a typed array constructor")
            },
            exportTypedArrayMethod: function(t, e, r) {
                if (o) {
                    if (r)
                        for (var n in k) {
                            var i = u[n];
                            if (i && l(i.prototype, t)) try {
                                delete i.prototype[t]
                            } catch (t) {}
                        }
                    I[t] && !r || g(I, t, r ? e : _ && A[t] || e)
                }
            },
            exportTypedArrayStaticMethod: function(t, e, r) {
                var n, i;
                if (o) {
                    if (E) {
                        if (r)
                            for (n in k)
                                if ((i = u[n]) && l(i, t)) try {
                                    delete i[t]
                                } catch (t) {}
                        if (x[t] && !r) return;
                        try {
                            return g(x, t, r ? e : _ && x[t] || e)
                        } catch (t) {}
                    }
                    for (n in k) !(i = u[n]) || i[t] && !r || g(i, t, e)
                }
            },
            isView: function(t) {
                if (!h(t)) return !1;
                var e = f(t);
                return "DataView" === e || l(k, e) || l(L, e)
            },
            isTypedArray: O,
            TypedArray: x,
            TypedArrayPrototype: I
        }
    }, function(t, e) {
        t.exports = function(t) {
            return "function" == typeof t
        }
    }, function(t, e) {
        var r = Function.prototype.call;
        t.exports = r.bind ? r.bind(r) : function() {
            return r.apply(r, arguments)
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(14),
            s = n.String,
            a = n.TypeError;
        t.exports = function(t) {
            if (i(t)) return t;
            throw a(s(t) + " is not an object")
        }
    }, function(t, e, r) {
        var n = r(1),
            i = r(15),
            s = n({}.hasOwnProperty);
        t.exports = Object.hasOwn || function(t, e) {
            return s(i(t), e)
        }
    }, function(t, e, r) {
        var n = r(3);
        t.exports = !n((function() {
            return 7 != Object.defineProperty({}, 1, {
                get: function() {
                    return 7
                }
            })[1]
        }))
    }, function(t, e, r) {
        var n = r(9);
        t.exports = function(t) {
            return "object" == typeof t ? null !== t : n(t)
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(27),
            s = n.Object;
        t.exports = function(t) {
            return s(i(t))
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(13),
            s = r(157),
            a = r(11),
            o = r(62),
            u = n.TypeError,
            c = Object.defineProperty;
        e.f = i ? c : function(t, e, r) {
            if (a(t), e = o(e), a(r), s) try {
                return c(t, e, r)
            } catch (t) {}
            if ("get" in r || "set" in r) throw u("Accessors not supported");
            return "value" in r && (t[e] = r.value), t
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(46),
            s = n.String;
        t.exports = function(t) {
            if ("Symbol" === i(t)) throw TypeError("Cannot convert a Symbol value to a string");
            return s(t)
        }
    }, function(t, e, r) {
        var n, i, s, a, o, u, c, h, l, f, p, d, g, y, v, m, E, S, b;
        t.exports = (n = r(4), r(50), void(n.lib.Cipher || (i = n, s = i.lib, a = s.Base, o = s.WordArray, u = s.BufferedBlockAlgorithm, c = i.enc, c.Utf8, h = c.Base64, l = i.algo.EvpKDF, f = s.Cipher = u.extend({
            cfg: a.extend(),
            createEncryptor: function(t, e) {
                return this.create(this._ENC_XFORM_MODE, t, e)
            },
            createDecryptor: function(t, e) {
                return this.create(this._DEC_XFORM_MODE, t, e)
            },
            init: function(t, e, r) {
                this.cfg = this.cfg.extend(r), this._xformMode = t, this._key = e, this.reset()
            },
            reset: function() {
                u.reset.call(this), this._doReset()
            },
            process: function(t) {
                return this._append(t), this._process()
            },
            finalize: function(t) {
                return t && this._append(t), this._doFinalize()
            },
            keySize: 4,
            ivSize: 4,
            _ENC_XFORM_MODE: 1,
            _DEC_XFORM_MODE: 2,
            _createHelper: function() {
                function t(t) {
                    return "string" == typeof t ? b : E
                }
                return function(e) {
                    return {
                        encrypt: function(r, n, i) {
                            return t(n).encrypt(e, r, n, i)
                        },
                        decrypt: function(r, n, i) {
                            return t(n).decrypt(e, r, n, i)
                        }
                    }
                }
            }()
        }), s.StreamCipher = f.extend({
            _doFinalize: function() {
                return this._process(!0)
            },
            blockSize: 1
        }), p = i.mode = {}, d = s.BlockCipherMode = a.extend({
            createEncryptor: function(t, e) {
                return this.Encryptor.create(t, e)
            },
            createDecryptor: function(t, e) {
                return this.Decryptor.create(t, e)
            },
            init: function(t, e) {
                this._cipher = t, this._iv = e
            }
        }), g = p.CBC = function() {
            var t = d.extend();

            function e(t, e, r) {
                var n, i = this._iv;
                i ? (n = i, this._iv = void 0) : n = this._prevBlock;
                for (var s = 0; s < r; s++) t[e + s] ^= n[s]
            }
            return t.Encryptor = t.extend({
                processBlock: function(t, r) {
                    var n = this._cipher,
                        i = n.blockSize;
                    e.call(this, t, r, i), n.encryptBlock(t, r), this._prevBlock = t.slice(r, r + i)
                }
            }), t.Decryptor = t.extend({
                processBlock: function(t, r) {
                    var n = this._cipher,
                        i = n.blockSize,
                        s = t.slice(r, r + i);
                    n.decryptBlock(t, r), e.call(this, t, r, i), this._prevBlock = s
                }
            }), t
        }(), y = (i.pad = {}).Pkcs7 = {
            pad: function(t, e) {
                for (var r = 4 * e, n = r - t.sigBytes % r, i = n << 24 | n << 16 | n << 8 | n, s = [], a = 0; a < n; a += 4) s.push(i);
                var u = o.create(s, n);
                t.concat(u)
            },
            unpad: function(t) {
                var e = 255 & t.words[t.sigBytes - 1 >>> 2];
                t.sigBytes -= e
            }
        }, s.BlockCipher = f.extend({
            cfg: f.cfg.extend({
                mode: g,
                padding: y
            }),
            reset: function() {
                var t;
                f.reset.call(this);
                var e = this.cfg,
                    r = e.iv,
                    n = e.mode;
                this._xformMode == this._ENC_XFORM_MODE ? t = n.createEncryptor : (t = n.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == t ? this._mode.init(this, r && r.words) : (this._mode = t.call(n, this, r && r.words), this._mode.__creator = t)
            },
            _doProcessBlock: function(t, e) {
                this._mode.processBlock(t, e)
            },
            _doFinalize: function() {
                var t, e = this.cfg.padding;
                return this._xformMode == this._ENC_XFORM_MODE ? (e.pad(this._data, this.blockSize), t = this._process(!0)) : (t = this._process(!0), e.unpad(t)), t
            },
            blockSize: 4
        }), v = s.CipherParams = a.extend({
            init: function(t) {
                this.mixIn(t)
            },
            toString: function(t) {
                return (t || this.formatter).stringify(this)
            }
        }), m = (i.format = {}).OpenSSL = {
            stringify: function(t) {
                var e = t.ciphertext,
                    r = t.salt;
                return (r ? o.create([1398893684, 1701076831]).concat(r).concat(e) : e).toString(h)
            },
            parse: function(t) {
                var e, r = h.parse(t),
                    n = r.words;
                return 1398893684 == n[0] && 1701076831 == n[1] && (e = o.create(n.slice(2, 4)), n.splice(0, 4), r.sigBytes -= 16), v.create({
                    ciphertext: r,
                    salt: e
                })
            }
        }, E = s.SerializableCipher = a.extend({
            cfg: a.extend({
                format: m
            }),
            encrypt: function(t, e, r, n) {
                n = this.cfg.extend(n);
                var i = t.createEncryptor(r, n),
                    s = i.finalize(e),
                    a = i.cfg;
                return v.create({
                    ciphertext: s,
                    key: r,
                    iv: a.iv,
                    algorithm: t,
                    mode: a.mode,
                    padding: a.padding,
                    blockSize: t.blockSize,
                    formatter: n.format
                })
            },
            decrypt: function(t, e, r, n) {
                return n = this.cfg.extend(n), e = this._parse(e, n.format), t.createDecryptor(r, n).finalize(e.ciphertext)
            },
            _parse: function(t, e) {
                return "string" == typeof t ? e.parse(t, this) : t
            }
        }), S = (i.kdf = {}).OpenSSL = {
            execute: function(t, e, r, n) {
                n || (n = o.random(8));
                var i = l.create({
                        keySize: e + r
                    }).compute(t, n),
                    s = o.create(i.words.slice(e), 4 * r);
                return i.sigBytes = 4 * e, v.create({
                    key: i,
                    iv: s,
                    salt: n
                })
            }
        }, b = s.PasswordBasedCipher = E.extend({
            cfg: E.cfg.extend({
                kdf: S
            }),
            encrypt: function(t, e, r, n) {
                var i = (n = this.cfg.extend(n)).kdf.execute(r, t.keySize, t.ivSize);
                n.iv = i.iv;
                var s = E.encrypt.call(this, t, e, i.key, n);
                return s.mixIn(i), s
            },
            decrypt: function(t, e, r, n) {
                n = this.cfg.extend(n), e = this._parse(e, n.format);
                var i = n.kdf.execute(r, t.keySize, t.ivSize, e.salt);
                return n.iv = i.iv, E.decrypt.call(this, t, e, i.key, n)
            }
        }))))
    }, function(t, e, r) {
        var n = r(0),
            i = r(9),
            s = r(12),
            a = r(24),
            o = r(132),
            u = r(83),
            c = r(25),
            h = r(55).CONFIGURABLE,
            l = c.get,
            f = c.enforce,
            p = String(String).split("String");
        (t.exports = function(t, e, r, u) {
            var c, l = !!u && !!u.unsafe,
                d = !!u && !!u.enumerable,
                g = !!u && !!u.noTargetGet,
                y = u && void 0 !== u.name ? u.name : e;
            i(r) && ("Symbol(" === String(y).slice(0, 7) && (y = "[" + String(y).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!s(r, "name") || h && r.name !== y) && a(r, "name", y), (c = f(r)).source || (c.source = p.join("string" == typeof y ? y : ""))), t !== n ? (l ? !g && t[e] && (d = !0) : delete t[e], d ? t[e] = r : a(t, e, r)) : d ? t[e] = r : o(e, r)
        })(Function.prototype, "toString", (function() {
            return i(this) && l(this).source || u(this)
        }))
    }, function(t, e, r) {
        var n = r(33);
        t.exports = function(t) {
            return n(t.length)
        }
    }, function(t, e, r) {
        var n = r(1);
        t.exports = n([].slice)
    }, function(t, e, r) {
        var n = r(39),
            i = r(1),
            s = r(61),
            a = r(15),
            o = r(20),
            u = r(141),
            c = i([].push),
            h = function(t) {
                var e = 1 == t,
                    r = 2 == t,
                    i = 3 == t,
                    h = 4 == t,
                    l = 6 == t,
                    f = 7 == t,
                    p = 5 == t || l;
                return function(d, g, y, v) {
                    for (var m, E, S = a(d), b = s(S), C = n(g, y), A = o(b), w = 0, T = v || u, x = e ? T(d, A) : r || f ? T(d, 0) : void 0; A > w; w++)
                        if ((p || w in b) && (E = C(m = b[w], w, S), t))
                            if (e) x[w] = E;
                            else if (E) switch (t) {
                        case 3:
                            return !0;
                        case 5:
                            return m;
                        case 6:
                            return w;
                        case 2:
                            c(x, m)
                    } else switch (t) {
                        case 4:
                            return !1;
                        case 7:
                            c(x, m)
                    }
                    return l ? -1 : i || h ? h : x
                }
            };
        t.exports = {
            forEach: h(0),
            map: h(1),
            filter: h(2),
            some: h(3),
            every: h(4),
            find: h(5),
            findIndex: h(6),
            filterReject: h(7)
        }
    }, function(t, e, r) {
        var n = r(61),
            i = r(27);
        t.exports = function(t) {
            return n(i(t))
        }
    }, function(t, e, r) {
        var n = r(13),
            i = r(16),
            s = r(40);
        t.exports = n ? function(t, e, r) {
            return i.f(t, e, s(1, r))
        } : function(t, e, r) {
            return t[e] = r, t
        }
    }, function(t, e, r) {
        var n, i, s, a = r(203),
            o = r(0),
            u = r(1),
            c = r(14),
            h = r(24),
            l = r(12),
            f = r(131),
            p = r(84),
            d = r(85),
            g = o.TypeError,
            y = o.WeakMap;
        if (a || f.state) {
            var v = f.state || (f.state = new y),
                m = u(v.get),
                E = u(v.has),
                S = u(v.set);
            n = function(t, e) {
                if (E(v, t)) throw new g("Object already initialized");
                return e.facade = t, S(v, t, e), e
            }, i = function(t) {
                return m(v, t) || {}
            }, s = function(t) {
                return E(v, t)
            }
        } else {
            var b = p("state");
            d[b] = !0, n = function(t, e) {
                if (l(t, b)) throw new g("Object already initialized");
                return e.facade = t, h(t, b, e), e
            }, i = function(t) {
                return l(t, b) ? t[b] : {}
            }, s = function(t) {
                return l(t, b)
            }
        }
        t.exports = {
            set: n,
            get: i,
            has: s,
            enforce: function(t) {
                return s(t) ? i(t) : n(t, {})
            },
            getterFor: function(t) {
                return function(e) {
                    var r;
                    if (!c(e) || (r = i(e)).type !== t) throw g("Incompatible receiver, " + t + " required");
                    return r
                }
            }
        }
    }, function(t, e) {
        var r = Math.ceil,
            n = Math.floor;
        t.exports = function(t) {
            var e = +t;
            return e != e || 0 === e ? 0 : (e > 0 ? n : r)(e)
        }
    }, function(t, e, r) {
        var n = r(0).TypeError;
        t.exports = function(t) {
            if (null == t) throw n("Can't call method on " + t);
            return t
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(9),
            s = function(t) {
                return i(t) ? t : void 0
            };
        t.exports = function(t, e) {
            return arguments.length < 2 ? s(n[t]) : n[t] && n[t][e]
        }
    }, function(t, e, r) {
        var n = r(1);
        t.exports = n({}.isPrototypeOf)
    }, function(t, e, r) {
        var n = r(135),
            i = r(19),
            s = r(205);
        n || i(Object.prototype, "toString", s, {
            unsafe: !0
        })
    }, function(t, e, r) {
        "use strict";
        var n = r(23),
            i = r(172),
            s = r(72),
            a = r(25),
            o = r(166),
            u = a.set,
            c = a.getterFor("Array Iterator");
        t.exports = o(Array, "Array", (function(t, e) {
            u(this, {
                type: "Array Iterator",
                target: n(t),
                index: 0,
                kind: e
            })
        }), (function() {
            var t = c(this),
                e = t.target,
                r = t.kind,
                n = t.index++;
            return !e || n >= e.length ? (t.target = void 0, {
                value: void 0,
                done: !0
            }) : "keys" == r ? {
                value: n,
                done: !1
            } : "values" == r ? {
                value: e[n],
                done: !1
            } : {
                value: [n, e[n]],
                done: !1
            }
        }), "values"), s.Arguments = s.Array, i("keys"), i("values"), i("entries")
    }, function(t, e, r) {
        var n = r(0),
            i = r(9),
            s = r(64),
            a = n.TypeError;
        t.exports = function(t) {
            if (i(t)) return t;
            throw a(s(t) + " is not a function")
        }
    }, function(t, e, r) {
        var n = r(26),
            i = Math.min;
        t.exports = function(t) {
            return t > 0 ? i(n(t), 9007199254740991) : 0
        }
    }, function(t, e) {
        var r = Function.prototype,
            n = r.apply,
            i = r.bind,
            s = r.call;
        t.exports = "object" == typeof Reflect && Reflect.apply || (i ? s.bind(n) : function() {
            return s.apply(n, arguments)
        })
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(0),
            s = r(10),
            a = r(13),
            o = r(214),
            u = r(8),
            c = r(96),
            h = r(74),
            l = r(40),
            f = r(24),
            p = r(215),
            d = r(33),
            g = r(174),
            y = r(176),
            v = r(62),
            m = r(12),
            E = r(46),
            S = r(14),
            b = r(63),
            C = r(37),
            A = r(29),
            w = r(48),
            T = r(44).f,
            x = r(217),
            I = r(22).forEach,
            B = r(97),
            F = r(16),
            R = r(53),
            D = r(25),
            N = r(146),
            _ = D.get,
            P = D.set,
            k = F.f,
            L = R.f,
            O = Math.round,
            U = i.RangeError,
            V = c.ArrayBuffer,
            H = V.prototype,
            j = c.DataView,
            M = u.NATIVE_ARRAY_BUFFER_VIEWS,
            K = u.TYPED_ARRAY_CONSTRUCTOR,
            q = u.TYPED_ARRAY_TAG,
            z = u.TypedArray,
            G = u.TypedArrayPrototype,
            Y = u.aTypedArrayConstructor,
            W = u.isTypedArray,
            X = function(t, e) {
                Y(t);
                for (var r = 0, n = e.length, i = new t(n); n > r;) i[r] = e[r++];
                return i
            },
            Q = function(t, e) {
                k(t, e, {
                    get: function() {
                        return _(this)[e]
                    }
                })
            },
            Z = function(t) {
                var e;
                return A(H, t) || "ArrayBuffer" == (e = E(t)) || "SharedArrayBuffer" == e
            },
            J = function(t, e) {
                return W(t) && !b(e) && e in t && p(+e) && e >= 0
            },
            $ = function(t, e) {
                return e = v(e), J(t, e) ? l(2, t[e]) : L(t, e)
            },
            tt = function(t, e, r) {
                return e = v(e), !(J(t, e) && S(r) && m(r, "value")) || m(r, "get") || m(r, "set") || r.configurable || m(r, "writable") && !r.writable || m(r, "enumerable") && !r.enumerable ? k(t, e, r) : (t[e] = r.value, t)
            };
        a ? (M || (R.f = $, F.f = tt, Q(G, "buffer"), Q(G, "byteOffset"), Q(G, "byteLength"), Q(G, "length")), n({
            target: "Object",
            stat: !0,
            forced: !M
        }, {
            getOwnPropertyDescriptor: $,
            defineProperty: tt
        }), t.exports = function(t, e, r) {
            var a = t.match(/\d+$/)[0] / 8,
                u = t + (r ? "Clamped" : "") + "Array",
                c = "get" + t,
                l = "set" + t,
                p = i[u],
                v = p,
                m = v && v.prototype,
                E = {},
                b = function(t, e) {
                    k(t, e, {
                        get: function() {
                            return function(t, e) {
                                var r = _(t);
                                return r.view[c](e * a + r.byteOffset, !0)
                            }(this, e)
                        },
                        set: function(t) {
                            return function(t, e, n) {
                                var i = _(t);
                                r && (n = (n = O(n)) < 0 ? 0 : n > 255 ? 255 : 255 & n), i.view[l](e * a + i.byteOffset, n, !0)
                            }(this, e, t)
                        },
                        enumerable: !0
                    })
                };
            M ? o && (v = e((function(t, e, r, n) {
                return h(t, m), N(S(e) ? Z(e) ? void 0 !== n ? new p(e, y(r, a), n) : void 0 !== r ? new p(e, y(r, a)) : new p(e) : W(e) ? X(v, e) : s(x, v, e) : new p(g(e)), t, v)
            })), w && w(v, z), I(T(p), (function(t) {
                t in v || f(v, t, p[t])
            })), v.prototype = m) : (v = e((function(t, e, r, n) {
                h(t, m);
                var i, o, u, c = 0,
                    l = 0;
                if (S(e)) {
                    if (!Z(e)) return W(e) ? X(v, e) : s(x, v, e);
                    i = e, l = y(r, a);
                    var f = e.byteLength;
                    if (void 0 === n) {
                        if (f % a) throw U("Wrong length");
                        if ((o = f - l) < 0) throw U("Wrong length")
                    } else if ((o = d(n) * a) + l > f) throw U("Wrong length");
                    u = o / a
                } else u = g(e), i = new V(o = u * a);
                for (P(t, {
                        buffer: i,
                        byteOffset: l,
                        byteLength: o,
                        length: u,
                        view: new j(i)
                    }); c < u;) b(t, c++)
            })), w && w(v, z), m = v.prototype = C(G)), m.constructor !== v && f(m, "constructor", v), f(m, K, v), q && f(m, q, u), E[u] = v, n({
                global: !0,
                forced: v != p,
                sham: !M
            }, E), "BYTES_PER_ELEMENT" in v || f(v, "BYTES_PER_ELEMENT", a), "BYTES_PER_ELEMENT" in m || f(m, "BYTES_PER_ELEMENT", a), B(u)
        }) : t.exports = function() {}
    }, function(t, e, r) {
        var n = r(28);
        t.exports = n("navigator", "userAgent") || ""
    }, function(t, e, r) {
        var n, i = r(11),
            s = r(160),
            a = r(133),
            o = r(85),
            u = r(161),
            c = r(82),
            h = r(84),
            l = h("IE_PROTO"),
            f = function() {},
            p = function(t) {
                return "<script>" + t + "<\/script>"
            },
            d = function(t) {
                t.write(p("")), t.close();
                var e = t.parentWindow.Object;
                return t = null, e
            },
            g = function() {
                try {
                    n = new ActiveXObject("htmlfile")
                } catch (t) {}
                var t, e;
                g = "undefined" != typeof document ? document.domain && n ? d(n) : ((e = c("iframe")).style.display = "none", u.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write(p("document.F=Object")), t.close(), t.F) : d(n);
                for (var r = a.length; r--;) delete g.prototype[a[r]];
                return g()
            };
        o[l] = !0, t.exports = Object.create || function(t, e) {
            var r;
            return null !== t ? (f.prototype = i(t), r = new f, f.prototype = null, r[l] = t) : r = g(), void 0 === e ? r : s(r, e)
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(1),
            i = r(55).PROPER,
            s = r(19),
            a = r(11),
            o = r(29),
            u = r(17),
            c = r(3),
            h = r(88),
            l = RegExp.prototype,
            f = l.toString,
            p = n(h),
            d = c((function() {
                return "/a/b" != f.call({
                    source: "a",
                    flags: "b"
                })
            })),
            g = i && "toString" != f.name;
        (d || g) && s(RegExp.prototype, "toString", (function() {
            var t = a(this),
                e = u(t.source),
                r = t.flags;
            return "/" + e + "/" + u(void 0 === r && o(l, t) && !("flags" in l) ? p(t) : r)
        }), {
            unsafe: !0
        })
    }, function(t, e, r) {
        var n = r(1),
            i = r(32),
            s = n(n.bind);
        t.exports = function(t, e) {
            return i(t), void 0 === e ? t : s ? s(t, e) : function() {
                return t.apply(e, arguments)
            }
        }
    }, function(t, e) {
        t.exports = function(t, e) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: e
            }
        }
    }, function(t, e, r) {
        var n = r(1),
            i = n({}.toString),
            s = n("".slice);
        t.exports = function(t) {
            return s(i(t), 8, -1)
        }
    }, function(t, e, r) {
        var n, i, s = r(0),
            a = r(36),
            o = s.process,
            u = s.Deno,
            c = o && o.versions || u && u.version,
            h = c && c.v8;
        h && (i = (n = h.split("."))[0] > 0 && n[0] < 4 ? 1 : +(n[0] + n[1])), !i && a && (!(n = a.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = a.match(/Chrome\/(\d+)/)) && (i = +n[1]), t.exports = i
    }, function(t, e, r) {
        var n = r(32);
        t.exports = function(t, e) {
            var r = t[e];
            return null == r ? void 0 : n(r)
        }
    }, function(t, e, r) {
        var n = r(159),
            i = r(133).concat("length", "prototype");
        e.f = Object.getOwnPropertyNames || function(t) {
            return n(t, i)
        }
    }, function(t, e, r) {
        var n = r(26),
            i = Math.max,
            s = Math.min;
        t.exports = function(t, e) {
            var r = n(t);
            return r < 0 ? i(r + e, 0) : s(r, e)
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(135),
            s = r(9),
            a = r(41),
            o = r(7)("toStringTag"),
            u = n.Object,
            c = "Arguments" == a(function() {
                return arguments
            }());
        t.exports = i ? a : function(t) {
            var e, r, n;
            return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof(r = function(t, e) {
                try {
                    return t[e]
                } catch (t) {}
            }(e = u(t), o)) ? r : c ? a(e) : "Object" == (n = a(e)) && s(e.callee) ? "Arguments" : n
        }
    }, function(t, e, r) {
        var n = r(16).f,
            i = r(12),
            s = r(7)("toStringTag");
        t.exports = function(t, e, r) {
            t && !i(t = r ? t : t.prototype, s) && n(t, s, {
                configurable: !0,
                value: e
            })
        }
    }, function(t, e, r) {
        var n = r(1),
            i = r(11),
            s = r(212);
        t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var t, e = !1,
                r = {};
            try {
                (t = n(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(r, []), e = r instanceof Array
            } catch (t) {}
            return function(r, n) {
                return i(r), s(n), e ? t(r, n) : r.__proto__ = n, r
            }
        }() : void 0)
    }, function(t, e, r) {
        var n, i, s;
        t.exports = (s = r(4), i = (n = s).lib.WordArray, n.enc.Base64 = {
            stringify: function(t) {
                var e = t.words,
                    r = t.sigBytes,
                    n = this._map;
                t.clamp();
                for (var i = [], s = 0; s < r; s += 3)
                    for (var a = (e[s >>> 2] >>> 24 - s % 4 * 8 & 255) << 16 | (e[s + 1 >>> 2] >>> 24 - (s + 1) % 4 * 8 & 255) << 8 | e[s + 2 >>> 2] >>> 24 - (s + 2) % 4 * 8 & 255, o = 0; o < 4 && s + .75 * o < r; o++) i.push(n.charAt(a >>> 6 * (3 - o) & 63));
                var u = n.charAt(64);
                if (u)
                    for (; i.length % 4;) i.push(u);
                return i.join("")
            },
            parse: function(t) {
                var e = t.length,
                    r = this._map,
                    n = this._reverseMap;
                if (!n) {
                    n = this._reverseMap = [];
                    for (var s = 0; s < r.length; s++) n[r.charCodeAt(s)] = s
                }
                var a = r.charAt(64);
                if (a) {
                    var o = t.indexOf(a); - 1 !== o && (e = o)
                }
                return function(t, e, r) {
                    for (var n = [], s = 0, a = 0; a < e; a++)
                        if (a % 4) {
                            var o = r[t.charCodeAt(a - 1)] << a % 4 * 2,
                                u = r[t.charCodeAt(a)] >>> 6 - a % 4 * 2,
                                c = o | u;
                            n[s >>> 2] |= c << 24 - s % 4 * 8, s++
                        }
                    return i.create(n, s)
                }(t, e, n)
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        }, s.enc.Base64)
    }, function(t, e, r) {
        var n, i, s, a, o, u, c, h;
        t.exports = (h = r(4), r(149), r(125), i = (n = h).lib, s = i.Base, a = i.WordArray, o = n.algo, u = o.MD5, c = o.EvpKDF = s.extend({
            cfg: s.extend({
                keySize: 4,
                hasher: u,
                iterations: 1
            }),
            init: function(t) {
                this.cfg = this.cfg.extend(t)
            },
            compute: function(t, e) {
                for (var r, n = this.cfg, i = n.hasher.create(), s = a.create(), o = s.words, u = n.keySize, c = n.iterations; o.length < u;) {
                    r && i.update(r), r = i.update(t).finalize(e), i.reset();
                    for (var h = 1; h < c; h++) r = i.finalize(r), i.reset();
                    s.concat(r)
                }
                return s.sigBytes = 4 * u, s
            }
        }), n.EvpKDF = function(t, e, r) {
            return c.create(r).compute(t, e)
        }, h.EvpKDF)
    }, function(t, e, r) {
        "use strict";
        r(30), r(38), r(153), r(31), r(98), r(99), r(101), r(102), r(103), r(104), r(106), r(107), r(108), r(109), r(110), r(111), r(112), r(113), r(114), r(115), r(116), r(117), r(118), r(119), r(120), r(121), r(122), r(123), r(124),
            function() {
                var e;

                function r(t, e, r) {
                    null != t && ("number" == typeof t ? this.fromNumber(t, e, r) : null == e && "string" != typeof t ? this.fromString(t, 256) : this.fromString(t, e))
                }

                function n() {
                    return new r(null)
                }
                var i = "undefined" != typeof navigator;
                i && "Microsoft Internet Explorer" == navigator.appName ? (r.prototype.am = function(t, e, r, n, i, s) {
                    for (var a = 32767 & e, o = e >> 15; --s >= 0;) {
                        var u = 32767 & this[t],
                            c = this[t++] >> 15,
                            h = o * u + c * a;
                        i = ((u = a * u + ((32767 & h) << 15) + r[n] + (1073741823 & i)) >>> 30) + (h >>> 15) + o * c + (i >>> 30), r[n++] = 1073741823 & u
                    }
                    return i
                }, e = 30) : i && "Netscape" != navigator.appName ? (r.prototype.am = function(t, e, r, n, i, s) {
                    for (; --s >= 0;) {
                        var a = e * this[t++] + r[n] + i;
                        i = Math.floor(a / 67108864), r[n++] = 67108863 & a
                    }
                    return i
                }, e = 26) : (r.prototype.am = function(t, e, r, n, i, s) {
                    for (var a = 16383 & e, o = e >> 14; --s >= 0;) {
                        var u = 16383 & this[t],
                            c = this[t++] >> 14,
                            h = o * u + c * a;
                        i = ((u = a * u + ((16383 & h) << 14) + r[n] + i) >> 28) + (h >> 14) + o * c, r[n++] = 268435455 & u
                    }
                    return i
                }, e = 28), r.prototype.DB = e, r.prototype.DM = (1 << e) - 1, r.prototype.DV = 1 << e;
                r.prototype.FV = Math.pow(2, 52), r.prototype.F1 = 52 - e, r.prototype.F2 = 2 * e - 52;
                var s, a, o = new Array;
                for (s = "0".charCodeAt(0), a = 0; a <= 9; ++a) o[s++] = a;
                for (s = "a".charCodeAt(0), a = 10; a < 36; ++a) o[s++] = a;
                for (s = "A".charCodeAt(0), a = 10; a < 36; ++a) o[s++] = a;

                function u(t) {
                    return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(t)
                }

                function c(t, e) {
                    var r = o[t.charCodeAt(e)];
                    return null == r ? -1 : r
                }

                function h(t) {
                    var e = n();
                    return e.fromInt(t), e
                }

                function l(t) {
                    var e, r = 1;
                    return 0 != (e = t >>> 16) && (t = e, r += 16), 0 != (e = t >> 8) && (t = e, r += 8), 0 != (e = t >> 4) && (t = e, r += 4), 0 != (e = t >> 2) && (t = e, r += 2), 0 != (e = t >> 1) && (t = e, r += 1), r
                }

                function f(t) {
                    this.m = t
                }

                function p(t) {
                    this.m = t, this.mp = t.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << t.DB - 15) - 1, this.mt2 = 2 * t.t
                }

                function d(t, e) {
                    return t & e
                }

                function g(t, e) {
                    return t | e
                }

                function y(t, e) {
                    return t ^ e
                }

                function v(t, e) {
                    return t & ~e
                }

                function m(t) {
                    if (0 == t) return -1;
                    var e = 0;
                    return 0 == (65535 & t) && (t >>= 16, e += 16), 0 == (255 & t) && (t >>= 8, e += 8), 0 == (15 & t) && (t >>= 4, e += 4), 0 == (3 & t) && (t >>= 2, e += 2), 0 == (1 & t) && ++e, e
                }

                function E(t) {
                    for (var e = 0; 0 != t;) t &= t - 1, ++e;
                    return e
                }

                function S() {}

                function b(t) {
                    return t
                }

                function C(t) {
                    this.r2 = n(), this.q3 = n(), r.ONE.dlShiftTo(2 * t.t, this.r2), this.mu = this.r2.divide(t), this.m = t
                }
                f.prototype.convert = function(t) {
                    return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t
                }, f.prototype.revert = function(t) {
                    return t
                }, f.prototype.reduce = function(t) {
                    t.divRemTo(this.m, null, t)
                }, f.prototype.mulTo = function(t, e, r) {
                    t.multiplyTo(e, r), this.reduce(r)
                }, f.prototype.sqrTo = function(t, e) {
                    t.squareTo(e), this.reduce(e)
                }, p.prototype.convert = function(t) {
                    var e = n();
                    return t.abs().dlShiftTo(this.m.t, e), e.divRemTo(this.m, null, e), t.s < 0 && e.compareTo(r.ZERO) > 0 && this.m.subTo(e, e), e
                }, p.prototype.revert = function(t) {
                    var e = n();
                    return t.copyTo(e), this.reduce(e), e
                }, p.prototype.reduce = function(t) {
                    for (; t.t <= this.mt2;) t[t.t++] = 0;
                    for (var e = 0; e < this.m.t; ++e) {
                        var r = 32767 & t[e],
                            n = r * this.mpl + ((r * this.mph + (t[e] >> 15) * this.mpl & this.um) << 15) & t.DM;
                        for (t[r = e + this.m.t] += this.m.am(0, n, t, e, 0, this.m.t); t[r] >= t.DV;) t[r] -= t.DV, t[++r]++
                    }
                    t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t)
                }, p.prototype.mulTo = function(t, e, r) {
                    t.multiplyTo(e, r), this.reduce(r)
                }, p.prototype.sqrTo = function(t, e) {
                    t.squareTo(e), this.reduce(e)
                }, r.prototype.copyTo = function(t) {
                    for (var e = this.t - 1; e >= 0; --e) t[e] = this[e];
                    t.t = this.t, t.s = this.s
                }, r.prototype.fromInt = function(t) {
                    this.t = 1, this.s = t < 0 ? -1 : 0, t > 0 ? this[0] = t : t < -1 ? this[0] = t + this.DV : this.t = 0
                }, r.prototype.fromString = function(t, e) {
                    var n;
                    if (16 == e) n = 4;
                    else if (8 == e) n = 3;
                    else if (256 == e) n = 8;
                    else if (2 == e) n = 1;
                    else if (32 == e) n = 5;
                    else {
                        if (4 != e) return void this.fromRadix(t, e);
                        n = 2
                    }
                    this.t = 0, this.s = 0;
                    for (var i = t.length, s = !1, a = 0; --i >= 0;) {
                        var o = 8 == n ? 255 & t[i] : c(t, i);
                        o < 0 ? "-" == t.charAt(i) && (s = !0) : (s = !1, 0 == a ? this[this.t++] = o : a + n > this.DB ? (this[this.t - 1] |= (o & (1 << this.DB - a) - 1) << a, this[this.t++] = o >> this.DB - a) : this[this.t - 1] |= o << a, (a += n) >= this.DB && (a -= this.DB))
                    }
                    8 == n && 0 != (128 & t[0]) && (this.s = -1, a > 0 && (this[this.t - 1] |= (1 << this.DB - a) - 1 << a)), this.clamp(), s && r.ZERO.subTo(this, this)
                }, r.prototype.clamp = function() {
                    for (var t = this.s & this.DM; this.t > 0 && this[this.t - 1] == t;) --this.t
                }, r.prototype.dlShiftTo = function(t, e) {
                    var r;
                    for (r = this.t - 1; r >= 0; --r) e[r + t] = this[r];
                    for (r = t - 1; r >= 0; --r) e[r] = 0;
                    e.t = this.t + t, e.s = this.s
                }, r.prototype.drShiftTo = function(t, e) {
                    for (var r = t; r < this.t; ++r) e[r - t] = this[r];
                    e.t = Math.max(this.t - t, 0), e.s = this.s
                }, r.prototype.lShiftTo = function(t, e) {
                    var r, n = t % this.DB,
                        i = this.DB - n,
                        s = (1 << i) - 1,
                        a = Math.floor(t / this.DB),
                        o = this.s << n & this.DM;
                    for (r = this.t - 1; r >= 0; --r) e[r + a + 1] = this[r] >> i | o, o = (this[r] & s) << n;
                    for (r = a - 1; r >= 0; --r) e[r] = 0;
                    e[a] = o, e.t = this.t + a + 1, e.s = this.s, e.clamp()
                }, r.prototype.rShiftTo = function(t, e) {
                    e.s = this.s;
                    var r = Math.floor(t / this.DB);
                    if (r >= this.t) e.t = 0;
                    else {
                        var n = t % this.DB,
                            i = this.DB - n,
                            s = (1 << n) - 1;
                        e[0] = this[r] >> n;
                        for (var a = r + 1; a < this.t; ++a) e[a - r - 1] |= (this[a] & s) << i, e[a - r] = this[a] >> n;
                        n > 0 && (e[this.t - r - 1] |= (this.s & s) << i), e.t = this.t - r, e.clamp()
                    }
                }, r.prototype.subTo = function(t, e) {
                    for (var r = 0, n = 0, i = Math.min(t.t, this.t); r < i;) n += this[r] - t[r], e[r++] = n & this.DM, n >>= this.DB;
                    if (t.t < this.t) {
                        for (n -= t.s; r < this.t;) n += this[r], e[r++] = n & this.DM, n >>= this.DB;
                        n += this.s
                    } else {
                        for (n += this.s; r < t.t;) n -= t[r], e[r++] = n & this.DM, n >>= this.DB;
                        n -= t.s
                    }
                    e.s = n < 0 ? -1 : 0, n < -1 ? e[r++] = this.DV + n : n > 0 && (e[r++] = n), e.t = r, e.clamp()
                }, r.prototype.multiplyTo = function(t, e) {
                    var n = this.abs(),
                        i = t.abs(),
                        s = n.t;
                    for (e.t = s + i.t; --s >= 0;) e[s] = 0;
                    for (s = 0; s < i.t; ++s) e[s + n.t] = n.am(0, i[s], e, s, 0, n.t);
                    e.s = 0, e.clamp(), this.s != t.s && r.ZERO.subTo(e, e)
                }, r.prototype.squareTo = function(t) {
                    for (var e = this.abs(), r = t.t = 2 * e.t; --r >= 0;) t[r] = 0;
                    for (r = 0; r < e.t - 1; ++r) {
                        var n = e.am(r, e[r], t, 2 * r, 0, 1);
                        (t[r + e.t] += e.am(r + 1, 2 * e[r], t, 2 * r + 1, n, e.t - r - 1)) >= e.DV && (t[r + e.t] -= e.DV, t[r + e.t + 1] = 1)
                    }
                    t.t > 0 && (t[t.t - 1] += e.am(r, e[r], t, 2 * r, 0, 1)), t.s = 0, t.clamp()
                }, r.prototype.divRemTo = function(t, e, i) {
                    var s = t.abs();
                    if (!(s.t <= 0)) {
                        var a = this.abs();
                        if (a.t < s.t) return null != e && e.fromInt(0), void(null != i && this.copyTo(i));
                        null == i && (i = n());
                        var o = n(),
                            u = this.s,
                            c = t.s,
                            h = this.DB - l(s[s.t - 1]);
                        h > 0 ? (s.lShiftTo(h, o), a.lShiftTo(h, i)) : (s.copyTo(o), a.copyTo(i));
                        var f = o.t,
                            p = o[f - 1];
                        if (0 != p) {
                            var d = p * (1 << this.F1) + (f > 1 ? o[f - 2] >> this.F2 : 0),
                                g = this.FV / d,
                                y = (1 << this.F1) / d,
                                v = 1 << this.F2,
                                m = i.t,
                                E = m - f,
                                S = null == e ? n() : e;
                            for (o.dlShiftTo(E, S), i.compareTo(S) >= 0 && (i[i.t++] = 1, i.subTo(S, i)), r.ONE.dlShiftTo(f, S), S.subTo(o, o); o.t < f;) o[o.t++] = 0;
                            for (; --E >= 0;) {
                                var b = i[--m] == p ? this.DM : Math.floor(i[m] * g + (i[m - 1] + v) * y);
                                if ((i[m] += o.am(0, b, i, E, 0, f)) < b)
                                    for (o.dlShiftTo(E, S), i.subTo(S, i); i[m] < --b;) i.subTo(S, i)
                            }
                            null != e && (i.drShiftTo(f, e), u != c && r.ZERO.subTo(e, e)), i.t = f, i.clamp(), h > 0 && i.rShiftTo(h, i), u < 0 && r.ZERO.subTo(i, i)
                        }
                    }
                }, r.prototype.invDigit = function() {
                    if (this.t < 1) return 0;
                    var t = this[0];
                    if (0 == (1 & t)) return 0;
                    var e = 3 & t;
                    return (e = (e = (e = (e = e * (2 - (15 & t) * e) & 15) * (2 - (255 & t) * e) & 255) * (2 - ((65535 & t) * e & 65535)) & 65535) * (2 - t * e % this.DV) % this.DV) > 0 ? this.DV - e : -e
                }, r.prototype.isEven = function() {
                    return 0 == (this.t > 0 ? 1 & this[0] : this.s)
                }, r.prototype.exp = function(t, e) {
                    if (t > 4294967295 || t < 1) return r.ONE;
                    var i = n(),
                        s = n(),
                        a = e.convert(this),
                        o = l(t) - 1;
                    for (a.copyTo(i); --o >= 0;)
                        if (e.sqrTo(i, s), (t & 1 << o) > 0) e.mulTo(s, a, i);
                        else {
                            var u = i;
                            i = s, s = u
                        }
                    return e.revert(i)
                }, r.prototype.toString = function(t) {
                    if (this.s < 0) return "-" + this.negate().toString(t);
                    var e;
                    if (16 == t) e = 4;
                    else if (8 == t) e = 3;
                    else if (2 == t) e = 1;
                    else if (32 == t) e = 5;
                    else {
                        if (4 != t) return this.toRadix(t);
                        e = 2
                    }
                    var r, n = (1 << e) - 1,
                        i = !1,
                        s = "",
                        a = this.t,
                        o = this.DB - a * this.DB % e;
                    if (a-- > 0)
                        for (o < this.DB && (r = this[a] >> o) > 0 && (i = !0, s = u(r)); a >= 0;) o < e ? (r = (this[a] & (1 << o) - 1) << e - o, r |= this[--a] >> (o += this.DB - e)) : (r = this[a] >> (o -= e) & n, o <= 0 && (o += this.DB, --a)), r > 0 && (i = !0), i && (s += u(r));
                    return i ? s : "0"
                }, r.prototype.negate = function() {
                    var t = n();
                    return r.ZERO.subTo(this, t), t
                }, r.prototype.abs = function() {
                    return this.s < 0 ? this.negate() : this
                }, r.prototype.compareTo = function(t) {
                    var e = this.s - t.s;
                    if (0 != e) return e;
                    var r = this.t;
                    if (0 != (e = r - t.t)) return this.s < 0 ? -e : e;
                    for (; --r >= 0;)
                        if (0 != (e = this[r] - t[r])) return e;
                    return 0
                }, r.prototype.bitLength = function() {
                    return this.t <= 0 ? 0 : this.DB * (this.t - 1) + l(this[this.t - 1] ^ this.s & this.DM)
                }, r.prototype.mod = function(t) {
                    var e = n();
                    return this.abs().divRemTo(t, null, e), this.s < 0 && e.compareTo(r.ZERO) > 0 && t.subTo(e, e), e
                }, r.prototype.modPowInt = function(t, e) {
                    var r;
                    return r = t < 256 || e.isEven() ? new f(e) : new p(e), this.exp(t, r)
                }, r.ZERO = h(0), r.ONE = h(1), S.prototype.convert = b, S.prototype.revert = b, S.prototype.mulTo = function(t, e, r) {
                    t.multiplyTo(e, r)
                }, S.prototype.sqrTo = function(t, e) {
                    t.squareTo(e)
                }, C.prototype.convert = function(t) {
                    if (t.s < 0 || t.t > 2 * this.m.t) return t.mod(this.m);
                    if (t.compareTo(this.m) < 0) return t;
                    var e = n();
                    return t.copyTo(e), this.reduce(e), e
                }, C.prototype.revert = function(t) {
                    return t
                }, C.prototype.reduce = function(t) {
                    for (t.drShiftTo(this.m.t - 1, this.r2), t.t > this.m.t + 1 && (t.t = this.m.t + 1, t.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t.compareTo(this.r2) < 0;) t.dAddOffset(1, this.m.t + 1);
                    for (t.subTo(this.r2, t); t.compareTo(this.m) >= 0;) t.subTo(this.m, t)
                }, C.prototype.mulTo = function(t, e, r) {
                    t.multiplyTo(e, r), this.reduce(r)
                }, C.prototype.sqrTo = function(t, e) {
                    t.squareTo(e), this.reduce(e)
                };
                var A, w, T, x = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997],
                    I = (1 << 26) / x[x.length - 1];

                function B() {
                    var t;
                    t = (new Date).getTime(), w[T++] ^= 255 & t, w[T++] ^= t >> 8 & 255, w[T++] ^= t >> 16 & 255, w[T++] ^= t >> 24 & 255, T >= k && (T -= k)
                }
                if (r.prototype.chunkSize = function(t) {
                        return Math.floor(Math.LN2 * this.DB / Math.log(t))
                    }, r.prototype.toRadix = function(t) {
                        if (null == t && (t = 10), 0 == this.signum() || t < 2 || t > 36) return "0";
                        var e = this.chunkSize(t),
                            r = Math.pow(t, e),
                            i = h(r),
                            s = n(),
                            a = n(),
                            o = "";
                        for (this.divRemTo(i, s, a); s.signum() > 0;) o = (r + a.intValue()).toString(t).substr(1) + o, s.divRemTo(i, s, a);
                        return a.intValue().toString(t) + o
                    }, r.prototype.fromRadix = function(t, e) {
                        this.fromInt(0), null == e && (e = 10);
                        for (var n = this.chunkSize(e), i = Math.pow(e, n), s = !1, a = 0, o = 0, u = 0; u < t.length; ++u) {
                            var h = c(t, u);
                            h < 0 ? "-" == t.charAt(u) && 0 == this.signum() && (s = !0) : (o = e * o + h, ++a >= n && (this.dMultiply(i), this.dAddOffset(o, 0), a = 0, o = 0))
                        }
                        a > 0 && (this.dMultiply(Math.pow(e, a)), this.dAddOffset(o, 0)), s && r.ZERO.subTo(this, this)
                    }, r.prototype.fromNumber = function(t, e, n) {
                        if ("number" == typeof e)
                            if (t < 2) this.fromInt(1);
                            else
                                for (this.fromNumber(t, n), this.testBit(t - 1) || this.bitwiseTo(r.ONE.shiftLeft(t - 1), g, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e);) this.dAddOffset(2, 0), this.bitLength() > t && this.subTo(r.ONE.shiftLeft(t - 1), this);
                        else {
                            var i = new Array,
                                s = 7 & t;
                            i.length = 1 + (t >> 3), e.nextBytes(i), s > 0 ? i[0] &= (1 << s) - 1 : i[0] = 0, this.fromString(i, 256)
                        }
                    }, r.prototype.bitwiseTo = function(t, e, r) {
                        var n, i, s = Math.min(t.t, this.t);
                        for (n = 0; n < s; ++n) r[n] = e(this[n], t[n]);
                        if (t.t < this.t) {
                            for (i = t.s & this.DM, n = s; n < this.t; ++n) r[n] = e(this[n], i);
                            r.t = this.t
                        } else {
                            for (i = this.s & this.DM, n = s; n < t.t; ++n) r[n] = e(i, t[n]);
                            r.t = t.t
                        }
                        r.s = e(this.s, t.s), r.clamp()
                    }, r.prototype.changeBit = function(t, e) {
                        var n = r.ONE.shiftLeft(t);
                        return this.bitwiseTo(n, e, n), n
                    }, r.prototype.addTo = function(t, e) {
                        for (var r = 0, n = 0, i = Math.min(t.t, this.t); r < i;) n += this[r] + t[r], e[r++] = n & this.DM, n >>= this.DB;
                        if (t.t < this.t) {
                            for (n += t.s; r < this.t;) n += this[r], e[r++] = n & this.DM, n >>= this.DB;
                            n += this.s
                        } else {
                            for (n += this.s; r < t.t;) n += t[r], e[r++] = n & this.DM, n >>= this.DB;
                            n += t.s
                        }
                        e.s = n < 0 ? -1 : 0, n > 0 ? e[r++] = n : n < -1 && (e[r++] = this.DV + n), e.t = r, e.clamp()
                    }, r.prototype.dMultiply = function(t) {
                        this[this.t] = this.am(0, t - 1, this, 0, 0, this.t), ++this.t, this.clamp()
                    }, r.prototype.dAddOffset = function(t, e) {
                        if (0 != t) {
                            for (; this.t <= e;) this[this.t++] = 0;
                            for (this[e] += t; this[e] >= this.DV;) this[e] -= this.DV, ++e >= this.t && (this[this.t++] = 0), ++this[e]
                        }
                    }, r.prototype.multiplyLowerTo = function(t, e, r) {
                        var n, i = Math.min(this.t + t.t, e);
                        for (r.s = 0, r.t = i; i > 0;) r[--i] = 0;
                        for (n = r.t - this.t; i < n; ++i) r[i + this.t] = this.am(0, t[i], r, i, 0, this.t);
                        for (n = Math.min(t.t, e); i < n; ++i) this.am(0, t[i], r, i, 0, e - i);
                        r.clamp()
                    }, r.prototype.multiplyUpperTo = function(t, e, r) {
                        --e;
                        var n = r.t = this.t + t.t - e;
                        for (r.s = 0; --n >= 0;) r[n] = 0;
                        for (n = Math.max(e - this.t, 0); n < t.t; ++n) r[this.t + n - e] = this.am(e - n, t[n], r, 0, 0, this.t + n - e);
                        r.clamp(), r.drShiftTo(1, r)
                    }, r.prototype.modInt = function(t) {
                        if (t <= 0) return 0;
                        var e = this.DV % t,
                            r = this.s < 0 ? t - 1 : 0;
                        if (this.t > 0)
                            if (0 == e) r = this[0] % t;
                            else
                                for (var n = this.t - 1; n >= 0; --n) r = (e * r + this[n]) % t;
                        return r
                    }, r.prototype.millerRabin = function(t) {
                        var e = this.subtract(r.ONE),
                            i = e.getLowestSetBit();
                        if (i <= 0) return !1;
                        var s = e.shiftRight(i);
                        (t = t + 1 >> 1) > x.length && (t = x.length);
                        for (var a = n(), o = 0; o < t; ++o) {
                            a.fromInt(x[Math.floor(Math.random() * x.length)]);
                            var u = a.modPow(s, this);
                            if (0 != u.compareTo(r.ONE) && 0 != u.compareTo(e)) {
                                for (var c = 1; c++ < i && 0 != u.compareTo(e);)
                                    if (0 == (u = u.modPowInt(2, this)).compareTo(r.ONE)) return !1;
                                if (0 != u.compareTo(e)) return !1
                            }
                        }
                        return !0
                    }, r.prototype.clone = function() {
                        var t = n();
                        return this.copyTo(t), t
                    }, r.prototype.intValue = function() {
                        if (this.s < 0) {
                            if (1 == this.t) return this[0] - this.DV;
                            if (0 == this.t) return -1
                        } else {
                            if (1 == this.t) return this[0];
                            if (0 == this.t) return 0
                        }
                        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0]
                    }, r.prototype.byteValue = function() {
                        return 0 == this.t ? this.s : this[0] << 24 >> 24
                    }, r.prototype.shortValue = function() {
                        return 0 == this.t ? this.s : this[0] << 16 >> 16
                    }, r.prototype.signum = function() {
                        return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this[0] <= 0 ? 0 : 1
                    }, r.prototype.toByteArray = function() {
                        var t = this.t,
                            e = new Array;
                        e[0] = this.s;
                        var r, n = this.DB - t * this.DB % 8,
                            i = 0;
                        if (t-- > 0)
                            for (n < this.DB && (r = this[t] >> n) != (this.s & this.DM) >> n && (e[i++] = r | this.s << this.DB - n); t >= 0;) n < 8 ? (r = (this[t] & (1 << n) - 1) << 8 - n, r |= this[--t] >> (n += this.DB - 8)) : (r = this[t] >> (n -= 8) & 255, n <= 0 && (n += this.DB, --t)), 0 != (128 & r) && (r |= -256), 0 == i && (128 & this.s) != (128 & r) && ++i, (i > 0 || r != this.s) && (e[i++] = r);
                        return e
                    }, r.prototype.equals = function(t) {
                        return 0 == this.compareTo(t)
                    }, r.prototype.min = function(t) {
                        return this.compareTo(t) < 0 ? this : t
                    }, r.prototype.max = function(t) {
                        return this.compareTo(t) > 0 ? this : t
                    }, r.prototype.and = function(t) {
                        var e = n();
                        return this.bitwiseTo(t, d, e), e
                    }, r.prototype.or = function(t) {
                        var e = n();
                        return this.bitwiseTo(t, g, e), e
                    }, r.prototype.xor = function(t) {
                        var e = n();
                        return this.bitwiseTo(t, y, e), e
                    }, r.prototype.andNot = function(t) {
                        var e = n();
                        return this.bitwiseTo(t, v, e), e
                    }, r.prototype.not = function() {
                        for (var t = n(), e = 0; e < this.t; ++e) t[e] = this.DM & ~this[e];
                        return t.t = this.t, t.s = ~this.s, t
                    }, r.prototype.shiftLeft = function(t) {
                        var e = n();
                        return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e), e
                    }, r.prototype.shiftRight = function(t) {
                        var e = n();
                        return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e), e
                    }, r.prototype.getLowestSetBit = function() {
                        for (var t = 0; t < this.t; ++t)
                            if (0 != this[t]) return t * this.DB + m(this[t]);
                        return this.s < 0 ? this.t * this.DB : -1
                    }, r.prototype.bitCount = function() {
                        for (var t = 0, e = this.s & this.DM, r = 0; r < this.t; ++r) t += E(this[r] ^ e);
                        return t
                    }, r.prototype.testBit = function(t) {
                        var e = Math.floor(t / this.DB);
                        return e >= this.t ? 0 != this.s : 0 != (this[e] & 1 << t % this.DB)
                    }, r.prototype.setBit = function(t) {
                        return this.changeBit(t, g)
                    }, r.prototype.clearBit = function(t) {
                        return this.changeBit(t, v)
                    }, r.prototype.flipBit = function(t) {
                        return this.changeBit(t, y)
                    }, r.prototype.add = function(t) {
                        var e = n();
                        return this.addTo(t, e), e
                    }, r.prototype.subtract = function(t) {
                        var e = n();
                        return this.subTo(t, e), e
                    }, r.prototype.multiply = function(t) {
                        var e = n();
                        return this.multiplyTo(t, e), e
                    }, r.prototype.divide = function(t) {
                        var e = n();
                        return this.divRemTo(t, e, null), e
                    }, r.prototype.remainder = function(t) {
                        var e = n();
                        return this.divRemTo(t, null, e), e
                    }, r.prototype.divideAndRemainder = function(t) {
                        var e = n(),
                            r = n();
                        return this.divRemTo(t, e, r), new Array(e, r)
                    }, r.prototype.modPow = function(t, e) {
                        var r, i, s = t.bitLength(),
                            a = h(1);
                        if (s <= 0) return a;
                        r = s < 18 ? 1 : s < 48 ? 3 : s < 144 ? 4 : s < 768 ? 5 : 6, i = s < 8 ? new f(e) : e.isEven() ? new C(e) : new p(e);
                        var o = new Array,
                            u = 3,
                            c = r - 1,
                            d = (1 << r) - 1;
                        if (o[1] = i.convert(this), r > 1) {
                            var g = n();
                            for (i.sqrTo(o[1], g); u <= d;) o[u] = n(), i.mulTo(g, o[u - 2], o[u]), u += 2
                        }
                        var y, v, m = t.t - 1,
                            E = !0,
                            S = n();
                        for (s = l(t[m]) - 1; m >= 0;) {
                            for (s >= c ? y = t[m] >> s - c & d : (y = (t[m] & (1 << s + 1) - 1) << c - s, m > 0 && (y |= t[m - 1] >> this.DB + s - c)), u = r; 0 == (1 & y);) y >>= 1, --u;
                            if ((s -= u) < 0 && (s += this.DB, --m), E) o[y].copyTo(a), E = !1;
                            else {
                                for (; u > 1;) i.sqrTo(a, S), i.sqrTo(S, a), u -= 2;
                                u > 0 ? i.sqrTo(a, S) : (v = a, a = S, S = v), i.mulTo(S, o[y], a)
                            }
                            for (; m >= 0 && 0 == (t[m] & 1 << s);) i.sqrTo(a, S), v = a, a = S, S = v, --s < 0 && (s = this.DB - 1, --m)
                        }
                        return i.revert(a)
                    }, r.prototype.modInverse = function(t) {
                        var e = t.isEven();
                        if (this.isEven() && e || 0 == t.signum()) return r.ZERO;
                        for (var n = t.clone(), i = this.clone(), s = h(1), a = h(0), o = h(0), u = h(1); 0 != n.signum();) {
                            for (; n.isEven();) n.rShiftTo(1, n), e ? (s.isEven() && a.isEven() || (s.addTo(this, s), a.subTo(t, a)), s.rShiftTo(1, s)) : a.isEven() || a.subTo(t, a), a.rShiftTo(1, a);
                            for (; i.isEven();) i.rShiftTo(1, i), e ? (o.isEven() && u.isEven() || (o.addTo(this, o), u.subTo(t, u)), o.rShiftTo(1, o)) : u.isEven() || u.subTo(t, u), u.rShiftTo(1, u);
                            n.compareTo(i) >= 0 ? (n.subTo(i, n), e && s.subTo(o, s), a.subTo(u, a)) : (i.subTo(n, i), e && o.subTo(s, o), u.subTo(a, u))
                        }
                        return 0 != i.compareTo(r.ONE) ? r.ZERO : u.compareTo(t) >= 0 ? u.subtract(t) : u.signum() < 0 ? (u.addTo(t, u), u.signum() < 0 ? u.add(t) : u) : u
                    }, r.prototype.pow = function(t) {
                        return this.exp(t, new S)
                    }, r.prototype.gcd = function(t) {
                        var e = this.s < 0 ? this.negate() : this.clone(),
                            r = t.s < 0 ? t.negate() : t.clone();
                        if (e.compareTo(r) < 0) {
                            var n = e;
                            e = r, r = n
                        }
                        var i = e.getLowestSetBit(),
                            s = r.getLowestSetBit();
                        if (s < 0) return e;
                        for (i < s && (s = i), s > 0 && (e.rShiftTo(s, e), r.rShiftTo(s, r)); e.signum() > 0;)(i = e.getLowestSetBit()) > 0 && e.rShiftTo(i, e), (i = r.getLowestSetBit()) > 0 && r.rShiftTo(i, r), e.compareTo(r) >= 0 ? (e.subTo(r, e), e.rShiftTo(1, e)) : (r.subTo(e, r), r.rShiftTo(1, r));
                        return s > 0 && r.lShiftTo(s, r), r
                    }, r.prototype.isProbablePrime = function(t) {
                        var e, r = this.abs();
                        if (1 == r.t && r[0] <= x[x.length - 1]) {
                            for (e = 0; e < x.length; ++e)
                                if (r[0] == x[e]) return !0;
                            return !1
                        }
                        if (r.isEven()) return !1;
                        for (e = 1; e < x.length;) {
                            for (var n = x[e], i = e + 1; i < x.length && n < I;) n *= x[i++];
                            for (n = r.modInt(n); e < i;)
                                if (n % x[e++] == 0) return !1
                        }
                        return r.millerRabin(t)
                    }, r.prototype.square = function() {
                        var t = n();
                        return this.squareTo(t), t
                    }, r.prototype.Barrett = C, null == w) {
                    var F;
                    if (w = new Array, T = 0, "undefined" != typeof window && window.crypto)
                        if (window.crypto.getRandomValues) {
                            var R = new Uint8Array(32);
                            for (window.crypto.getRandomValues(R), F = 0; F < 32; ++F) w[T++] = R[F]
                        } else if ("Netscape" == navigator.appName && navigator.appVersion < "5") {
                        var D = window.crypto.random(32);
                        for (F = 0; F < D.length; ++F) w[T++] = 255 & D.charCodeAt(F)
                    }
                    for (; T < k;) F = Math.floor(65536 * Math.random()), w[T++] = F >>> 8, w[T++] = 255 & F;
                    T = 0, B()
                }

                function N() {
                    if (null == A) {
                        for (B(), (A = new P).init(w), T = 0; T < w.length; ++T) w[T] = 0;
                        T = 0
                    }
                    return A.next()
                }

                function _() {}

                function P() {
                    this.i = 0, this.j = 0, this.S = new Array
                }
                _.prototype.nextBytes = function(t) {
                    var e;
                    for (e = 0; e < t.length; ++e) t[e] = N()
                }, P.prototype.init = function(t) {
                    var e, r, n;
                    for (e = 0; e < 256; ++e) this.S[e] = e;
                    for (r = 0, e = 0; e < 256; ++e) r = r + this.S[e] + t[e % t.length] & 255, n = this.S[e], this.S[e] = this.S[r], this.S[r] = n;
                    this.i = 0, this.j = 0
                }, P.prototype.next = function() {
                    var t;
                    return this.i = this.i + 1 & 255, this.j = this.j + this.S[this.i] & 255, t = this.S[this.i], this.S[this.i] = this.S[this.j], this.S[this.j] = t, this.S[t + this.S[this.i] & 255]
                };
                var k = 256;
                r.SecureRandom = _, r.BigInteger = r, t.exports = r
            }.call(void 0)
    }, function(t, e) {
        var r;
        r = function() {
            return this
        }();
        try {
            r = r || new Function("return this")()
        } catch (t) {
            "object" == typeof window && (r = window)
        }
        t.exports = r
    }, function(t, e, r) {
        var n = r(13),
            i = r(10),
            s = r(79),
            a = r(40),
            o = r(23),
            u = r(62),
            c = r(12),
            h = r(157),
            l = Object.getOwnPropertyDescriptor;
        e.f = n ? l : function(t, e) {
            if (t = o(t), e = u(e), h) try {
                return l(t, e)
            } catch (t) {}
            if (c(t, e)) return a(!i(s.f, t, e), t[e])
        }
    }, function(t, e) {
        t.exports = !1
    }, function(t, e, r) {
        var n = r(13),
            i = r(12),
            s = Function.prototype,
            a = n && Object.getOwnPropertyDescriptor,
            o = i(s, "name"),
            u = o && "something" === function() {}.name,
            c = o && (!n || n && a(s, "name").configurable);
        t.exports = {
            EXISTS: o,
            PROPER: u,
            CONFIGURABLE: c
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(3);
        t.exports = function(t, e) {
            var r = [][t];
            return !!r && n((function() {
                r.call(null, e || function() {
                    throw 1
                }, 1)
            }))
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(92).charAt,
            i = r(17),
            s = r(25),
            a = r(166),
            o = s.set,
            u = s.getterFor("String Iterator");
        a(String, "String", (function(t) {
            o(this, {
                type: "String Iterator",
                string: i(t),
                index: 0
            })
        }), (function() {
            var t, e = u(this),
                r = e.string,
                i = e.index;
            return i >= r.length ? {
                value: void 0,
                done: !0
            } : (t = n(r, i), e.index += t.length, {
                value: t,
                done: !1
            })
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(1),
            s = r(61),
            a = r(23),
            o = r(56),
            u = i([].join),
            c = s != Object,
            h = o("join", ",");
        n({
            target: "Array",
            proto: !0,
            forced: c || !h
        }, {
            join: function(t) {
                return u(a(this), void 0 === t ? "," : t)
            }
        })
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), function(t) {
            var e = n,
                r = e.lib,
                i = r.WordArray,
                s = r.Hasher,
                a = e.algo,
                o = [];
            ! function() {
                for (var e = 0; e < 64; e++) o[e] = 4294967296 * t.abs(t.sin(e + 1)) | 0
            }();
            var u = a.MD5 = s.extend({
                _doReset: function() {
                    this._hash = new i.init([1732584193, 4023233417, 2562383102, 271733878])
                },
                _doProcessBlock: function(t, e) {
                    for (var r = 0; r < 16; r++) {
                        var n = e + r,
                            i = t[n];
                        t[n] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8)
                    }
                    var s = this._hash.words,
                        a = t[e + 0],
                        u = t[e + 1],
                        p = t[e + 2],
                        d = t[e + 3],
                        g = t[e + 4],
                        y = t[e + 5],
                        v = t[e + 6],
                        m = t[e + 7],
                        E = t[e + 8],
                        S = t[e + 9],
                        b = t[e + 10],
                        C = t[e + 11],
                        A = t[e + 12],
                        w = t[e + 13],
                        T = t[e + 14],
                        x = t[e + 15],
                        I = s[0],
                        B = s[1],
                        F = s[2],
                        R = s[3];
                    I = c(I, B, F, R, a, 7, o[0]), R = c(R, I, B, F, u, 12, o[1]), F = c(F, R, I, B, p, 17, o[2]), B = c(B, F, R, I, d, 22, o[3]), I = c(I, B, F, R, g, 7, o[4]), R = c(R, I, B, F, y, 12, o[5]), F = c(F, R, I, B, v, 17, o[6]), B = c(B, F, R, I, m, 22, o[7]), I = c(I, B, F, R, E, 7, o[8]), R = c(R, I, B, F, S, 12, o[9]), F = c(F, R, I, B, b, 17, o[10]), B = c(B, F, R, I, C, 22, o[11]), I = c(I, B, F, R, A, 7, o[12]), R = c(R, I, B, F, w, 12, o[13]), F = c(F, R, I, B, T, 17, o[14]), I = h(I, B = c(B, F, R, I, x, 22, o[15]), F, R, u, 5, o[16]), R = h(R, I, B, F, v, 9, o[17]), F = h(F, R, I, B, C, 14, o[18]), B = h(B, F, R, I, a, 20, o[19]), I = h(I, B, F, R, y, 5, o[20]), R = h(R, I, B, F, b, 9, o[21]), F = h(F, R, I, B, x, 14, o[22]), B = h(B, F, R, I, g, 20, o[23]), I = h(I, B, F, R, S, 5, o[24]), R = h(R, I, B, F, T, 9, o[25]), F = h(F, R, I, B, d, 14, o[26]), B = h(B, F, R, I, E, 20, o[27]), I = h(I, B, F, R, w, 5, o[28]), R = h(R, I, B, F, p, 9, o[29]), F = h(F, R, I, B, m, 14, o[30]), I = l(I, B = h(B, F, R, I, A, 20, o[31]), F, R, y, 4, o[32]), R = l(R, I, B, F, E, 11, o[33]), F = l(F, R, I, B, C, 16, o[34]), B = l(B, F, R, I, T, 23, o[35]), I = l(I, B, F, R, u, 4, o[36]), R = l(R, I, B, F, g, 11, o[37]), F = l(F, R, I, B, m, 16, o[38]), B = l(B, F, R, I, b, 23, o[39]), I = l(I, B, F, R, w, 4, o[40]), R = l(R, I, B, F, a, 11, o[41]), F = l(F, R, I, B, d, 16, o[42]), B = l(B, F, R, I, v, 23, o[43]), I = l(I, B, F, R, S, 4, o[44]), R = l(R, I, B, F, A, 11, o[45]), F = l(F, R, I, B, x, 16, o[46]), I = f(I, B = l(B, F, R, I, p, 23, o[47]), F, R, a, 6, o[48]), R = f(R, I, B, F, m, 10, o[49]), F = f(F, R, I, B, T, 15, o[50]), B = f(B, F, R, I, y, 21, o[51]), I = f(I, B, F, R, A, 6, o[52]), R = f(R, I, B, F, d, 10, o[53]), F = f(F, R, I, B, b, 15, o[54]), B = f(B, F, R, I, u, 21, o[55]), I = f(I, B, F, R, E, 6, o[56]), R = f(R, I, B, F, x, 10, o[57]), F = f(F, R, I, B, v, 15, o[58]), B = f(B, F, R, I, w, 21, o[59]), I = f(I, B, F, R, g, 6, o[60]), R = f(R, I, B, F, C, 10, o[61]), F = f(F, R, I, B, p, 15, o[62]), B = f(B, F, R, I, S, 21, o[63]), s[0] = s[0] + I | 0, s[1] = s[1] + B | 0, s[2] = s[2] + F | 0, s[3] = s[3] + R | 0
                },
                _doFinalize: function() {
                    var e = this._data,
                        r = e.words,
                        n = 8 * this._nDataBytes,
                        i = 8 * e.sigBytes;
                    r[i >>> 5] |= 128 << 24 - i % 32;
                    var s = t.floor(n / 4294967296),
                        a = n;
                    r[15 + (i + 64 >>> 9 << 4)] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8), r[14 + (i + 64 >>> 9 << 4)] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8), e.sigBytes = 4 * (r.length + 1), this._process();
                    for (var o = this._hash, u = o.words, c = 0; c < 4; c++) {
                        var h = u[c];
                        u[c] = 16711935 & (h << 8 | h >>> 24) | 4278255360 & (h << 24 | h >>> 8)
                    }
                    return o
                },
                clone: function() {
                    var t = s.clone.call(this);
                    return t._hash = this._hash.clone(), t
                }
            });

            function c(t, e, r, n, i, s, a) {
                var o = t + (e & r | ~e & n) + i + a;
                return (o << s | o >>> 32 - s) + e
            }

            function h(t, e, r, n, i, s, a) {
                var o = t + (e & n | r & ~n) + i + a;
                return (o << s | o >>> 32 - s) + e
            }

            function l(t, e, r, n, i, s, a) {
                var o = t + (e ^ r ^ n) + i + a;
                return (o << s | o >>> 32 - s) + e
            }

            function f(t, e, r, n, i, s, a) {
                var o = t + (r ^ (e | ~n)) + i + a;
                return (o << s | o >>> 32 - s) + e
            }
            e.MD5 = s._createHelper(u), e.HmacMD5 = s._createHmacHelper(u)
        }(Math), n.MD5)
    }, function(t, e, r) {
        var n = r(2).Buffer;
        t.exports = function(t) {
            if (t instanceof Uint8Array) {
                if (0 === t.byteOffset && t.byteLength === t.buffer.byteLength) return t.buffer;
                if ("function" == typeof t.buffer.slice) return t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength)
            }
            if (n.isBuffer(t)) {
                for (var e = new Uint8Array(t.length), r = t.length, i = 0; i < r; i++) e[i] = t[i];
                return e.buffer
            }
            throw new Error("Argument must be a Buffer")
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(1),
            s = r(3),
            a = r(41),
            o = n.Object,
            u = i("".split);
        t.exports = s((function() {
            return !o("z").propertyIsEnumerable(0)
        })) ? function(t) {
            return "String" == a(t) ? u(t, "") : o(t)
        } : o
    }, function(t, e, r) {
        var n = r(155),
            i = r(63);
        t.exports = function(t) {
            var e = n(t, "string");
            return i(e) ? e : e + ""
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(28),
            s = r(9),
            a = r(29),
            o = r(156),
            u = n.Object;
        t.exports = o ? function(t) {
            return "symbol" == typeof t
        } : function(t) {
            var e = i("Symbol");
            return s(e) && a(e.prototype, u(t))
        }
    }, function(t, e, r) {
        var n = r(0).String;
        t.exports = function(t) {
            try {
                return n(t)
            } catch (t) {
                return "Object"
            }
        }
    }, function(t, e, r) {
        var n = r(23),
            i = r(45),
            s = r(20),
            a = function(t) {
                return function(e, r, a) {
                    var o, u = n(e),
                        c = s(u),
                        h = i(a, c);
                    if (t && r != r) {
                        for (; c > h;)
                            if ((o = u[h++]) != o) return !0
                    } else
                        for (; c > h; h++)
                            if ((t || h in u) && u[h] === r) return t || h || 0;
                    return !t && -1
                }
            };
        t.exports = {
            includes: a(!0),
            indexOf: a(!1)
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(87);
        n({
            target: "RegExp",
            proto: !0,
            forced: /./.exec !== i
        }, {
            exec: i
        })
    }, function(t, e, r) {
        var n = r(159),
            i = r(133);
        t.exports = Object.keys || function(t) {
            return n(t, i)
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(0),
            s = r(28),
            a = r(34),
            o = r(10),
            u = r(1),
            c = r(54),
            h = r(13),
            l = r(130),
            f = r(3),
            p = r(12),
            d = r(95),
            g = r(9),
            y = r(14),
            v = r(29),
            m = r(63),
            E = r(11),
            S = r(15),
            b = r(23),
            C = r(62),
            A = r(17),
            w = r(40),
            T = r(37),
            x = r(67),
            I = r(44),
            B = r(209),
            F = r(134),
            R = r(53),
            D = r(16),
            N = r(79),
            _ = r(21),
            P = r(19),
            k = r(80),
            L = r(84),
            O = r(85),
            U = r(81),
            V = r(7),
            H = r(164),
            j = r(165),
            M = r(47),
            K = r(25),
            q = r(22).forEach,
            z = L("hidden"),
            G = V("toPrimitive"),
            Y = K.set,
            W = K.getterFor("Symbol"),
            X = Object.prototype,
            Q = i.Symbol,
            Z = Q && Q.prototype,
            J = i.TypeError,
            $ = i.QObject,
            tt = s("JSON", "stringify"),
            et = R.f,
            rt = D.f,
            nt = B.f,
            it = N.f,
            st = u([].push),
            at = k("symbols"),
            ot = k("op-symbols"),
            ut = k("string-to-symbol-registry"),
            ct = k("symbol-to-string-registry"),
            ht = k("wks"),
            lt = !$ || !$.prototype || !$.prototype.findChild,
            ft = h && f((function() {
                return 7 != T(rt({}, "a", {
                    get: function() {
                        return rt(this, "a", {
                            value: 7
                        }).a
                    }
                })).a
            })) ? function(t, e, r) {
                var n = et(X, e);
                n && delete X[e], rt(t, e, r), n && t !== X && rt(X, e, n)
            } : rt,
            pt = function(t, e) {
                var r = at[t] = T(Z);
                return Y(r, {
                    type: "Symbol",
                    tag: t,
                    description: e
                }), h || (r.description = e), r
            },
            dt = function(t, e, r) {
                t === X && dt(ot, e, r), E(t);
                var n = C(e);
                return E(r), p(at, n) ? (r.enumerable ? (p(t, z) && t[z][n] && (t[z][n] = !1), r = T(r, {
                    enumerable: w(0, !1)
                })) : (p(t, z) || rt(t, z, w(1, {})), t[z][n] = !0), ft(t, n, r)) : rt(t, n, r)
            },
            gt = function(t, e) {
                E(t);
                var r = b(e),
                    n = x(r).concat(Et(r));
                return q(n, (function(e) {
                    h && !o(yt, r, e) || dt(t, e, r[e])
                })), t
            },
            yt = function(t) {
                var e = C(t),
                    r = o(it, this, e);
                return !(this === X && p(at, e) && !p(ot, e)) && (!(r || !p(this, e) || !p(at, e) || p(this, z) && this[z][e]) || r)
            },
            vt = function(t, e) {
                var r = b(t),
                    n = C(e);
                if (r !== X || !p(at, n) || p(ot, n)) {
                    var i = et(r, n);
                    return !i || !p(at, n) || p(r, z) && r[z][n] || (i.enumerable = !0), i
                }
            },
            mt = function(t) {
                var e = nt(b(t)),
                    r = [];
                return q(e, (function(t) {
                    p(at, t) || p(O, t) || st(r, t)
                })), r
            },
            Et = function(t) {
                var e = t === X,
                    r = nt(e ? ot : b(t)),
                    n = [];
                return q(r, (function(t) {
                    !p(at, t) || e && !p(X, t) || st(n, at[t])
                })), n
            };
        (l || (P(Z = (Q = function() {
            if (v(Z, this)) throw J("Symbol is not a constructor");
            var t = arguments.length && void 0 !== arguments[0] ? A(arguments[0]) : void 0,
                e = U(t),
                r = function(t) {
                    this === X && o(r, ot, t), p(this, z) && p(this[z], e) && (this[z][e] = !1), ft(this, e, w(1, t))
                };
            return h && lt && ft(X, e, {
                configurable: !0,
                set: r
            }), pt(e, t)
        }).prototype, "toString", (function() {
            return W(this).tag
        })), P(Q, "withoutSetter", (function(t) {
            return pt(U(t), t)
        })), N.f = yt, D.f = dt, R.f = vt, I.f = B.f = mt, F.f = Et, H.f = function(t) {
            return pt(V(t), t)
        }, h && (rt(Z, "description", {
            configurable: !0,
            get: function() {
                return W(this).description
            }
        }), c || P(X, "propertyIsEnumerable", yt, {
            unsafe: !0
        }))), n({
            global: !0,
            wrap: !0,
            forced: !l,
            sham: !l
        }, {
            Symbol: Q
        }), q(x(ht), (function(t) {
            j(t)
        })), n({
            target: "Symbol",
            stat: !0,
            forced: !l
        }, {
            for: function(t) {
                var e = A(t);
                if (p(ut, e)) return ut[e];
                var r = Q(e);
                return ut[e] = r, ct[r] = e, r
            },
            keyFor: function(t) {
                if (!m(t)) throw J(t + " is not a symbol");
                if (p(ct, t)) return ct[t]
            },
            useSetter: function() {
                lt = !0
            },
            useSimple: function() {
                lt = !1
            }
        }), n({
            target: "Object",
            stat: !0,
            forced: !l,
            sham: !h
        }, {
            create: function(t, e) {
                return void 0 === e ? T(t) : gt(T(t), e)
            },
            defineProperty: dt,
            defineProperties: gt,
            getOwnPropertyDescriptor: vt
        }), n({
            target: "Object",
            stat: !0,
            forced: !l
        }, {
            getOwnPropertyNames: mt,
            getOwnPropertySymbols: Et
        }), n({
            target: "Object",
            stat: !0,
            forced: f((function() {
                F.f(1)
            }))
        }, {
            getOwnPropertySymbols: function(t) {
                return F.f(S(t))
            }
        }), tt) && n({
            target: "JSON",
            stat: !0,
            forced: !l || f((function() {
                var t = Q();
                return "[null]" != tt([t]) || "{}" != tt({
                    a: t
                }) || "{}" != tt(Object(t))
            }))
        }, {
            stringify: function(t, e, r) {
                var n = _(arguments),
                    i = e;
                if ((y(e) || void 0 !== t) && !m(t)) return d(e) || (e = function(t, e) {
                    if (g(i) && (e = o(i, this, t, e)), !m(e)) return e
                }), n[1] = e, a(tt, null, n)
            }
        });
        if (!Z[G]) {
            var St = Z.valueOf;
            P(Z, G, (function(t) {
                return o(St, this)
            }))
        }
        M(Q, "Symbol"), O[z] = !0
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(13),
            s = r(0),
            a = r(1),
            o = r(12),
            u = r(9),
            c = r(29),
            h = r(17),
            l = r(16).f,
            f = r(158),
            p = s.Symbol,
            d = p && p.prototype;
        if (i && u(p) && (!("description" in d) || void 0 !== p().description)) {
            var g = {},
                y = function() {
                    var t = arguments.length < 1 || void 0 === arguments[0] ? void 0 : h(arguments[0]),
                        e = c(d, this) ? new p(t) : void 0 === t ? p() : p(t);
                    return "" === t && (g[e] = !0), e
                };
            f(y, p), y.prototype = d, d.constructor = y;
            var v = "Symbol(test)" == String(p("test")),
                m = a(d.toString),
                E = a(d.valueOf),
                S = /^Symbol\((.*)\)[^)]+$/,
                b = a("".replace),
                C = a("".slice);
            l(d, "description", {
                configurable: !0,
                get: function() {
                    var t = E(this),
                        e = m(t);
                    if (o(g, t)) return "";
                    var r = v ? C(e, 7, -1) : b(e, S, "$1");
                    return "" === r ? void 0 : r
                }
            }), n({
                global: !0,
                forced: !0
            }, {
                Symbol: y
            })
        }
    }, function(t, e, r) {
        r(165)("iterator")
    }, function(t, e, r) {
        var n = r(0),
            i = r(12),
            s = r(9),
            a = r(15),
            o = r(84),
            u = r(169),
            c = o("IE_PROTO"),
            h = n.Object,
            l = h.prototype;
        t.exports = u ? h.getPrototypeOf : function(t) {
            var e = a(t);
            if (i(e, c)) return e[c];
            var r = e.constructor;
            return s(r) && e instanceof r ? r.prototype : e instanceof h ? l : null
        }
    }, function(t, e) {
        t.exports = {}
    }, function(t, e, r) {
        var n = r(0),
            i = r(170),
            s = r(171),
            a = r(31),
            o = r(24),
            u = r(7),
            c = u("iterator"),
            h = u("toStringTag"),
            l = a.values,
            f = function(t, e) {
                if (t) {
                    if (t[c] !== l) try {
                        o(t, c, l)
                    } catch (e) {
                        t[c] = l
                    }
                    if (t[h] || o(t, h, e), i[e])
                        for (var r in a)
                            if (t[r] !== a[r]) try {
                                o(t, r, a[r])
                            } catch (e) {
                                t[r] = a[r]
                            }
                }
            };
        for (var p in i) f(n[p] && n[p].prototype, p);
        f(s, "DOMTokenList")
    }, function(t, e, r) {
        var n = r(0),
            i = r(29),
            s = n.TypeError;
        t.exports = function(t, e) {
            if (i(e, t)) return t;
            throw s("Incorrect invocation")
        }
    }, function(t, e, r) {
        var n = r(46),
            i = r(43),
            s = r(72),
            a = r(7)("iterator");
        t.exports = function(t) {
            if (null != t) return i(t, a) || i(t, "@@iterator") || s[n(t)]
        }
    }, function(t, e, r) {
        var n = r(3),
            i = r(7),
            s = r(42),
            a = i("species");
        t.exports = function(t) {
            return s >= 51 || !n((function() {
                var e = [];
                return (e.constructor = {})[a] = function() {
                    return {
                        foo: 1
                    }
                }, 1 !== e[t](Boolean).foo
            }))
        }
    }, function(t, e, r) {
        "use strict";
        r(30), r(38), r(58), r(276), r(31), r(98), r(99), r(101), r(102), r(103), r(104), r(106), r(107), r(108), r(109), r(110), r(111), r(112), r(113), r(114), r(115), r(116), r(117), r(118), r(119), r(120), r(121), r(122), r(123), r(124), r(127);
        var n = r(51),
            i = n.BigInteger,
            s = n.SecureRandom,
            a = r(277).ECCurveFp,
            o = new s,
            u = f(),
            c = u.curve,
            h = u.G,
            l = u.n;

        function f() {
            var t = new i("FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF", 16),
                e = new i("FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC", 16),
                r = new i("28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93", 16),
                n = new a(t, e, r),
                s = n.decodePointHex("0432C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0");
            return {
                curve: n,
                G: s,
                n: new i("FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123", 16)
            }
        }

        function p(t, e) {
            return t.length >= e ? t : new Array(e - t.length + 1).join("0") + t
        }
        t.exports = {
            getGlobalCurve: function() {
                return c
            },
            generateEcparam: f,
            generateKeyPairHex: function() {
                var t = new i(l.bitLength(), o).mod(l.subtract(i.ONE)).add(i.ONE),
                    e = p(t.toString(16), 64),
                    r = h.multiply(t);
                return {
                    privateKey: e,
                    publicKey: "04" + p(r.getX().toBigInteger().toString(16), 64) + p(r.getY().toBigInteger().toString(16), 64)
                }
            },
            parseUtf8StringToHex: function(t) {
                for (var e = (t = unescape(encodeURIComponent(t))).length, r = [], n = 0; n < e; n++) r[n >>> 2] |= (255 & t.charCodeAt(n)) << 24 - n % 4 * 8;
                for (var i = [], s = 0; s < e; s++) {
                    var a = r[s >>> 2] >>> 24 - s % 4 * 8 & 255;
                    i.push((a >>> 4).toString(16)), i.push((15 & a).toString(16))
                }
                return i.join("")
            },
            parseArrayBufferToHex: function(t) {
                return Array.prototype.map.call(new Uint8Array(t), (function(t) {
                    return ("00" + t.toString(16)).slice(-2)
                })).join("")
            },
            leftPad: p,
            arrayToHex: function(t) {
                for (var e = [], r = 0, n = 0; n < 2 * t.length; n += 2) e[n >>> 3] |= parseInt(t[r], 10) << 24 - n % 8 * 4, r++;
                for (var i = [], s = 0; s < t.length; s++) {
                    var a = e[s >>> 2] >>> 24 - s % 4 * 8 & 255;
                    i.push((a >>> 4).toString(16)), i.push((15 & a).toString(16))
                }
                return i.join("")
            },
            arrayToUtf8: function(t) {
                for (var e = [], r = 0, n = 0; n < 2 * t.length; n += 2) e[n >>> 3] |= parseInt(t[r], 10) << 24 - n % 8 * 4, r++;
                try {
                    for (var i = [], s = 0; s < t.length; s++) {
                        var a = e[s >>> 2] >>> 24 - s % 4 * 8 & 255;
                        i.push(String.fromCharCode(a))
                    }
                    return decodeURIComponent(escape(i.join("")))
                } catch (t) {
                    throw new Error("Malformed UTF-8 data")
                }
            },
            hexToArray: function(t) {
                var e = [],
                    r = t.length;
                r % 2 != 0 && (t = p(t, r + 1)), r = t.length;
                for (var n = 0; n < r; n += 2) e.push(parseInt(t.substr(n, 2), 16));
                return e
            }
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(1),
            s = r(65).indexOf,
            a = r(56),
            o = i([].indexOf),
            u = !!o && 1 / o([1], 1, -0) < 0,
            c = a("indexOf");
        n({
            target: "Array",
            proto: !0,
            forced: u || !c
        }, {
            indexOf: function(t) {
                var e = arguments.length > 1 ? arguments[1] : void 0;
                return u ? o(this, t, e) || 0 : s(this, t, e)
            }
        })
    }, function(t, e, r) {
        "use strict";
        var n = {}.propertyIsEnumerable,
            i = Object.getOwnPropertyDescriptor,
            s = i && !n.call({
                1: 2
            }, 1);
        e.f = s ? function(t) {
            var e = i(this, t);
            return !!e && e.enumerable
        } : n
    }, function(t, e, r) {
        var n = r(54),
            i = r(131);
        (t.exports = function(t, e) {
            return i[t] || (i[t] = void 0 !== e ? e : {})
        })("versions", []).push({
            version: "3.19.1",
            mode: n ? "pure" : "global",
            copyright: " 2021 Denis Pushkarev (zloirock.ru)"
        })
    }, function(t, e, r) {
        var n = r(1),
            i = 0,
            s = Math.random(),
            a = n(1..toString);
        t.exports = function(t) {
            return "Symbol(" + (void 0 === t ? "" : t) + ")_" + a(++i + s, 36)
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(14),
            s = n.document,
            a = i(s) && i(s.createElement);
        t.exports = function(t) {
            return a ? s.createElement(t) : {}
        }
    }, function(t, e, r) {
        var n = r(1),
            i = r(9),
            s = r(131),
            a = n(Function.toString);
        i(s.inspectSource) || (s.inspectSource = function(t) {
            return a(t)
        }), t.exports = s.inspectSource
    }, function(t, e, r) {
        var n = r(80),
            i = r(81),
            s = n("keys");
        t.exports = function(t) {
            return s[t] || (s[t] = i(t))
        }
    }, function(t, e) {
        t.exports = {}
    }, function(t, e, r) {
        var n = r(3),
            i = r(9),
            s = /#|\.prototype\./,
            a = function(t, e) {
                var r = u[o(t)];
                return r == h || r != c && (i(e) ? n(e) : !!e)
            },
            o = a.normalize = function(t) {
                return String(t).replace(s, ".").toLowerCase()
            },
            u = a.data = {},
            c = a.NATIVE = "N",
            h = a.POLYFILL = "P";
        t.exports = a
    }, function(t, e, r) {
        "use strict";
        var n, i, s = r(10),
            a = r(1),
            o = r(17),
            u = r(88),
            c = r(136),
            h = r(80),
            l = r(37),
            f = r(25).get,
            p = r(162),
            d = r(163),
            g = h("native-string-replace", String.prototype.replace),
            y = RegExp.prototype.exec,
            v = y,
            m = a("".charAt),
            E = a("".indexOf),
            S = a("".replace),
            b = a("".slice),
            C = (i = /b*/g, s(y, n = /a/, "a"), s(y, i, "a"), 0 !== n.lastIndex || 0 !== i.lastIndex),
            A = c.UNSUPPORTED_Y || c.BROKEN_CARET,
            w = void 0 !== /()??/.exec("")[1];
        (C || w || A || p || d) && (v = function(t) {
            var e, r, n, i, a, c, h, p = this,
                d = f(p),
                T = o(t),
                x = d.raw;
            if (x) return x.lastIndex = p.lastIndex, e = s(v, x, T), p.lastIndex = x.lastIndex, e;
            var I = d.groups,
                B = A && p.sticky,
                F = s(u, p),
                R = p.source,
                D = 0,
                N = T;
            if (B && (F = S(F, "y", ""), -1 === E(F, "g") && (F += "g"), N = b(T, p.lastIndex), p.lastIndex > 0 && (!p.multiline || p.multiline && "\n" !== m(T, p.lastIndex - 1)) && (R = "(?: " + R + ")", N = " " + N, D++), r = new RegExp("^(?:" + R + ")", F)), w && (r = new RegExp("^" + R + "$(?!\\s)", F)), C && (n = p.lastIndex), i = s(y, B ? r : p, N), B ? i ? (i.input = b(i.input, D), i[0] = b(i[0], D), i.index = p.lastIndex, p.lastIndex += i[0].length) : p.lastIndex = 0 : C && i && (p.lastIndex = p.global ? i.index + i[0].length : n), w && i && i.length > 1 && s(g, i[0], r, (function() {
                    for (a = 1; a < arguments.length - 2; a++) void 0 === arguments[a] && (i[a] = void 0)
                })), i && I)
                for (i.groups = c = l(null), a = 0; a < I.length; a++) c[(h = I[a])[0]] = i[h[1]];
            return i
        }), t.exports = v
    }, function(t, e, r) {
        "use strict";
        var n = r(11);
        t.exports = function() {
            var t = n(this),
                e = "";
            return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.sticky && (e += "y"), e
        }
    }, function(t, e, r) {
        "use strict";
        r(66);
        var n = r(1),
            i = r(19),
            s = r(87),
            a = r(3),
            o = r(7),
            u = r(24),
            c = o("species"),
            h = RegExp.prototype;
        t.exports = function(t, e, r, l) {
            var f = o(t),
                p = !a((function() {
                    var e = {};
                    return e[f] = function() {
                        return 7
                    }, 7 != "" [t](e)
                })),
                d = p && !a((function() {
                    var e = !1,
                        r = /a/;
                    return "split" === t && ((r = {}).constructor = {}, r.constructor[c] = function() {
                        return r
                    }, r.flags = "", r[f] = /./ [f]), r.exec = function() {
                        return e = !0, null
                    }, r[f](""), !e
                }));
            if (!p || !d || r) {
                var g = n(/./ [f]),
                    y = e(f, "" [t], (function(t, e, r, i, a) {
                        var o = n(t),
                            u = e.exec;
                        return u === s || u === h.exec ? p && !a ? {
                            done: !0,
                            value: g(e, r, i)
                        } : {
                            done: !0,
                            value: o(r, e, i)
                        } : {
                            done: !1
                        }
                    }));
                i(String.prototype, t, y[0]), i(h, f, y[1])
            }
            l && u(h[f], "sham", !0)
        }
    }, function(t, e, r) {
        var n = r(11),
            i = r(139),
            s = r(7)("species");
        t.exports = function(t, e) {
            var r, a = n(t).constructor;
            return void 0 === a || null == (r = n(a)[s]) ? e : i(r)
        }
    }, function(t, e, r) {
        var n = r(1),
            i = r(3),
            s = r(9),
            a = r(46),
            o = r(28),
            u = r(83),
            c = function() {},
            h = [],
            l = o("Reflect", "construct"),
            f = /^\s*(?:class|function)\b/,
            p = n(f.exec),
            d = !f.exec(c),
            g = function(t) {
                if (!s(t)) return !1;
                try {
                    return l(c, h, t), !0
                } catch (t) {
                    return !1
                }
            };
        t.exports = !l || i((function() {
            var t;
            return g(g.call) || !g(Object) || !g((function() {
                t = !0
            })) || t
        })) ? function(t) {
            if (!s(t)) return !1;
            switch (a(t)) {
                case "AsyncFunction":
                case "GeneratorFunction":
                case "AsyncGeneratorFunction":
                    return !1
            }
            return d || !!p(f, u(t))
        } : g
    }, function(t, e, r) {
        var n = r(1),
            i = r(26),
            s = r(17),
            a = r(27),
            o = n("".charAt),
            u = n("".charCodeAt),
            c = n("".slice),
            h = function(t) {
                return function(e, r) {
                    var n, h, l = s(a(e)),
                        f = i(r),
                        p = l.length;
                    return f < 0 || f >= p ? t ? "" : void 0 : (n = u(l, f)) < 55296 || n > 56319 || f + 1 === p || (h = u(l, f + 1)) < 56320 || h > 57343 ? t ? o(l, f) : n : t ? c(l, f, f + 2) : h - 56320 + (n - 55296 << 10) + 65536
                }
            };
        t.exports = {
            codeAt: h(!1),
            charAt: h(!0)
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(10),
            s = r(11),
            a = r(9),
            o = r(41),
            u = r(87),
            c = n.TypeError;
        t.exports = function(t, e) {
            var r = t.exec;
            if (a(r)) {
                var n = i(r, t, e);
                return null !== n && s(n), n
            }
            if ("RegExp" === o(t)) return i(u, t, e);
            throw c("RegExp#exec called on incompatible receiver")
        }
    }, function(t, e, r) {
        var n, i, s, a, o, u;
        t.exports = (u = r(4), i = (n = u).lib, s = i.Base, a = i.WordArray, (o = n.x64 = {}).Word = s.extend({
            init: function(t, e) {
                this.high = t, this.low = e
            }
        }), o.WordArray = s.extend({
            init: function(t, e) {
                t = this.words = t || [], this.sigBytes = null != e ? e : 8 * t.length
            },
            toX32: function() {
                for (var t = this.words, e = t.length, r = [], n = 0; n < e; n++) {
                    var i = t[n];
                    r.push(i.high), r.push(i.low)
                }
                return a.create(r, this.sigBytes)
            },
            clone: function() {
                for (var t = s.clone.call(this), e = t.words = this.words.slice(0), r = e.length, n = 0; n < r; n++) e[n] = e[n].clone();
                return t
            }
        }), u)
    }, function(t, e, r) {
        var n = r(41);
        t.exports = Array.isArray || function(t) {
            return "Array" == n(t)
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(0),
            i = r(1),
            s = r(13),
            a = r(142),
            o = r(55),
            u = r(24),
            c = r(143),
            h = r(3),
            l = r(74),
            f = r(26),
            p = r(33),
            d = r(174),
            g = r(213),
            y = r(71),
            v = r(48),
            m = r(44).f,
            E = r(16).f,
            S = r(175),
            b = r(21),
            C = r(47),
            A = r(25),
            w = o.PROPER,
            T = o.CONFIGURABLE,
            x = A.get,
            I = A.set,
            B = n.ArrayBuffer,
            F = B,
            R = F && F.prototype,
            D = n.DataView,
            N = D && D.prototype,
            _ = Object.prototype,
            P = n.Array,
            k = n.RangeError,
            L = i(S),
            O = i([].reverse),
            U = g.pack,
            V = g.unpack,
            H = function(t) {
                return [255 & t]
            },
            j = function(t) {
                return [255 & t, t >> 8 & 255]
            },
            M = function(t) {
                return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255]
            },
            K = function(t) {
                return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0]
            },
            q = function(t) {
                return U(t, 23, 4)
            },
            z = function(t) {
                return U(t, 52, 8)
            },
            G = function(t, e) {
                E(t.prototype, e, {
                    get: function() {
                        return x(this)[e]
                    }
                })
            },
            Y = function(t, e, r, n) {
                var i = d(r),
                    s = x(t);
                if (i + e > s.byteLength) throw k("Wrong index");
                var a = x(s.buffer).bytes,
                    o = i + s.byteOffset,
                    u = b(a, o, o + e);
                return n ? u : O(u)
            },
            W = function(t, e, r, n, i, s) {
                var a = d(r),
                    o = x(t);
                if (a + e > o.byteLength) throw k("Wrong index");
                for (var u = x(o.buffer).bytes, c = a + o.byteOffset, h = n(+i), l = 0; l < e; l++) u[c + l] = h[s ? l : e - l - 1]
            };
        if (a) {
            var X = w && "ArrayBuffer" !== B.name;
            if (h((function() {
                    B(1)
                })) && h((function() {
                    new B(-1)
                })) && !h((function() {
                    return new B, new B(1.5), new B(NaN), X && !T
                }))) X && T && u(B, "name", "ArrayBuffer");
            else {
                (F = function(t) {
                    return l(this, R), new B(d(t))
                }).prototype = R;
                for (var Q, Z = m(B), J = 0; Z.length > J;)(Q = Z[J++]) in F || u(F, Q, B[Q]);
                R.constructor = F
            }
            v && y(N) !== _ && v(N, _);
            var $ = new D(new F(2)),
                tt = i(N.setInt8);
            $.setInt8(0, 2147483648), $.setInt8(1, 2147483649), !$.getInt8(0) && $.getInt8(1) || c(N, {
                setInt8: function(t, e) {
                    tt(this, t, e << 24 >> 24)
                },
                setUint8: function(t, e) {
                    tt(this, t, e << 24 >> 24)
                }
            }, {
                unsafe: !0
            })
        } else R = (F = function(t) {
            l(this, R);
            var e = d(t);
            I(this, {
                bytes: L(P(e), 0),
                byteLength: e
            }), s || (this.byteLength = e)
        }).prototype, N = (D = function(t, e, r) {
            l(this, N), l(t, R);
            var n = x(t).byteLength,
                i = f(e);
            if (i < 0 || i > n) throw k("Wrong offset");
            if (i + (r = void 0 === r ? n - i : p(r)) > n) throw k("Wrong length");
            I(this, {
                buffer: t,
                byteLength: r,
                byteOffset: i
            }), s || (this.buffer = t, this.byteLength = r, this.byteOffset = i)
        }).prototype, s && (G(F, "byteLength"), G(D, "buffer"), G(D, "byteLength"), G(D, "byteOffset")), c(N, {
            getInt8: function(t) {
                return Y(this, 1, t)[0] << 24 >> 24
            },
            getUint8: function(t) {
                return Y(this, 1, t)[0]
            },
            getInt16: function(t) {
                var e = Y(this, 2, t, arguments.length > 1 ? arguments[1] : void 0);
                return (e[1] << 8 | e[0]) << 16 >> 16
            },
            getUint16: function(t) {
                var e = Y(this, 2, t, arguments.length > 1 ? arguments[1] : void 0);
                return e[1] << 8 | e[0]
            },
            getInt32: function(t) {
                return K(Y(this, 4, t, arguments.length > 1 ? arguments[1] : void 0))
            },
            getUint32: function(t) {
                return K(Y(this, 4, t, arguments.length > 1 ? arguments[1] : void 0)) >>> 0
            },
            getFloat32: function(t) {
                return V(Y(this, 4, t, arguments.length > 1 ? arguments[1] : void 0), 23)
            },
            getFloat64: function(t) {
                return V(Y(this, 8, t, arguments.length > 1 ? arguments[1] : void 0), 52)
            },
            setInt8: function(t, e) {
                W(this, 1, t, H, e)
            },
            setUint8: function(t, e) {
                W(this, 1, t, H, e)
            },
            setInt16: function(t, e) {
                W(this, 2, t, j, e, arguments.length > 2 ? arguments[2] : void 0)
            },
            setUint16: function(t, e) {
                W(this, 2, t, j, e, arguments.length > 2 ? arguments[2] : void 0)
            },
            setInt32: function(t, e) {
                W(this, 4, t, M, e, arguments.length > 2 ? arguments[2] : void 0)
            },
            setUint32: function(t, e) {
                W(this, 4, t, M, e, arguments.length > 2 ? arguments[2] : void 0)
            },
            setFloat32: function(t, e) {
                W(this, 4, t, q, e, arguments.length > 2 ? arguments[2] : void 0)
            },
            setFloat64: function(t, e) {
                W(this, 8, t, z, e, arguments.length > 2 ? arguments[2] : void 0)
            }
        });
        C(F, "ArrayBuffer"), C(D, "DataView"), t.exports = {
            ArrayBuffer: F,
            DataView: D
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(28),
            i = r(16),
            s = r(7),
            a = r(13),
            o = s("species");
        t.exports = function(t) {
            var e = n(t),
                r = i.f;
            a && e && !e[o] && r(e, o, {
                configurable: !0,
                get: function() {
                    return this
                }
            })
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(1),
            s = r(3),
            a = r(96),
            o = r(11),
            u = r(45),
            c = r(33),
            h = r(90),
            l = a.ArrayBuffer,
            f = a.DataView,
            p = f.prototype,
            d = i(l.prototype.slice),
            g = i(p.getUint8),
            y = i(p.setUint8);
        n({
            target: "ArrayBuffer",
            proto: !0,
            unsafe: !0,
            forced: s((function() {
                return !new l(2).slice(1, void 0).byteLength
            }))
        }, {
            slice: function(t, e) {
                if (d && void 0 === e) return d(o(this), t);
                for (var r = o(this).byteLength, n = u(t, r), i = u(void 0 === e ? r : e, r), s = new(h(this, l))(c(i - n)), a = new f(this), p = new f(s), v = 0; n < i;) y(p, v++, g(a, n++));
                return s
            }
        })
    }, function(t, e, r) {
        r(35)("Uint8", (function(t) {
            return function(e, r, n) {
                return t(this, e, r, n)
            }
        }))
    }, function(t, e, r) {
        var n = r(0),
            i = r(10),
            s = r(32),
            a = r(11),
            o = r(64),
            u = r(75),
            c = n.TypeError;
        t.exports = function(t, e) {
            var r = arguments.length < 2 ? u(t) : e;
            if (s(r)) return a(i(r, t));
            throw c(o(t) + " is not iterable")
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(1),
            i = r(8),
            s = n(r(218)),
            a = i.aTypedArray;
        (0, i.exportTypedArrayMethod)("copyWithin", (function(t, e) {
            return s(a(this), t, e, arguments.length > 2 ? arguments[2] : void 0)
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(22).every,
            s = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("every", (function(t) {
            return i(s(this), t, arguments.length > 1 ? arguments[1] : void 0)
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(10),
            s = r(175),
            a = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("fill", (function(t) {
            var e = arguments.length;
            return i(s, a(this), t, e > 1 ? arguments[1] : void 0, e > 2 ? arguments[2] : void 0)
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(22).filter,
            s = r(219),
            a = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("filter", (function(t) {
            var e = i(a(this), t, arguments.length > 1 ? arguments[1] : void 0);
            return s(this, e)
        }))
    }, function(t, e, r) {
        var n = r(8),
            i = r(90),
            s = n.TYPED_ARRAY_CONSTRUCTOR,
            a = n.aTypedArrayConstructor;
        t.exports = function(t) {
            return a(i(t, t[s]))
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(22).find,
            s = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("find", (function(t) {
            return i(s(this), t, arguments.length > 1 ? arguments[1] : void 0)
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(22).findIndex,
            s = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("findIndex", (function(t) {
            return i(s(this), t, arguments.length > 1 ? arguments[1] : void 0)
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(22).forEach,
            s = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("forEach", (function(t) {
            i(s(this), t, arguments.length > 1 ? arguments[1] : void 0)
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(65).includes,
            s = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("includes", (function(t) {
            return i(s(this), t, arguments.length > 1 ? arguments[1] : void 0)
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(65).indexOf,
            s = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("indexOf", (function(t) {
            return i(s(this), t, arguments.length > 1 ? arguments[1] : void 0)
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(0),
            i = r(1),
            s = r(55).PROPER,
            a = r(8),
            o = r(31),
            u = r(7)("iterator"),
            c = n.Uint8Array,
            h = i(o.values),
            l = i(o.keys),
            f = i(o.entries),
            p = a.aTypedArray,
            d = a.exportTypedArrayMethod,
            g = c && c.prototype[u],
            y = !!g && "values" === g.name,
            v = function() {
                return h(p(this))
            };
        d("entries", (function() {
            return f(p(this))
        })), d("keys", (function() {
            return l(p(this))
        })), d("values", v, s && !y), d(u, v, s && !y)
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(1),
            s = n.aTypedArray,
            a = n.exportTypedArrayMethod,
            o = i([].join);
        a("join", (function(t) {
            return o(s(this), t)
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(34),
            s = r(221),
            a = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("lastIndexOf", (function(t) {
            var e = arguments.length;
            return i(s, a(this), e > 1 ? [t, arguments[1]] : [t])
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(22).map,
            s = r(105),
            a = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("map", (function(t) {
            return i(a(this), t, arguments.length > 1 ? arguments[1] : void 0, (function(t, e) {
                return new(s(t))(e)
            }))
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(147).left,
            s = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("reduce", (function(t) {
            var e = arguments.length;
            return i(s(this), t, e, e > 1 ? arguments[1] : void 0)
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(147).right,
            s = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("reduceRight", (function(t) {
            var e = arguments.length;
            return i(s(this), t, e, e > 1 ? arguments[1] : void 0)
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = n.aTypedArray,
            s = n.exportTypedArrayMethod,
            a = Math.floor;
        s("reverse", (function() {
            for (var t, e = i(this).length, r = a(e / 2), n = 0; n < r;) t = this[n], this[n++] = this[--e], this[e] = t;
            return this
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(0),
            i = r(8),
            s = r(20),
            a = r(176),
            o = r(15),
            u = r(3),
            c = n.RangeError,
            h = i.aTypedArray;
        (0, i.exportTypedArrayMethod)("set", (function(t) {
            h(this);
            var e = a(arguments.length > 1 ? arguments[1] : void 0, 1),
                r = this.length,
                n = o(t),
                i = s(n),
                u = 0;
            if (i + e > r) throw c("Wrong length");
            for (; u < i;) this[e + u] = n[u++]
        }), u((function() {
            new Int8Array(1).set({})
        })))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(105),
            s = r(3),
            a = r(21),
            o = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("slice", (function(t, e) {
            for (var r = a(o(this), t, e), n = i(this), s = 0, u = r.length, c = new n(u); u > s;) c[s] = r[s++];
            return c
        }), s((function() {
            new Int8Array(1).slice()
        })))
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(22).some,
            s = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("some", (function(t) {
            return i(s(this), t, arguments.length > 1 ? arguments[1] : void 0)
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(0),
            i = r(1),
            s = r(3),
            a = r(32),
            o = r(148),
            u = r(8),
            c = r(177),
            h = r(178),
            l = r(42),
            f = r(179),
            p = n.Array,
            d = u.aTypedArray,
            g = u.exportTypedArrayMethod,
            y = n.Uint16Array,
            v = y && i(y.prototype.sort),
            m = !(!v || s((function() {
                v(new y(2), null)
            })) && s((function() {
                v(new y(2), {})
            }))),
            E = !!v && !s((function() {
                if (l) return l < 74;
                if (c) return c < 67;
                if (h) return !0;
                if (f) return f < 602;
                var t, e, r = new y(516),
                    n = p(516);
                for (t = 0; t < 516; t++) e = t % 4, r[t] = 515 - t, n[t] = t - 2 * e + 3;
                for (v(r, (function(t, e) {
                        return (t / 4 | 0) - (e / 4 | 0)
                    })), t = 0; t < 516; t++)
                    if (r[t] !== n[t]) return !0
            }));
        g("sort", (function(t) {
            return void 0 !== t && a(t), E ? v(this, t) : o(d(this), function(t) {
                return function(e, r) {
                    return void 0 !== t ? +t(e, r) || 0 : r != r ? -1 : e != e ? 1 : 0 === e && 0 === r ? 1 / e > 0 && 1 / r < 0 ? 1 : -1 : e > r
                }
            }(t))
        }), !E || m)
    }, function(t, e, r) {
        "use strict";
        var n = r(8),
            i = r(33),
            s = r(45),
            a = r(105),
            o = n.aTypedArray;
        (0, n.exportTypedArrayMethod)("subarray", (function(t, e) {
            var r = o(this),
                n = r.length,
                u = s(t, n);
            return new(a(r))(r.buffer, r.byteOffset + u * r.BYTES_PER_ELEMENT, i((void 0 === e ? n : s(e, n)) - u))
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(0),
            i = r(34),
            s = r(8),
            a = r(3),
            o = r(21),
            u = n.Int8Array,
            c = s.aTypedArray,
            h = s.exportTypedArrayMethod,
            l = [].toLocaleString,
            f = !!u && a((function() {
                l.call(new u(1))
            }));
        h("toLocaleString", (function() {
            return i(l, f ? o(c(this)) : c(this), o(arguments))
        }), a((function() {
            return [1, 2].toLocaleString() != new u([1, 2]).toLocaleString()
        })) || !a((function() {
            u.prototype.toLocaleString.call([1, 2])
        })))
    }, function(t, e, r) {
        "use strict";
        var n = r(8).exportTypedArrayMethod,
            i = r(3),
            s = r(0),
            a = r(1),
            o = s.Uint8Array,
            u = o && o.prototype || {},
            c = [].toString,
            h = a([].join);
        i((function() {
            c.call({})
        })) && (c = function() {
            return h(this)
        });
        var l = u.toString != c;
        n("toString", c, l)
    }, function(t, e, r) {
        var n, i, s, a;
        t.exports = (n = r(4), s = (i = n).lib.Base, a = i.enc.Utf8, void(i.algo.HMAC = s.extend({
            init: function(t, e) {
                t = this._hasher = new t.init, "string" == typeof e && (e = a.parse(e));
                var r = t.blockSize,
                    n = 4 * r;
                e.sigBytes > n && (e = t.finalize(e)), e.clamp();
                for (var i = this._oKey = e.clone(), s = this._iKey = e.clone(), o = i.words, u = s.words, c = 0; c < r; c++) o[c] ^= 1549556828, u[c] ^= 909522486;
                i.sigBytes = s.sigBytes = n, this.reset()
            },
            reset: function() {
                var t = this._hasher;
                t.reset(), t.update(this._iKey)
            },
            update: function(t) {
                return this._hasher.update(t), this
            },
            finalize: function(t) {
                var e = this._hasher,
                    r = e.finalize(t);
                return e.reset(), e.finalize(this._oKey.clone().concat(r))
            }
        })))
    }, function(t, e, r) {
        var n = r(41),
            i = r(0);
        t.exports = "process" == n(i.process)
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(0),
            s = r(95),
            a = r(91),
            o = r(14),
            u = r(45),
            c = r(20),
            h = r(23),
            l = r(128),
            f = r(7),
            p = r(76),
            d = r(21),
            g = p("slice"),
            y = f("species"),
            v = i.Array,
            m = Math.max;
        n({
            target: "Array",
            proto: !0,
            forced: !g
        }, {
            slice: function(t, e) {
                var r, n, i, f = h(this),
                    p = c(f),
                    g = u(t, p),
                    E = u(void 0 === e ? p : e, p);
                if (s(f) && (r = f.constructor, (a(r) && (r === v || s(r.prototype)) || o(r) && null === (r = r[y])) && (r = void 0), r === v || void 0 === r)) return d(f, g, E);
                for (n = new(void 0 === r ? v : r)(m(E - g, 0)), i = 0; g < E; g++, i++) g in f && l(n, i, f[g]);
                return n.length = i, n
            }
        })
    }, function(t, e, r) {
        "use strict";
        var n = r(62),
            i = r(16),
            s = r(40);
        t.exports = function(t, e, r) {
            var a = n(e);
            a in t ? i.f(t, a, s(0, r)) : t[a] = r
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(0),
            s = r(3),
            a = r(95),
            o = r(14),
            u = r(15),
            c = r(20),
            h = r(128),
            l = r(141),
            f = r(76),
            p = r(7),
            d = r(42),
            g = p("isConcatSpreadable"),
            y = i.TypeError,
            v = d >= 51 || !s((function() {
                var t = [];
                return t[g] = !1, t.concat()[0] !== t
            })),
            m = f("concat"),
            E = function(t) {
                if (!o(t)) return !1;
                var e = t[g];
                return void 0 !== e ? !!e : a(t)
            };
        n({
            target: "Array",
            proto: !0,
            forced: !v || !m
        }, {
            concat: function(t) {
                var e, r, n, i, s, a = u(this),
                    o = l(a, 0),
                    f = 0;
                for (e = -1, n = arguments.length; e < n; e++)
                    if (E(s = -1 === e ? a : arguments[e])) {
                        if (f + (i = c(s)) > 9007199254740991) throw y("Maximum allowed index exceeded");
                        for (r = 0; r < i; r++, f++) r in s && h(o, f, s[r])
                    } else {
                        if (f >= 9007199254740991) throw y("Maximum allowed index exceeded");
                        h(o, f++, s)
                    }
                return o.length = f, o
            }
        })
    }, function(t, e, r) {
        var n = r(42),
            i = r(3);
        t.exports = !!Object.getOwnPropertySymbols && !i((function() {
            var t = Symbol();
            return !String(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && n && n < 41
        }))
    }, function(t, e, r) {
        var n = r(0),
            i = r(132),
            s = n["__core-js_shared__"] || i("__core-js_shared__", {});
        t.exports = s
    }, function(t, e, r) {
        var n = r(0),
            i = Object.defineProperty;
        t.exports = function(t, e) {
            try {
                i(n, t, {
                    value: e,
                    configurable: !0,
                    writable: !0
                })
            } catch (r) {
                n[t] = e
            }
            return e
        }
    }, function(t, e) {
        t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
    }, function(t, e) {
        e.f = Object.getOwnPropertySymbols
    }, function(t, e, r) {
        var n = {};
        n[r(7)("toStringTag")] = "z", t.exports = "[object z]" === String(n)
    }, function(t, e, r) {
        var n = r(3),
            i = r(0).RegExp;
        e.UNSUPPORTED_Y = n((function() {
            var t = i("a", "y");
            return t.lastIndex = 2, null != t.exec("abcd")
        })), e.BROKEN_CARET = n((function() {
            var t = i("^r", "gy");
            return t.lastIndex = 2, null != t.exec("str")
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(34),
            i = r(10),
            s = r(1),
            a = r(89),
            o = r(138),
            u = r(11),
            c = r(27),
            h = r(90),
            l = r(140),
            f = r(33),
            p = r(17),
            d = r(43),
            g = r(21),
            y = r(93),
            v = r(87),
            m = r(136),
            E = r(3),
            S = m.UNSUPPORTED_Y,
            b = Math.min,
            C = [].push,
            A = s(/./.exec),
            w = s(C),
            T = s("".slice);
        a("split", (function(t, e, r) {
            var s;
            return s = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t, r) {
                var s = p(c(this)),
                    a = void 0 === r ? 4294967295 : r >>> 0;
                if (0 === a) return [];
                if (void 0 === t) return [s];
                if (!o(t)) return i(e, s, t, a);
                for (var u, h, l, f = [], d = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), y = 0, m = new RegExp(t.source, d + "g");
                    (u = i(v, m, s)) && !((h = m.lastIndex) > y && (w(f, T(s, y, u.index)), u.length > 1 && u.index < s.length && n(C, f, g(u, 1)), l = u[0].length, y = h, f.length >= a));) m.lastIndex === u.index && m.lastIndex++;
                return y === s.length ? !l && A(m, "") || w(f, "") : w(f, T(s, y)), f.length > a ? g(f, 0, a) : f
            } : "0".split(void 0, 0).length ? function(t, r) {
                return void 0 === t && 0 === r ? [] : i(e, this, t, r)
            } : e, [function(e, r) {
                var n = c(this),
                    a = null == e ? void 0 : d(e, t);
                return a ? i(a, e, n, r) : i(s, p(n), e, r)
            }, function(t, n) {
                var i = u(this),
                    a = p(t),
                    o = r(s, i, a, n, s !== e);
                if (o.done) return o.value;
                var c = h(i, RegExp),
                    d = i.unicode,
                    g = (i.ignoreCase ? "i" : "") + (i.multiline ? "m" : "") + (i.unicode ? "u" : "") + (S ? "g" : "y"),
                    v = new c(S ? "^(?:" + i.source + ")" : i, g),
                    m = void 0 === n ? 4294967295 : n >>> 0;
                if (0 === m) return [];
                if (0 === a.length) return null === y(v, a) ? [a] : [];
                for (var E = 0, C = 0, A = []; C < a.length;) {
                    v.lastIndex = S ? 0 : C;
                    var x, I = y(v, S ? T(a, C) : a);
                    if (null === I || (x = b(f(v.lastIndex + (S ? C : 0)), a.length)) === E) C = l(a, C, d);
                    else {
                        if (w(A, T(a, E, C)), A.length === m) return A;
                        for (var B = 1; B <= I.length - 1; B++)
                            if (w(A, I[B]), A.length === m) return A;
                        C = E = x
                    }
                }
                return w(A, T(a, E)), A
            }]
        }), !!E((function() {
            var t = /(?:)/,
                e = t.exec;
            t.exec = function() {
                return e.apply(this, arguments)
            };
            var r = "ab".split(t);
            return 2 !== r.length || "a" !== r[0] || "b" !== r[1]
        })), S)
    }, function(t, e, r) {
        var n = r(14),
            i = r(41),
            s = r(7)("match");
        t.exports = function(t) {
            var e;
            return n(t) && (void 0 !== (e = t[s]) ? !!e : "RegExp" == i(t))
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(91),
            s = r(64),
            a = n.TypeError;
        t.exports = function(t) {
            if (i(t)) return t;
            throw a(s(t) + " is not a constructor")
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(92).charAt;
        t.exports = function(t, e, r) {
            return e + (r ? n(t, e).length : 1)
        }
    }, function(t, e, r) {
        var n = r(211);
        t.exports = function(t, e) {
            return new(n(t))(0 === e ? 0 : e)
        }
    }, function(t, e) {
        t.exports = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView
    }, function(t, e, r) {
        var n = r(19);
        t.exports = function(t, e, r) {
            for (var i in e) n(t, i, e[i], r);
            return t
        }
    }, function(t, e, r) {
        var n = r(7)("iterator"),
            i = !1;
        try {
            var s = 0,
                a = {
                    next: function() {
                        return {
                            done: !!s++
                        }
                    },
                    return: function() {
                        i = !0
                    }
                };
            a[n] = function() {
                return this
            }, Array.from(a, (function() {
                throw 2
            }))
        } catch (t) {}
        t.exports = function(t, e) {
            if (!e && !i) return !1;
            var r = !1;
            try {
                var s = {};
                s[n] = function() {
                    return {
                        next: function() {
                            return {
                                done: r = !0
                            }
                        }
                    }
                }, t(s)
            } catch (t) {}
            return r
        }
    }, function(t, e, r) {
        var n = r(7),
            i = r(72),
            s = n("iterator"),
            a = Array.prototype;
        t.exports = function(t) {
            return void 0 !== t && (i.Array === t || a[s] === t)
        }
    }, function(t, e, r) {
        var n = r(9),
            i = r(14),
            s = r(48);
        t.exports = function(t, e, r) {
            var a, o;
            return s && n(a = e.constructor) && a !== r && i(o = a.prototype) && o !== r.prototype && s(t, o), t
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(32),
            s = r(15),
            a = r(61),
            o = r(20),
            u = n.TypeError,
            c = function(t) {
                return function(e, r, n, c) {
                    i(r);
                    var h = s(e),
                        l = a(h),
                        f = o(h),
                        p = t ? f - 1 : 0,
                        d = t ? -1 : 1;
                    if (n < 2)
                        for (;;) {
                            if (p in l) {
                                c = l[p], p += d;
                                break
                            }
                            if (p += d, t ? p < 0 : f <= p) throw u("Reduce of empty array with no initial value")
                        }
                    for (; t ? p >= 0 : f > p; p += d) p in l && (c = r(c, l[p], p, h));
                    return c
                }
            };
        t.exports = {
            left: c(!1),
            right: c(!0)
        }
    }, function(t, e, r) {
        var n = r(21),
            i = Math.floor,
            s = function(t, e) {
                var r = t.length,
                    u = i(r / 2);
                return r < 8 ? a(t, e) : o(t, s(n(t, 0, u), e), s(n(t, u), e), e)
            },
            a = function(t, e) {
                for (var r, n, i = t.length, s = 1; s < i;) {
                    for (n = s, r = t[s]; n && e(t[n - 1], r) > 0;) t[n] = t[--n];
                    n !== s++ && (t[n] = r)
                }
                return t
            },
            o = function(t, e, r, n) {
                for (var i = e.length, s = r.length, a = 0, o = 0; a < i || o < s;) t[a + o] = a < i && o < s ? n(e[a], r[o]) <= 0 ? e[a++] : r[o++] : a < i ? e[a++] : r[o++];
                return t
            };
        t.exports = s
    }, function(t, e, r) {
        var n, i, s, a, o, u, c, h;
        t.exports = (h = r(4), i = (n = h).lib, s = i.WordArray, a = i.Hasher, o = n.algo, u = [], c = o.SHA1 = a.extend({
            _doReset: function() {
                this._hash = new s.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
            },
            _doProcessBlock: function(t, e) {
                for (var r = this._hash.words, n = r[0], i = r[1], s = r[2], a = r[3], o = r[4], c = 0; c < 80; c++) {
                    if (c < 16) u[c] = 0 | t[e + c];
                    else {
                        var h = u[c - 3] ^ u[c - 8] ^ u[c - 14] ^ u[c - 16];
                        u[c] = h << 1 | h >>> 31
                    }
                    var l = (n << 5 | n >>> 27) + o + u[c];
                    l += c < 20 ? 1518500249 + (i & s | ~i & a) : c < 40 ? 1859775393 + (i ^ s ^ a) : c < 60 ? (i & s | i & a | s & a) - 1894007588 : (i ^ s ^ a) - 899497514, o = a, a = s, s = i << 30 | i >>> 2, i = n, n = l
                }
                r[0] = r[0] + n | 0, r[1] = r[1] + i | 0, r[2] = r[2] + s | 0, r[3] = r[3] + a | 0, r[4] = r[4] + o | 0
            },
            _doFinalize: function() {
                var t = this._data,
                    e = t.words,
                    r = 8 * this._nDataBytes,
                    n = 8 * t.sigBytes;
                return e[n >>> 5] |= 128 << 24 - n % 32, e[14 + (n + 64 >>> 9 << 4)] = Math.floor(r / 4294967296), e[15 + (n + 64 >>> 9 << 4)] = r, t.sigBytes = 4 * e.length, this._process(), this._hash
            },
            clone: function() {
                var t = a.clone.call(this);
                return t._hash = this._hash.clone(), t
            }
        }), n.SHA1 = a._createHelper(c), n.HmacSHA1 = a._createHmacHelper(c), h.SHA1)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), function(t) {
            var e = n,
                r = e.lib,
                i = r.WordArray,
                s = r.Hasher,
                a = e.algo,
                o = [],
                u = [];
            ! function() {
                function e(e) {
                    for (var r = t.sqrt(e), n = 2; n <= r; n++)
                        if (!(e % n)) return !1;
                    return !0
                }

                function r(t) {
                    return 4294967296 * (t - (0 | t)) | 0
                }
                for (var n = 2, i = 0; i < 64;) e(n) && (i < 8 && (o[i] = r(t.pow(n, .5))), u[i] = r(t.pow(n, 1 / 3)), i++), n++
            }();
            var c = [],
                h = a.SHA256 = s.extend({
                    _doReset: function() {
                        this._hash = new i.init(o.slice(0))
                    },
                    _doProcessBlock: function(t, e) {
                        for (var r = this._hash.words, n = r[0], i = r[1], s = r[2], a = r[3], o = r[4], h = r[5], l = r[6], f = r[7], p = 0; p < 64; p++) {
                            if (p < 16) c[p] = 0 | t[e + p];
                            else {
                                var d = c[p - 15],
                                    g = (d << 25 | d >>> 7) ^ (d << 14 | d >>> 18) ^ d >>> 3,
                                    y = c[p - 2],
                                    v = (y << 15 | y >>> 17) ^ (y << 13 | y >>> 19) ^ y >>> 10;
                                c[p] = g + c[p - 7] + v + c[p - 16]
                            }
                            var m = n & i ^ n & s ^ i & s,
                                E = (n << 30 | n >>> 2) ^ (n << 19 | n >>> 13) ^ (n << 10 | n >>> 22),
                                S = f + ((o << 26 | o >>> 6) ^ (o << 21 | o >>> 11) ^ (o << 7 | o >>> 25)) + (o & h ^ ~o & l) + u[p] + c[p];
                            f = l, l = h, h = o, o = a + S | 0, a = s, s = i, i = n, n = S + (E + m) | 0
                        }
                        r[0] = r[0] + n | 0, r[1] = r[1] + i | 0, r[2] = r[2] + s | 0, r[3] = r[3] + a | 0, r[4] = r[4] + o | 0, r[5] = r[5] + h | 0, r[6] = r[6] + l | 0, r[7] = r[7] + f | 0
                    },
                    _doFinalize: function() {
                        var e = this._data,
                            r = e.words,
                            n = 8 * this._nDataBytes,
                            i = 8 * e.sigBytes;
                        return r[i >>> 5] |= 128 << 24 - i % 32, r[14 + (i + 64 >>> 9 << 4)] = t.floor(n / 4294967296), r[15 + (i + 64 >>> 9 << 4)] = n, e.sigBytes = 4 * r.length, this._process(), this._hash
                    },
                    clone: function() {
                        var t = s.clone.call(this);
                        return t._hash = this._hash.clone(), t
                    }
                });
            e.SHA256 = s._createHelper(h), e.HmacSHA256 = s._createHmacHelper(h)
        }(Math), n.SHA256)
    }, function(t, e) {
        var r, n, i = t.exports = {};

        function s() {
            throw new Error("setTimeout has not been defined")
        }

        function a() {
            throw new Error("clearTimeout has not been defined")
        }

        function o(t) {
            if (r === setTimeout) return setTimeout(t, 0);
            if ((r === s || !r) && setTimeout) return r = setTimeout, setTimeout(t, 0);
            try {
                return r(t, 0)
            } catch (e) {
                try {
                    return r.call(null, t, 0)
                } catch (e) {
                    return r.call(this, t, 0)
                }
            }
        }! function() {
            try {
                r = "function" == typeof setTimeout ? setTimeout : s
            } catch (t) {
                r = s
            }
            try {
                n = "function" == typeof clearTimeout ? clearTimeout : a
            } catch (t) {
                n = a
            }
        }();
        var u, c = [],
            h = !1,
            l = -1;

        function f() {
            h && u && (h = !1, u.length ? c = u.concat(c) : l = -1, c.length && p())
        }

        function p() {
            if (!h) {
                var t = o(f);
                h = !0;
                for (var e = c.length; e;) {
                    for (u = c, c = []; ++l < e;) u && u[l].run();
                    l = -1, e = c.length
                }
                u = null, h = !1,
                    function(t) {
                        if (n === clearTimeout) return clearTimeout(t);
                        if ((n === a || !n) && clearTimeout) return n = clearTimeout, clearTimeout(t);
                        try {
                            n(t)
                        } catch (e) {
                            try {
                                return n.call(null, t)
                            } catch (e) {
                                return n.call(this, t)
                            }
                        }
                    }(t)
            }
        }

        function d(t, e) {
            this.fun = t, this.array = e
        }

        function g() {}
        i.nextTick = function(t) {
            var e = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
            c.push(new d(t, e)), 1 !== c.length || h || o(p)
        }, d.prototype.run = function() {
            this.fun.apply(null, this.array)
        }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = g, i.addListener = g, i.once = g, i.off = g, i.removeListener = g, i.removeAllListeners = g, i.emit = g, i.prependListener = g, i.prependOnceListener = g, i.listeners = function(t) {
            return []
        }, i.binding = function(t) {
            throw new Error("process.binding is not supported")
        }, i.cwd = function() {
            return "/"
        }, i.chdir = function(t) {
            throw new Error("process.chdir is not supported")
        }, i.umask = function() {
            return 0
        }
    }, function(t, e, r) {
        var n, i, s, a, o = r(0),
            u = r(34),
            c = r(39),
            h = r(9),
            l = r(12),
            f = r(3),
            p = r(161),
            d = r(21),
            g = r(82),
            y = r(185),
            v = r(126),
            m = o.setImmediate,
            E = o.clearImmediate,
            S = o.process,
            b = o.Dispatch,
            C = o.Function,
            A = o.MessageChannel,
            w = o.String,
            T = 0,
            x = {};
        try {
            n = o.location
        } catch (t) {}
        var I = function(t) {
                if (l(x, t)) {
                    var e = x[t];
                    delete x[t], e()
                }
            },
            B = function(t) {
                return function() {
                    I(t)
                }
            },
            F = function(t) {
                I(t.data)
            },
            R = function(t) {
                o.postMessage(w(t), n.protocol + "//" + n.host)
            };
        m && E || (m = function(t) {
            var e = d(arguments, 1);
            return x[++T] = function() {
                u(h(t) ? t : C(t), void 0, e)
            }, i(T), T
        }, E = function(t) {
            delete x[t]
        }, v ? i = function(t) {
            S.nextTick(B(t))
        } : b && b.now ? i = function(t) {
            b.now(B(t))
        } : A && !y ? (a = (s = new A).port2, s.port1.onmessage = F, i = c(a.postMessage, a)) : o.addEventListener && h(o.postMessage) && !o.importScripts && n && "file:" !== n.protocol && !f(R) ? (i = R, o.addEventListener("message", F, !1)) : i = "onreadystatechange" in g("script") ? function(t) {
            p.appendChild(g("script")).onreadystatechange = function() {
                p.removeChild(this), I(t)
            }
        } : function(t) {
            setTimeout(B(t), 0)
        }), t.exports = {
            set: m,
            clear: E
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(147).left,
            s = r(56),
            a = r(42),
            o = r(126);
        n({
            target: "Array",
            proto: !0,
            forced: !s("reduce") || !o && a > 79 && a < 83
        }, {
            reduce: function(t) {
                var e = arguments.length;
                return i(this, t, e, e > 1 ? arguments[1] : void 0)
            }
        })
    }, function(t, e, r) {
        "use strict";
        var n = r(10),
            i = r(89),
            s = r(11),
            a = r(33),
            o = r(17),
            u = r(27),
            c = r(43),
            h = r(140),
            l = r(93);
        i("match", (function(t, e, r) {
            return [function(e) {
                var r = u(this),
                    i = null == e ? void 0 : c(e, t);
                return i ? n(i, e, r) : new RegExp(e)[t](o(r))
            }, function(t) {
                var n = s(this),
                    i = o(t),
                    u = r(e, n, i);
                if (u.done) return u.value;
                if (!n.global) return l(n, i);
                var c = n.unicode;
                n.lastIndex = 0;
                for (var f, p = [], d = 0; null !== (f = l(n, i));) {
                    var g = o(f[0]);
                    p[d] = g, "" === g && (n.lastIndex = h(i, a(n.lastIndex), c)), d++
                }
                return 0 === d ? null : p
            }]
        }))
    }, function(t, e, r) {
        var n = r(0),
            i = r(10),
            s = r(14),
            a = r(63),
            o = r(43),
            u = r(202),
            c = r(7),
            h = n.TypeError,
            l = c("toPrimitive");
        t.exports = function(t, e) {
            if (!s(t) || a(t)) return t;
            var r, n = o(t, l);
            if (n) {
                if (void 0 === e && (e = "default"), r = i(n, t, e), !s(r) || a(r)) return r;
                throw h("Can't convert object to primitive value")
            }
            return void 0 === e && (e = "number"), u(t, e)
        }
    }, function(t, e, r) {
        var n = r(130);
        t.exports = n && !Symbol.sham && "symbol" == typeof Symbol.iterator
    }, function(t, e, r) {
        var n = r(13),
            i = r(3),
            s = r(82);
        t.exports = !n && !i((function() {
            return 7 != Object.defineProperty(s("div"), "a", {
                get: function() {
                    return 7
                }
            }).a
        }))
    }, function(t, e, r) {
        var n = r(12),
            i = r(204),
            s = r(53),
            a = r(16);
        t.exports = function(t, e) {
            for (var r = i(e), o = a.f, u = s.f, c = 0; c < r.length; c++) {
                var h = r[c];
                n(t, h) || o(t, h, u(e, h))
            }
        }
    }, function(t, e, r) {
        var n = r(1),
            i = r(12),
            s = r(23),
            a = r(65).indexOf,
            o = r(85),
            u = n([].push);
        t.exports = function(t, e) {
            var r, n = s(t),
                c = 0,
                h = [];
            for (r in n) !i(o, r) && i(n, r) && u(h, r);
            for (; e.length > c;) i(n, r = e[c++]) && (~a(h, r) || u(h, r));
            return h
        }
    }, function(t, e, r) {
        var n = r(13),
            i = r(16),
            s = r(11),
            a = r(23),
            o = r(67);
        t.exports = n ? Object.defineProperties : function(t, e) {
            s(t);
            for (var r, n = a(e), u = o(e), c = u.length, h = 0; c > h;) i.f(t, r = u[h++], n[r]);
            return t
        }
    }, function(t, e, r) {
        var n = r(28);
        t.exports = n("document", "documentElement")
    }, function(t, e, r) {
        var n = r(3),
            i = r(0).RegExp;
        t.exports = n((function() {
            var t = i(".", "s");
            return !(t.dotAll && t.exec("\n") && "s" === t.flags)
        }))
    }, function(t, e, r) {
        var n = r(3),
            i = r(0).RegExp;
        t.exports = n((function() {
            var t = i("(?<a>b)", "g");
            return "b" !== t.exec("b").groups.a || "bc" !== "b".replace(t, "$<a>c")
        }))
    }, function(t, e, r) {
        var n = r(7);
        e.f = n
    }, function(t, e, r) {
        var n = r(210),
            i = r(12),
            s = r(164),
            a = r(16).f;
        t.exports = function(t) {
            var e = n.Symbol || (n.Symbol = {});
            i(e, t) || a(e, t, {
                value: s.f(t)
            })
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(10),
            s = r(54),
            a = r(55),
            o = r(9),
            u = r(167),
            c = r(71),
            h = r(48),
            l = r(47),
            f = r(24),
            p = r(19),
            d = r(7),
            g = r(72),
            y = r(168),
            v = a.PROPER,
            m = a.CONFIGURABLE,
            E = y.IteratorPrototype,
            S = y.BUGGY_SAFARI_ITERATORS,
            b = d("iterator"),
            C = function() {
                return this
            };
        t.exports = function(t, e, r, a, d, y, A) {
            u(r, e, a);
            var w, T, x, I = function(t) {
                    if (t === d && N) return N;
                    if (!S && t in R) return R[t];
                    switch (t) {
                        case "keys":
                        case "values":
                        case "entries":
                            return function() {
                                return new r(this, t)
                            }
                    }
                    return function() {
                        return new r(this)
                    }
                },
                B = e + " Iterator",
                F = !1,
                R = t.prototype,
                D = R[b] || R["@@iterator"] || d && R[d],
                N = !S && D || I(d),
                _ = "Array" == e && R.entries || D;
            if (_ && (w = c(_.call(new t))) !== Object.prototype && w.next && (s || c(w) === E || (h ? h(w, E) : o(w[b]) || p(w, b, C)), l(w, B, !0, !0), s && (g[B] = C)), v && "values" == d && D && "values" !== D.name && (!s && m ? f(R, "name", "values") : (F = !0, N = function() {
                    return i(D, this)
                })), d)
                if (T = {
                        values: I("values"),
                        keys: y ? N : I("keys"),
                        entries: I("entries")
                    }, A)
                    for (x in T)(S || F || !(x in R)) && p(R, x, T[x]);
                else n({
                    target: e,
                    proto: !0,
                    forced: S || F
                }, T);
            return s && !A || R[b] === N || p(R, b, N, {
                name: d
            }), g[e] = N, T
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(168).IteratorPrototype,
            i = r(37),
            s = r(40),
            a = r(47),
            o = r(72),
            u = function() {
                return this
            };
        t.exports = function(t, e, r) {
            var c = e + " Iterator";
            return t.prototype = i(n, {
                next: s(1, r)
            }), a(t, c, !1, !0), o[c] = u, t
        }
    }, function(t, e, r) {
        "use strict";
        var n, i, s, a = r(3),
            o = r(9),
            u = r(37),
            c = r(71),
            h = r(19),
            l = r(7),
            f = r(54),
            p = l("iterator"),
            d = !1;
        [].keys && ("next" in (s = [].keys()) ? (i = c(c(s))) !== Object.prototype && (n = i) : d = !0), null == n || a((function() {
            var t = {};
            return n[p].call(t) !== t
        })) ? n = {} : f && (n = u(n)), o(n[p]) || h(n, p, (function() {
            return this
        })), t.exports = {
            IteratorPrototype: n,
            BUGGY_SAFARI_ITERATORS: d
        }
    }, function(t, e, r) {
        var n = r(3);
        t.exports = !n((function() {
            function t() {}
            return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype
        }))
    }, function(t, e) {
        t.exports = {
            CSSRuleList: 0,
            CSSStyleDeclaration: 0,
            CSSValueList: 0,
            ClientRectList: 0,
            DOMRectList: 0,
            DOMStringList: 0,
            DOMTokenList: 1,
            DataTransferItemList: 0,
            FileList: 0,
            HTMLAllCollection: 0,
            HTMLCollection: 0,
            HTMLFormElement: 0,
            HTMLSelectElement: 0,
            MediaList: 0,
            MimeTypeArray: 0,
            NamedNodeMap: 0,
            NodeList: 1,
            PaintRequestList: 0,
            Plugin: 0,
            PluginArray: 0,
            SVGLengthList: 0,
            SVGNumberList: 0,
            SVGPathSegList: 0,
            SVGPointList: 0,
            SVGStringList: 0,
            SVGTransformList: 0,
            SourceBufferList: 0,
            StyleSheetList: 0,
            TextTrackCueList: 0,
            TextTrackList: 0,
            TouchList: 0
        }
    }, function(t, e, r) {
        var n = r(82)("span").classList,
            i = n && n.constructor && n.constructor.prototype;
        t.exports = i === Object.prototype ? void 0 : i
    }, function(t, e, r) {
        var n = r(7),
            i = r(37),
            s = r(16),
            a = n("unscopables"),
            o = Array.prototype;
        null == o[a] && s.f(o, a, {
            configurable: !0,
            value: i(null)
        }), t.exports = function(t) {
            o[a][t] = !0
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(0),
            s = r(96),
            a = r(97),
            o = s.ArrayBuffer;
        n({
            global: !0,
            forced: i.ArrayBuffer !== o
        }, {
            ArrayBuffer: o
        }), a("ArrayBuffer")
    }, function(t, e, r) {
        var n = r(0),
            i = r(26),
            s = r(33),
            a = n.RangeError;
        t.exports = function(t) {
            if (void 0 === t) return 0;
            var e = i(t),
                r = s(e);
            if (e !== r) throw a("Wrong length or index");
            return r
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(15),
            i = r(45),
            s = r(20);
        t.exports = function(t) {
            for (var e = n(this), r = s(e), a = arguments.length, o = i(a > 1 ? arguments[1] : void 0, r), u = a > 2 ? arguments[2] : void 0, c = void 0 === u ? r : i(u, r); c > o;) e[o++] = t;
            return e
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(216),
            s = n.RangeError;
        t.exports = function(t, e) {
            var r = i(t);
            if (r % e) throw s("Wrong offset");
            return r
        }
    }, function(t, e, r) {
        var n = r(36).match(/firefox\/(\d+)/i);
        t.exports = !!n && +n[1]
    }, function(t, e, r) {
        var n = r(36);
        t.exports = /MSIE|Trident/.test(n)
    }, function(t, e, r) {
        var n = r(36).match(/AppleWebKit\/(\d+)\./);
        t.exports = !!n && +n[1]
    }, function(t, e, r) {
        r(35)("Uint16", (function(t) {
            return function(e, r, n) {
                return t(this, e, r, n)
            }
        }))
    }, function(t, e, r) {
        r(35)("Uint32", (function(t) {
            return function(e, r, n) {
                return t(this, e, r, n)
            }
        }))
    }, function(t, e, r) {
        r(35)("Float64", (function(t) {
            return function(e, r, n) {
                return t(this, e, r, n)
            }
        }))
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(94), function() {
            var t = n,
                e = t.lib.Hasher,
                r = t.x64,
                i = r.Word,
                s = r.WordArray,
                a = t.algo;

            function o() {
                return i.create.apply(i, arguments)
            }
            var u = [o(1116352408, 3609767458), o(1899447441, 602891725), o(3049323471, 3964484399), o(3921009573, 2173295548), o(961987163, 4081628472), o(1508970993, 3053834265), o(2453635748, 2937671579), o(2870763221, 3664609560), o(3624381080, 2734883394), o(310598401, 1164996542), o(607225278, 1323610764), o(1426881987, 3590304994), o(1925078388, 4068182383), o(2162078206, 991336113), o(2614888103, 633803317), o(3248222580, 3479774868), o(3835390401, 2666613458), o(4022224774, 944711139), o(264347078, 2341262773), o(604807628, 2007800933), o(770255983, 1495990901), o(1249150122, 1856431235), o(1555081692, 3175218132), o(1996064986, 2198950837), o(2554220882, 3999719339), o(2821834349, 766784016), o(2952996808, 2566594879), o(3210313671, 3203337956), o(3336571891, 1034457026), o(3584528711, 2466948901), o(113926993, 3758326383), o(338241895, 168717936), o(666307205, 1188179964), o(773529912, 1546045734), o(1294757372, 1522805485), o(1396182291, 2643833823), o(1695183700, 2343527390), o(1986661051, 1014477480), o(2177026350, 1206759142), o(2456956037, 344077627), o(2730485921, 1290863460), o(2820302411, 3158454273), o(3259730800, 3505952657), o(3345764771, 106217008), o(3516065817, 3606008344), o(3600352804, 1432725776), o(4094571909, 1467031594), o(275423344, 851169720), o(430227734, 3100823752), o(506948616, 1363258195), o(659060556, 3750685593), o(883997877, 3785050280), o(958139571, 3318307427), o(1322822218, 3812723403), o(1537002063, 2003034995), o(1747873779, 3602036899), o(1955562222, 1575990012), o(2024104815, 1125592928), o(2227730452, 2716904306), o(2361852424, 442776044), o(2428436474, 593698344), o(2756734187, 3733110249), o(3204031479, 2999351573), o(3329325298, 3815920427), o(3391569614, 3928383900), o(3515267271, 566280711), o(3940187606, 3454069534), o(4118630271, 4000239992), o(116418474, 1914138554), o(174292421, 2731055270), o(289380356, 3203993006), o(460393269, 320620315), o(685471733, 587496836), o(852142971, 1086792851), o(1017036298, 365543100), o(1126000580, 2618297676), o(1288033470, 3409855158), o(1501505948, 4234509866), o(1607167915, 987167468), o(1816402316, 1246189591)],
                c = [];
            ! function() {
                for (var t = 0; t < 80; t++) c[t] = o()
            }();
            var h = a.SHA512 = e.extend({
                _doReset: function() {
                    this._hash = new s.init([new i.init(1779033703, 4089235720), new i.init(3144134277, 2227873595), new i.init(1013904242, 4271175723), new i.init(2773480762, 1595750129), new i.init(1359893119, 2917565137), new i.init(2600822924, 725511199), new i.init(528734635, 4215389547), new i.init(1541459225, 327033209)])
                },
                _doProcessBlock: function(t, e) {
                    for (var r = this._hash.words, n = r[0], i = r[1], s = r[2], a = r[3], o = r[4], h = r[5], l = r[6], f = r[7], p = n.high, d = n.low, g = i.high, y = i.low, v = s.high, m = s.low, E = a.high, S = a.low, b = o.high, C = o.low, A = h.high, w = h.low, T = l.high, x = l.low, I = f.high, B = f.low, F = p, R = d, D = g, N = y, _ = v, P = m, k = E, L = S, O = b, U = C, V = A, H = w, j = T, M = x, K = I, q = B, z = 0; z < 80; z++) {
                        var G, Y, W = c[z];
                        if (z < 16) Y = W.high = 0 | t[e + 2 * z], G = W.low = 0 | t[e + 2 * z + 1];
                        else {
                            var X = c[z - 15],
                                Q = X.high,
                                Z = X.low,
                                J = (Q >>> 1 | Z << 31) ^ (Q >>> 8 | Z << 24) ^ Q >>> 7,
                                $ = (Z >>> 1 | Q << 31) ^ (Z >>> 8 | Q << 24) ^ (Z >>> 7 | Q << 25),
                                tt = c[z - 2],
                                et = tt.high,
                                rt = tt.low,
                                nt = (et >>> 19 | rt << 13) ^ (et << 3 | rt >>> 29) ^ et >>> 6,
                                it = (rt >>> 19 | et << 13) ^ (rt << 3 | et >>> 29) ^ (rt >>> 6 | et << 26),
                                st = c[z - 7],
                                at = st.high,
                                ot = st.low,
                                ut = c[z - 16],
                                ct = ut.high,
                                ht = ut.low;
                            Y = (Y = (Y = J + at + ((G = $ + ot) >>> 0 < $ >>> 0 ? 1 : 0)) + nt + ((G += it) >>> 0 < it >>> 0 ? 1 : 0)) + ct + ((G += ht) >>> 0 < ht >>> 0 ? 1 : 0), W.high = Y, W.low = G
                        }
                        var lt, ft = O & V ^ ~O & j,
                            pt = U & H ^ ~U & M,
                            dt = F & D ^ F & _ ^ D & _,
                            gt = R & N ^ R & P ^ N & P,
                            yt = (F >>> 28 | R << 4) ^ (F << 30 | R >>> 2) ^ (F << 25 | R >>> 7),
                            vt = (R >>> 28 | F << 4) ^ (R << 30 | F >>> 2) ^ (R << 25 | F >>> 7),
                            mt = (O >>> 14 | U << 18) ^ (O >>> 18 | U << 14) ^ (O << 23 | U >>> 9),
                            Et = (U >>> 14 | O << 18) ^ (U >>> 18 | O << 14) ^ (U << 23 | O >>> 9),
                            St = u[z],
                            bt = St.high,
                            Ct = St.low,
                            At = K + mt + ((lt = q + Et) >>> 0 < q >>> 0 ? 1 : 0),
                            wt = vt + gt;
                        K = j, q = M, j = V, M = H, V = O, H = U, O = k + (At = (At = (At = At + ft + ((lt += pt) >>> 0 < pt >>> 0 ? 1 : 0)) + bt + ((lt += Ct) >>> 0 < Ct >>> 0 ? 1 : 0)) + Y + ((lt += G) >>> 0 < G >>> 0 ? 1 : 0)) + ((U = L + lt | 0) >>> 0 < L >>> 0 ? 1 : 0) | 0, k = _, L = P, _ = D, P = N, D = F, N = R, F = At + (yt + dt + (wt >>> 0 < vt >>> 0 ? 1 : 0)) + ((R = lt + wt | 0) >>> 0 < lt >>> 0 ? 1 : 0) | 0
                    }
                    d = n.low = d + R, n.high = p + F + (d >>> 0 < R >>> 0 ? 1 : 0), y = i.low = y + N, i.high = g + D + (y >>> 0 < N >>> 0 ? 1 : 0), m = s.low = m + P, s.high = v + _ + (m >>> 0 < P >>> 0 ? 1 : 0), S = a.low = S + L, a.high = E + k + (S >>> 0 < L >>> 0 ? 1 : 0), C = o.low = C + U, o.high = b + O + (C >>> 0 < U >>> 0 ? 1 : 0), w = h.low = w + H, h.high = A + V + (w >>> 0 < H >>> 0 ? 1 : 0), x = l.low = x + M, l.high = T + j + (x >>> 0 < M >>> 0 ? 1 : 0), B = f.low = B + q, f.high = I + K + (B >>> 0 < q >>> 0 ? 1 : 0)
                },
                _doFinalize: function() {
                    var t = this._data,
                        e = t.words,
                        r = 8 * this._nDataBytes,
                        n = 8 * t.sigBytes;
                    return e[n >>> 5] |= 128 << 24 - n % 32, e[30 + (n + 128 >>> 10 << 5)] = Math.floor(r / 4294967296), e[31 + (n + 128 >>> 10 << 5)] = r, t.sigBytes = 4 * e.length, this._process(), this._hash.toX32()
                },
                clone: function() {
                    var t = e.clone.call(this);
                    return t._hash = this._hash.clone(), t
                },
                blockSize: 32
            });
            t.SHA512 = e._createHelper(h), t.HmacSHA512 = e._createHmacHelper(h)
        }(), n.SHA512)
    }, function(t, e, r) {
        "use strict";
        (function(t, n, i, s) {
            var a, o, u, c;

            function h(t) {
                return (h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                })(t)
            }
            r(256), r(257), r(127), r(30), r(258), r(173), r(98), r(38), r(31), r(99), r(101), r(102), r(103), r(104), r(106), r(107), r(108), r(109), r(110), r(111), r(112), r(113), r(114), r(115), r(116), r(117), r(118), r(119), r(120), r(121), r(122), r(123), r(124), r(260), r(180), r(66), r(186), r(187), r(137), r(78), r(188), r(58), r(263), r(265), r(266), r(57), r(73), r(267), r(193), r(153), r(154), r(129), r(68), r(69), r(181), r(271), r(194), r(182), r(70), "undefined" != typeof self && self, c = function() {
                return function(t) {
                    var e = {};

                    function r(n) {
                        if (e[n]) return e[n].exports;
                        var i = e[n] = {
                            i: n,
                            l: !1,
                            exports: {}
                        };
                        return t[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports
                    }
                    return r.m = t, r.c = e, r.d = function(t, e, n) {
                        r.o(t, e) || Object.defineProperty(t, e, {
                            configurable: !1,
                            enumerable: !0,
                            get: n
                        })
                    }, r.n = function(t) {
                        var e = t && t.__esModule ? function() {
                            return t.default
                        } : function() {
                            return t
                        };
                        return r.d(e, "a", e), e
                    }, r.o = function(t, e) {
                        return Object.prototype.hasOwnProperty.call(t, e)
                    }, r.p = "", r(r.s = 34)
                }([function(t, e) {
                    t.exports = {
                        options: {
                            usePureJavaScript: !1
                        }
                    }
                }, function(e, r, s) {
                    (function(r) {
                        var a = s(0),
                            o = s(37),
                            u = e.exports = a.util = a.util || {};

                        function c(t) {
                            if (8 !== t && 16 !== t && 24 !== t && 32 !== t) throw new Error("Only 8, 16, 24, or 32 bits supported: " + t)
                        }

                        function l(t) {
                            if (this.data = "", this.read = 0, "string" == typeof t) this.data = t;
                            else if (u.isArrayBuffer(t) || u.isArrayBufferView(t))
                                if (void 0 !== i && t instanceof i) this.data = t.toString("binary");
                                else {
                                    var e = new Uint8Array(t);
                                    try {
                                        this.data = String.fromCharCode.apply(null, e)
                                    } catch (t) {
                                        for (var r = 0; r < e.length; ++r) this.putByte(e[r])
                                    }
                                }
                            else(t instanceof l || "object" === h(t) && "string" == typeof t.data && "number" == typeof t.read) && (this.data = t.data, this.read = t.read);
                            this._constructedStringLength = 0
                        }! function() {
                            if (void 0 !== t && t.nextTick && !t.browser) return u.nextTick = t.nextTick, void(u.setImmediate = "function" == typeof n ? n : u.nextTick);
                            if ("function" == typeof n) return u.setImmediate = function() {
                                return n.apply(void 0, arguments)
                            }, void(u.nextTick = function(t) {
                                return n(t)
                            });
                            if (u.setImmediate = function(t) {
                                    setTimeout(t, 0)
                                }, "undefined" != typeof window && "function" == typeof window.postMessage) {
                                var e = "forge.setImmediate",
                                    r = [];
                                u.setImmediate = function(t) {
                                    r.push(t), 1 === r.length && window.postMessage(e, "*")
                                }, window.addEventListener("message", (function(t) {
                                    if (t.source === window && t.data === e) {
                                        t.stopPropagation();
                                        var n = r.slice();
                                        r.length = 0, n.forEach((function(t) {
                                            t()
                                        }))
                                    }
                                }), !0)
                            }
                            if ("undefined" != typeof MutationObserver) {
                                var i = Date.now(),
                                    s = !0,
                                    a = document.createElement("div");
                                r = [], new MutationObserver((function() {
                                    var t = r.slice();
                                    r.length = 0, t.forEach((function(t) {
                                        t()
                                    }))
                                })).observe(a, {
                                    attributes: !0
                                });
                                var o = u.setImmediate;
                                u.setImmediate = function(t) {
                                    Date.now() - i > 15 ? (i = Date.now(), o(t)) : (r.push(t), 1 === r.length && a.setAttribute("a", s = !s))
                                }
                            }
                            u.nextTick = u.setImmediate
                        }(), u.isNodejs = void 0 !== t && t.versions && t.versions.node, u.globalScope = u.isNodejs ? r : "undefined" == typeof self ? window : self, u.isArray = Array.isArray || function(t) {
                            return "[object Array]" === Object.prototype.toString.call(t)
                        }, u.isArrayBuffer = function(t) {
                            return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer
                        }, u.isArrayBufferView = function(t) {
                            return t && u.isArrayBuffer(t.buffer) && void 0 !== t.byteLength
                        }, u.ByteBuffer = l, u.ByteStringBuffer = l, u.ByteStringBuffer.prototype._optimizeConstructedString = function(t) {
                            this._constructedStringLength += t, this._constructedStringLength > 4096 && (this.data.substr(0, 1), this._constructedStringLength = 0)
                        }, u.ByteStringBuffer.prototype.length = function() {
                            return this.data.length - this.read
                        }, u.ByteStringBuffer.prototype.isEmpty = function() {
                            return this.length() <= 0
                        }, u.ByteStringBuffer.prototype.putByte = function(t) {
                            return this.putBytes(String.fromCharCode(t))
                        }, u.ByteStringBuffer.prototype.fillWithByte = function(t, e) {
                            t = String.fromCharCode(t);
                            for (var r = this.data; e > 0;) 1 & e && (r += t), (e >>>= 1) > 0 && (t += t);
                            return this.data = r, this._optimizeConstructedString(e), this
                        }, u.ByteStringBuffer.prototype.putBytes = function(t) {
                            return this.data += t, this._optimizeConstructedString(t.length), this
                        }, u.ByteStringBuffer.prototype.putString = function(t) {
                            return this.putBytes(u.encodeUtf8(t))
                        }, u.ByteStringBuffer.prototype.putInt16 = function(t) {
                            return this.putBytes(String.fromCharCode(t >> 8 & 255) + String.fromCharCode(255 & t))
                        }, u.ByteStringBuffer.prototype.putInt24 = function(t) {
                            return this.putBytes(String.fromCharCode(t >> 16 & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(255 & t))
                        }, u.ByteStringBuffer.prototype.putInt32 = function(t) {
                            return this.putBytes(String.fromCharCode(t >> 24 & 255) + String.fromCharCode(t >> 16 & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(255 & t))
                        }, u.ByteStringBuffer.prototype.putInt16Le = function(t) {
                            return this.putBytes(String.fromCharCode(255 & t) + String.fromCharCode(t >> 8 & 255))
                        }, u.ByteStringBuffer.prototype.putInt24Le = function(t) {
                            return this.putBytes(String.fromCharCode(255 & t) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t >> 16 & 255))
                        }, u.ByteStringBuffer.prototype.putInt32Le = function(t) {
                            return this.putBytes(String.fromCharCode(255 & t) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t >> 16 & 255) + String.fromCharCode(t >> 24 & 255))
                        }, u.ByteStringBuffer.prototype.putInt = function(t, e) {
                            c(e);
                            var r = "";
                            do {
                                e -= 8, r += String.fromCharCode(t >> e & 255)
                            } while (e > 0);
                            return this.putBytes(r)
                        }, u.ByteStringBuffer.prototype.putSignedInt = function(t, e) {
                            return t < 0 && (t += 2 << e - 1), this.putInt(t, e)
                        }, u.ByteStringBuffer.prototype.putBuffer = function(t) {
                            return this.putBytes(t.getBytes())
                        }, u.ByteStringBuffer.prototype.getByte = function() {
                            return this.data.charCodeAt(this.read++)
                        }, u.ByteStringBuffer.prototype.getInt16 = function() {
                            var t = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
                            return this.read += 2, t
                        }, u.ByteStringBuffer.prototype.getInt24 = function() {
                            var t = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
                            return this.read += 3, t
                        }, u.ByteStringBuffer.prototype.getInt32 = function() {
                            var t = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
                            return this.read += 4, t
                        }, u.ByteStringBuffer.prototype.getInt16Le = function() {
                            var t = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
                            return this.read += 2, t
                        }, u.ByteStringBuffer.prototype.getInt24Le = function() {
                            var t = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
                            return this.read += 3, t
                        }, u.ByteStringBuffer.prototype.getInt32Le = function() {
                            var t = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
                            return this.read += 4, t
                        }, u.ByteStringBuffer.prototype.getInt = function(t) {
                            c(t);
                            var e = 0;
                            do {
                                e = (e << 8) + this.data.charCodeAt(this.read++), t -= 8
                            } while (t > 0);
                            return e
                        }, u.ByteStringBuffer.prototype.getSignedInt = function(t) {
                            var e = this.getInt(t),
                                r = 2 << t - 2;
                            return e >= r && (e -= r << 1), e
                        }, u.ByteStringBuffer.prototype.getBytes = function(t) {
                            var e;
                            return t ? (t = Math.min(this.length(), t), e = this.data.slice(this.read, this.read + t), this.read += t) : 0 === t ? e = "" : (e = 0 === this.read ? this.data : this.data.slice(this.read), this.clear()), e
                        }, u.ByteStringBuffer.prototype.bytes = function(t) {
                            return void 0 === t ? this.data.slice(this.read) : this.data.slice(this.read, this.read + t)
                        }, u.ByteStringBuffer.prototype.at = function(t) {
                            return this.data.charCodeAt(this.read + t)
                        }, u.ByteStringBuffer.prototype.setAt = function(t, e) {
                            return this.data = this.data.substr(0, this.read + t) + String.fromCharCode(e) + this.data.substr(this.read + t + 1), this
                        }, u.ByteStringBuffer.prototype.last = function() {
                            return this.data.charCodeAt(this.data.length - 1)
                        }, u.ByteStringBuffer.prototype.copy = function() {
                            var t = u.createBuffer(this.data);
                            return t.read = this.read, t
                        }, u.ByteStringBuffer.prototype.compact = function() {
                            return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this
                        }, u.ByteStringBuffer.prototype.clear = function() {
                            return this.data = "", this.read = 0, this
                        }, u.ByteStringBuffer.prototype.truncate = function(t) {
                            var e = Math.max(0, this.length() - t);
                            return this.data = this.data.substr(this.read, e), this.read = 0, this
                        }, u.ByteStringBuffer.prototype.toHex = function() {
                            for (var t = "", e = this.read; e < this.data.length; ++e) {
                                var r = this.data.charCodeAt(e);
                                r < 16 && (t += "0"), t += r.toString(16)
                            }
                            return t
                        }, u.ByteStringBuffer.prototype.toString = function() {
                            return u.decodeUtf8(this.bytes())
                        }, u.DataBuffer = function(t, e) {
                            e = e || {}, this.read = e.readOffset || 0, this.growSize = e.growSize || 1024;
                            var r = u.isArrayBuffer(t),
                                n = u.isArrayBufferView(t);
                            if (r || n) return this.data = r ? new DataView(t) : new DataView(t.buffer, t.byteOffset, t.byteLength), void(this.write = "writeOffset" in e ? e.writeOffset : this.data.byteLength);
                            this.data = new DataView(new ArrayBuffer(0)), this.write = 0, null != t && this.putBytes(t), "writeOffset" in e && (this.write = e.writeOffset)
                        }, u.DataBuffer.prototype.length = function() {
                            return this.write - this.read
                        }, u.DataBuffer.prototype.isEmpty = function() {
                            return this.length() <= 0
                        }, u.DataBuffer.prototype.accommodate = function(t, e) {
                            if (this.length() >= t) return this;
                            e = Math.max(e || this.growSize, t);
                            var r = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength),
                                n = new Uint8Array(this.length() + e);
                            return n.set(r), this.data = new DataView(n.buffer), this
                        }, u.DataBuffer.prototype.putByte = function(t) {
                            return this.accommodate(1), this.data.setUint8(this.write++, t), this
                        }, u.DataBuffer.prototype.fillWithByte = function(t, e) {
                            this.accommodate(e);
                            for (var r = 0; r < e; ++r) this.data.setUint8(t);
                            return this
                        }, u.DataBuffer.prototype.putBytes = function(t, e) {
                            if (u.isArrayBufferView(t)) {
                                var r = (n = new Uint8Array(t.buffer, t.byteOffset, t.byteLength)).byteLength - n.byteOffset;
                                return this.accommodate(r), new Uint8Array(this.data.buffer, this.write).set(n), this.write += r, this
                            }
                            if (u.isArrayBuffer(t)) {
                                var n = new Uint8Array(t);
                                return this.accommodate(n.byteLength), new Uint8Array(this.data.buffer).set(n, this.write), this.write += n.byteLength, this
                            }
                            if (t instanceof u.DataBuffer || "object" === h(t) && "number" == typeof t.read && "number" == typeof t.write && u.isArrayBufferView(t.data)) return n = new Uint8Array(t.data.byteLength, t.read, t.length()), this.accommodate(n.byteLength), new Uint8Array(t.data.byteLength, this.write).set(n), this.write += n.byteLength, this;
                            if (t instanceof u.ByteStringBuffer && (t = t.data, e = "binary"), e = e || "binary", "string" == typeof t) {
                                var i;
                                if ("hex" === e) return this.accommodate(Math.ceil(t.length / 2)), i = new Uint8Array(this.data.buffer, this.write), this.write += u.binary.hex.decode(t, i, this.write), this;
                                if ("base64" === e) return this.accommodate(3 * Math.ceil(t.length / 4)), i = new Uint8Array(this.data.buffer, this.write), this.write += u.binary.base64.decode(t, i, this.write), this;
                                if ("utf8" === e && (t = u.encodeUtf8(t), e = "binary"), "binary" === e || "raw" === e) return this.accommodate(t.length), i = new Uint8Array(this.data.buffer, this.write), this.write += u.binary.raw.decode(i), this;
                                if ("utf16" === e) return this.accommodate(2 * t.length), i = new Uint16Array(this.data.buffer, this.write), this.write += u.text.utf16.encode(i), this;
                                throw new Error("Invalid encoding: " + e)
                            }
                            throw Error("Invalid parameter: " + t)
                        }, u.DataBuffer.prototype.putBuffer = function(t) {
                            return this.putBytes(t), t.clear(), this
                        }, u.DataBuffer.prototype.putString = function(t) {
                            return this.putBytes(t, "utf16")
                        }, u.DataBuffer.prototype.putInt16 = function(t) {
                            return this.accommodate(2), this.data.setInt16(this.write, t), this.write += 2, this
                        }, u.DataBuffer.prototype.putInt24 = function(t) {
                            return this.accommodate(3), this.data.setInt16(this.write, t >> 8 & 65535), this.data.setInt8(this.write, t >> 16 & 255), this.write += 3, this
                        }, u.DataBuffer.prototype.putInt32 = function(t) {
                            return this.accommodate(4), this.data.setInt32(this.write, t), this.write += 4, this
                        }, u.DataBuffer.prototype.putInt16Le = function(t) {
                            return this.accommodate(2), this.data.setInt16(this.write, t, !0), this.write += 2, this
                        }, u.DataBuffer.prototype.putInt24Le = function(t) {
                            return this.accommodate(3), this.data.setInt8(this.write, t >> 16 & 255), this.data.setInt16(this.write, t >> 8 & 65535, !0), this.write += 3, this
                        }, u.DataBuffer.prototype.putInt32Le = function(t) {
                            return this.accommodate(4), this.data.setInt32(this.write, t, !0), this.write += 4, this
                        }, u.DataBuffer.prototype.putInt = function(t, e) {
                            c(e), this.accommodate(e / 8);
                            do {
                                e -= 8, this.data.setInt8(this.write++, t >> e & 255)
                            } while (e > 0);
                            return this
                        }, u.DataBuffer.prototype.putSignedInt = function(t, e) {
                            return c(e), this.accommodate(e / 8), t < 0 && (t += 2 << e - 1), this.putInt(t, e)
                        }, u.DataBuffer.prototype.getByte = function() {
                            return this.data.getInt8(this.read++)
                        }, u.DataBuffer.prototype.getInt16 = function() {
                            var t = this.data.getInt16(this.read);
                            return this.read += 2, t
                        }, u.DataBuffer.prototype.getInt24 = function() {
                            var t = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
                            return this.read += 3, t
                        }, u.DataBuffer.prototype.getInt32 = function() {
                            var t = this.data.getInt32(this.read);
                            return this.read += 4, t
                        }, u.DataBuffer.prototype.getInt16Le = function() {
                            var t = this.data.getInt16(this.read, !0);
                            return this.read += 2, t
                        }, u.DataBuffer.prototype.getInt24Le = function() {
                            var t = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, !0) << 8;
                            return this.read += 3, t
                        }, u.DataBuffer.prototype.getInt32Le = function() {
                            var t = this.data.getInt32(this.read, !0);
                            return this.read += 4, t
                        }, u.DataBuffer.prototype.getInt = function(t) {
                            c(t);
                            var e = 0;
                            do {
                                e = (e << 8) + this.data.getInt8(this.read++), t -= 8
                            } while (t > 0);
                            return e
                        }, u.DataBuffer.prototype.getSignedInt = function(t) {
                            var e = this.getInt(t),
                                r = 2 << t - 2;
                            return e >= r && (e -= r << 1), e
                        }, u.DataBuffer.prototype.getBytes = function(t) {
                            var e;
                            return t ? (t = Math.min(this.length(), t), e = this.data.slice(this.read, this.read + t), this.read += t) : 0 === t ? e = "" : (e = 0 === this.read ? this.data : this.data.slice(this.read), this.clear()), e
                        }, u.DataBuffer.prototype.bytes = function(t) {
                            return void 0 === t ? this.data.slice(this.read) : this.data.slice(this.read, this.read + t)
                        }, u.DataBuffer.prototype.at = function(t) {
                            return this.data.getUint8(this.read + t)
                        }, u.DataBuffer.prototype.setAt = function(t, e) {
                            return this.data.setUint8(t, e), this
                        }, u.DataBuffer.prototype.last = function() {
                            return this.data.getUint8(this.write - 1)
                        }, u.DataBuffer.prototype.copy = function() {
                            return new u.DataBuffer(this)
                        }, u.DataBuffer.prototype.compact = function() {
                            if (this.read > 0) {
                                var t = new Uint8Array(this.data.buffer, this.read),
                                    e = new Uint8Array(t.byteLength);
                                e.set(t), this.data = new DataView(e), this.write -= this.read, this.read = 0
                            }
                            return this
                        }, u.DataBuffer.prototype.clear = function() {
                            return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this
                        }, u.DataBuffer.prototype.truncate = function(t) {
                            return this.write = Math.max(0, this.length() - t), this.read = Math.min(this.read, this.write), this
                        }, u.DataBuffer.prototype.toHex = function() {
                            for (var t = "", e = this.read; e < this.data.byteLength; ++e) {
                                var r = this.data.getUint8(e);
                                r < 16 && (t += "0"), t += r.toString(16)
                            }
                            return t
                        }, u.DataBuffer.prototype.toString = function(t) {
                            var e = new Uint8Array(this.data, this.read, this.length());
                            if ("binary" === (t = t || "utf8") || "raw" === t) return u.binary.raw.encode(e);
                            if ("hex" === t) return u.binary.hex.encode(e);
                            if ("base64" === t) return u.binary.base64.encode(e);
                            if ("utf8" === t) return u.text.utf8.decode(e);
                            if ("utf16" === t) return u.text.utf16.decode(e);
                            throw new Error("Invalid encoding: " + t)
                        }, u.createBuffer = function(t, e) {
                            return e = e || "raw", void 0 !== t && "utf8" === e && (t = u.encodeUtf8(t)), new u.ByteBuffer(t)
                        }, u.fillString = function(t, e) {
                            for (var r = ""; e > 0;) 1 & e && (r += t), (e >>>= 1) > 0 && (t += t);
                            return r
                        }, u.xorBytes = function(t, e, r) {
                            for (var n = "", i = "", s = "", a = 0, o = 0; r > 0; --r, ++a) i = t.charCodeAt(a) ^ e.charCodeAt(a), o >= 10 && (n += s, s = "", o = 0), s += String.fromCharCode(i), ++o;
                            return n += s
                        }, u.hexToBytes = function(t) {
                            var e = "",
                                r = 0;
                            for (!0 & t.length && (r = 1, e += String.fromCharCode(parseInt(t[0], 16))); r < t.length; r += 2) e += String.fromCharCode(parseInt(t.substr(r, 2), 16));
                            return e
                        }, u.bytesToHex = function(t) {
                            return u.createBuffer(t).toHex()
                        }, u.int32ToBytes = function(t) {
                            return String.fromCharCode(t >> 24 & 255) + String.fromCharCode(t >> 16 & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(255 & t)
                        };
                        var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                            p = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51],
                            d = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
                        u.encode64 = function(t, e) {
                            for (var r, n, i, s = "", a = "", o = 0; o < t.length;) r = t.charCodeAt(o++), n = t.charCodeAt(o++), i = t.charCodeAt(o++), s += f.charAt(r >> 2), s += f.charAt((3 & r) << 4 | n >> 4), isNaN(n) ? s += "==" : (s += f.charAt((15 & n) << 2 | i >> 6), s += isNaN(i) ? "=" : f.charAt(63 & i)), e && s.length > e && (a += s.substr(0, e) + "\r\n", s = s.substr(e));
                            return a += s
                        }, u.decode64 = function(t) {
                            t = t.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                            for (var e, r, n, i, s = "", a = 0; a < t.length;) e = p[t.charCodeAt(a++) - 43], r = p[t.charCodeAt(a++) - 43], n = p[t.charCodeAt(a++) - 43], i = p[t.charCodeAt(a++) - 43], s += String.fromCharCode(e << 2 | r >> 4), 64 !== n && (s += String.fromCharCode((15 & r) << 4 | n >> 2), 64 !== i && (s += String.fromCharCode((3 & n) << 6 | i)));
                            return s
                        }, u.encodeUtf8 = function(t) {
                            return unescape(encodeURIComponent(t))
                        }, u.decodeUtf8 = function(t) {
                            return decodeURIComponent(escape(t))
                        }, u.binary = {
                            raw: {},
                            hex: {},
                            base64: {},
                            base58: {},
                            baseN: {
                                encode: o.encode,
                                decode: o.decode
                            }
                        }, u.binary.raw.encode = function(t) {
                            return String.fromCharCode.apply(null, t)
                        }, u.binary.raw.decode = function(t, e, r) {
                            var n = e;
                            n || (n = new Uint8Array(t.length));
                            for (var i = r = r || 0, s = 0; s < t.length; ++s) n[i++] = t.charCodeAt(s);
                            return e ? i - r : n
                        }, u.binary.hex.encode = u.bytesToHex, u.binary.hex.decode = function(t, e, r) {
                            var n = e;
                            n || (n = new Uint8Array(Math.ceil(t.length / 2)));
                            var i = 0,
                                s = r = r || 0;
                            for (1 & t.length && (i = 1, n[s++] = parseInt(t[0], 16)); i < t.length; i += 2) n[s++] = parseInt(t.substr(i, 2), 16);
                            return e ? s - r : n
                        }, u.binary.base64.encode = function(t, e) {
                            for (var r, n, i, s = "", a = "", o = 0; o < t.byteLength;) r = t[o++], n = t[o++], i = t[o++], s += f.charAt(r >> 2), s += f.charAt((3 & r) << 4 | n >> 4), isNaN(n) ? s += "==" : (s += f.charAt((15 & n) << 2 | i >> 6), s += isNaN(i) ? "=" : f.charAt(63 & i)), e && s.length > e && (a += s.substr(0, e) + "\r\n", s = s.substr(e));
                            return a += s
                        }, u.binary.base64.decode = function(t, e, r) {
                            var n, i, s, a, o = e;
                            o || (o = new Uint8Array(3 * Math.ceil(t.length / 4))), t = t.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                            for (var u = 0, c = r = r || 0; u < t.length;) n = p[t.charCodeAt(u++) - 43], i = p[t.charCodeAt(u++) - 43], s = p[t.charCodeAt(u++) - 43], a = p[t.charCodeAt(u++) - 43], o[c++] = n << 2 | i >> 4, 64 !== s && (o[c++] = (15 & i) << 4 | s >> 2, 64 !== a && (o[c++] = (3 & s) << 6 | a));
                            return e ? c - r : o.subarray(0, c)
                        }, u.binary.base58.encode = function(t, e) {
                            return u.binary.baseN.encode(t, d, e)
                        }, u.binary.base58.decode = function(t, e) {
                            return u.binary.baseN.decode(t, d, e)
                        }, u.text = {
                            utf8: {},
                            utf16: {}
                        }, u.text.utf8.encode = function(t, e, r) {
                            t = u.encodeUtf8(t);
                            var n = e;
                            n || (n = new Uint8Array(t.length));
                            for (var i = r = r || 0, s = 0; s < t.length; ++s) n[i++] = t.charCodeAt(s);
                            return e ? i - r : n
                        }, u.text.utf8.decode = function(t) {
                            return u.decodeUtf8(String.fromCharCode.apply(null, t))
                        }, u.text.utf16.encode = function(t, e, r) {
                            var n = e;
                            n || (n = new Uint8Array(2 * t.length));
                            for (var i = new Uint16Array(n.buffer), s = r = r || 0, a = r, o = 0; o < t.length; ++o) i[a++] = t.charCodeAt(o), s += 2;
                            return e ? s - r : n
                        }, u.text.utf16.decode = function(t) {
                            return String.fromCharCode.apply(null, new Uint16Array(t.buffer))
                        }, u.deflate = function(t, e, r) {
                            if (e = u.decode64(t.deflate(u.encode64(e)).rval), r) {
                                var n = 2;
                                32 & e.charCodeAt(1) && (n = 6), e = e.substring(n, e.length - 4)
                            }
                            return e
                        }, u.inflate = function(t, e, r) {
                            var n = t.inflate(u.encode64(e)).rval;
                            return null === n ? null : u.decode64(n)
                        };
                        var g = function(t, e, r) {
                                if (!t) throw new Error("WebStorage not available.");
                                var n;
                                if (null === r ? n = t.removeItem(e) : (r = u.encode64(JSON.stringify(r)), n = t.setItem(e, r)), void 0 !== n && !0 !== n.rval) {
                                    var i = new Error(n.error.message);
                                    throw i.id = n.error.id, i.name = n.error.name, i
                                }
                            },
                            y = function(t, e) {
                                if (!t) throw new Error("WebStorage not available.");
                                var r = t.getItem(e);
                                if (t.init)
                                    if (null === r.rval) {
                                        if (r.error) {
                                            var n = new Error(r.error.message);
                                            throw n.id = r.error.id, n.name = r.error.name, n
                                        }
                                        r = null
                                    } else r = r.rval;
                                return null !== r && (r = JSON.parse(u.decode64(r))), r
                            },
                            v = function(t, e, r, n) {
                                var i = y(t, e);
                                null === i && (i = {}), i[r] = n, g(t, e, i)
                            },
                            m = function(t, e, r) {
                                var n = y(t, e);
                                return null !== n && (n = r in n ? n[r] : null), n
                            },
                            E = function(t, e, r) {
                                var n = y(t, e);
                                if (null !== n && r in n) {
                                    delete n[r];
                                    var i = !0;
                                    for (var s in n) {
                                        i = !1;
                                        break
                                    }
                                    i && (n = null), g(t, e, n)
                                }
                            },
                            S = function(t, e) {
                                g(t, e, null)
                            },
                            b = function(t, e, r) {
                                var n, i = null;
                                void 0 === r && (r = ["web", "flash"]);
                                var s = !1,
                                    a = null;
                                for (var o in r) {
                                    n = r[o];
                                    try {
                                        if ("flash" === n || "both" === n) {
                                            if (null === e[0]) throw new Error("Flash local storage not available.");
                                            i = t.apply(this, e), s = "flash" === n
                                        }
                                        "web" !== n && "both" !== n || (e[0] = localStorage, i = t.apply(this, e), s = !0)
                                    } catch (t) {
                                        a = t
                                    }
                                    if (s) break
                                }
                                if (!s) throw a;
                                return i
                            };
                        u.setItem = function(t, e, r, n, i) {
                            b(v, arguments, i)
                        }, u.getItem = function(t, e, r, n) {
                            return b(m, arguments, n)
                        }, u.removeItem = function(t, e, r, n) {
                            b(E, arguments, n)
                        }, u.clearItems = function(t, e, r) {
                            b(S, arguments, r)
                        }, u.parseUrl = function(t) {
                            var e = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
                            e.lastIndex = 0;
                            var r = e.exec(t),
                                n = null === r ? null : {
                                    full: t,
                                    scheme: r[1],
                                    host: r[2],
                                    port: r[3],
                                    path: r[4]
                                };
                            return n && (n.fullHost = n.host, n.port ? (80 !== n.port && "http" === n.scheme || 443 !== n.port && "https" === n.scheme) && (n.fullHost += ":" + n.port) : "http" === n.scheme ? n.port = 80 : "https" === n.scheme && (n.port = 443), n.full = n.scheme + "://" + n.fullHost), n
                        };
                        var C = null;
                        u.getQueryVariables = function(t) {
                            var e, r = function(t) {
                                for (var e = {}, r = t.split("&"), n = 0; n < r.length; n++) {
                                    var i, s, a = r[n].indexOf("=");
                                    a > 0 ? (i = r[n].substring(0, a), s = r[n].substring(a + 1)) : (i = r[n], s = null), i in e || (e[i] = []), i in Object.prototype || null === s || e[i].push(unescape(s))
                                }
                                return e
                            };
                            return void 0 === t ? (null === C && (C = "undefined" != typeof window && window.location && window.location.search ? r(window.location.search.substring(1)) : {}), e = C) : e = r(t), e
                        }, u.parseFragment = function(t) {
                            var e = t,
                                r = "",
                                n = t.indexOf("?");
                            n > 0 && (e = t.substring(0, n), r = t.substring(n + 1));
                            var i = e.split("/");
                            return i.length > 0 && "" === i[0] && i.shift(), {
                                pathString: e,
                                queryString: r,
                                path: i,
                                query: "" === r ? {} : u.getQueryVariables(r)
                            }
                        }, u.makeRequest = function(t) {
                            var e = u.parseFragment(t),
                                r = {
                                    path: e.pathString,
                                    query: e.queryString,
                                    getPath: function(t) {
                                        return void 0 === t ? e.path : e.path[t]
                                    },
                                    getQuery: function(t, r) {
                                        var n;
                                        return void 0 === t ? n = e.query : (n = e.query[t]) && void 0 !== r && (n = n[r]), n
                                    },
                                    getQueryLast: function(t, e) {
                                        var n = r.getQuery(t);
                                        return n ? n[n.length - 1] : e
                                    }
                                };
                            return r
                        }, u.makeLink = function(t, e, r) {
                            t = jQuery.isArray(t) ? t.join("/") : t;
                            var n = jQuery.param(e || {});
                            return r = r || "", t + (n.length > 0 ? "?" + n : "") + (r.length > 0 ? "#" + r : "")
                        }, u.setPath = function(t, e, r) {
                            if ("object" === h(t) && null !== t)
                                for (var n = 0, i = e.length; n < i;) {
                                    var s = e[n++];
                                    if (n == i) t[s] = r;
                                    else {
                                        var a = s in t;
                                        (!a || a && "object" !== h(t[s]) || a && null === t[s]) && (t[s] = {}), t = t[s]
                                    }
                                }
                        }, u.getPath = function(t, e, r) {
                            for (var n = 0, i = e.length, s = !0; s && n < i && "object" === h(t) && null !== t;) {
                                var a = e[n++];
                                (s = a in t) && (t = t[a])
                            }
                            return s ? t : r
                        }, u.deletePath = function(t, e) {
                            if ("object" === h(t) && null !== t)
                                for (var r = 0, n = e.length; r < n;) {
                                    var i = e[r++];
                                    if (r == n) delete t[i];
                                    else {
                                        if (!(i in t) || "object" !== h(t[i]) || null === t[i]) break;
                                        t = t[i]
                                    }
                                }
                        }, u.isEmpty = function(t) {
                            for (var e in t)
                                if (t.hasOwnProperty(e)) return !1;
                            return !0
                        }, u.format = function(t) {
                            for (var e, r, n = /%./g, i = 0, s = [], a = 0; e = n.exec(t);) {
                                (r = t.substring(a, n.lastIndex - 2)).length > 0 && s.push(r), a = n.lastIndex;
                                var o = e[0][1];
                                switch (o) {
                                    case "s":
                                    case "o":
                                        i < arguments.length ? s.push(arguments[1 + i++]) : s.push("<?>");
                                        break;
                                    case "%":
                                        s.push("%");
                                        break;
                                    default:
                                        s.push("<%" + o + "?>")
                                }
                            }
                            return s.push(t.substring(a)), s.join("")
                        }, u.formatNumber = function(t, e, r, n) {
                            var i = t,
                                s = isNaN(e = Math.abs(e)) ? 2 : e,
                                a = void 0 === r ? "," : r,
                                o = void 0 === n ? "." : n,
                                u = i < 0 ? "-" : "",
                                c = parseInt(i = Math.abs(+i || 0).toFixed(s), 10) + "",
                                h = c.length > 3 ? c.length % 3 : 0;
                            return u + (h ? c.substr(0, h) + o : "") + c.substr(h).replace(/(\d{3})(?=\d)/g, "$1" + o) + (s ? a + Math.abs(i - c).toFixed(s).slice(2) : "")
                        }, u.formatSize = function(t) {
                            return t = t >= 1073741824 ? u.formatNumber(t / 1073741824, 2, ".", "") + " GiB" : t >= 1048576 ? u.formatNumber(t / 1048576, 2, ".", "") + " MiB" : t >= 1024 ? u.formatNumber(t / 1024, 0) + " KiB" : u.formatNumber(t, 0) + " bytes"
                        }, u.bytesFromIP = function(t) {
                            return -1 !== t.indexOf(".") ? u.bytesFromIPv4(t) : -1 !== t.indexOf(":") ? u.bytesFromIPv6(t) : null
                        }, u.bytesFromIPv4 = function(t) {
                            if (4 !== (t = t.split(".")).length) return null;
                            for (var e = u.createBuffer(), r = 0; r < t.length; ++r) {
                                var n = parseInt(t[r], 10);
                                if (isNaN(n)) return null;
                                e.putByte(n)
                            }
                            return e.getBytes()
                        }, u.bytesFromIPv6 = function(t) {
                            for (var e = 0, r = 2 * (8 - (t = t.split(":").filter((function(t) {
                                    return 0 === t.length && ++e, !0
                                }))).length + e), n = u.createBuffer(), i = 0; i < 8; ++i)
                                if (t[i] && 0 !== t[i].length) {
                                    var s = u.hexToBytes(t[i]);
                                    s.length < 2 && n.putByte(0), n.putBytes(s)
                                } else n.fillWithByte(0, r), r = 0;
                            return n.getBytes()
                        }, u.bytesToIP = function(t) {
                            return 4 === t.length ? u.bytesToIPv4(t) : 16 === t.length ? u.bytesToIPv6(t) : null
                        }, u.bytesToIPv4 = function(t) {
                            if (4 !== t.length) return null;
                            for (var e = [], r = 0; r < t.length; ++r) e.push(t.charCodeAt(r));
                            return e.join(".")
                        }, u.bytesToIPv6 = function(t) {
                            if (16 !== t.length) return null;
                            for (var e = [], r = [], n = 0, i = 0; i < t.length; i += 2) {
                                for (var s = u.bytesToHex(t[i] + t[i + 1]);
                                    "0" === s[0] && "0" !== s;) s = s.substr(1);
                                if ("0" === s) {
                                    var a = r[r.length - 1],
                                        o = e.length;
                                    a && o === a.end + 1 ? (a.end = o, a.end - a.start > r[n].end - r[n].start && (n = r.length - 1)) : r.push({
                                        start: o,
                                        end: o
                                    })
                                }
                                e.push(s)
                            }
                            if (r.length > 0) {
                                var c = r[n];
                                c.end - c.start > 0 && (e.splice(c.start, c.end - c.start + 1, ""), 0 === c.start && e.unshift(""), 7 === c.end && e.push(""))
                            }
                            return e.join(":")
                        }, u.estimateCores = function(t, e) {
                            if ("function" == typeof t && (e = t, t = {}), t = t || {}, "cores" in u && !t.update) return e(null, u.cores);
                            if ("undefined" != typeof navigator && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) return u.cores = navigator.hardwareConcurrency, e(null, u.cores);
                            if ("undefined" == typeof Worker) return u.cores = 1, e(null, u.cores);
                            if ("undefined" == typeof Blob) return u.cores = 2, e(null, u.cores);
                            var r = URL.createObjectURL(new Blob(["(", function() {
                                self.addEventListener("message", (function(t) {
                                    for (var e = Date.now(), r = e + 4; Date.now() < r;);
                                    self.postMessage({
                                        st: e,
                                        et: r
                                    })
                                }))
                            }.toString(), ")()"], {
                                type: "application/javascript"
                            }));
                            ! function t(n, i, s) {
                                if (0 === i) {
                                    var a = Math.floor(n.reduce((function(t, e) {
                                        return t + e
                                    }), 0) / n.length);
                                    return u.cores = Math.max(1, a), URL.revokeObjectURL(r), e(null, u.cores)
                                }! function(t, e) {
                                    for (var n = [], i = [], s = 0; s < t; ++s) {
                                        var a = new Worker(r);
                                        a.addEventListener("message", (function(r) {
                                            if (i.push(r.data), i.length === t) {
                                                for (var s = 0; s < t; ++s) n[s].terminate();
                                                e(null, i)
                                            }
                                        })), n.push(a)
                                    }
                                    for (s = 0; s < t; ++s) n[s].postMessage(s)
                                }(s, (function(e, r) {
                                    n.push(function(t, e) {
                                        for (var r = [], n = 0; n < t; ++n)
                                            for (var i = e[n], s = r[n] = [], a = 0; a < t; ++a)
                                                if (n !== a) {
                                                    var o = e[a];
                                                    (i.st > o.st && i.st < o.et || o.st > i.st && o.st < i.et) && s.push(a)
                                                }
                                        return r.reduce((function(t, e) {
                                            return Math.max(t, e.length)
                                        }), 0)
                                    }(s, r)), t(n, i - 1, s)
                                }))
                            }([], 5, 16)
                        }
                    }).call(r, s(36))
                }, function(t, e, r) {
                    var n = r(0);
                    r(5), r(23), r(24), r(1), n.random && n.random.getBytes ? t.exports = n.random : function(e) {
                        var r = {},
                            i = new Array(4),
                            s = n.util.createBuffer();

                        function a() {
                            var t = n.prng.create(r);
                            return t.getBytes = function(e, r) {
                                return t.generate(e, r)
                            }, t.getBytesSync = function(e) {
                                return t.generate(e)
                            }, t
                        }
                        r.formatKey = function(t) {
                            var e = n.util.createBuffer(t);
                            return (t = new Array(4))[0] = e.getInt32(), t[1] = e.getInt32(), t[2] = e.getInt32(), t[3] = e.getInt32(), n.aes._expandKey(t, !1)
                        }, r.formatSeed = function(t) {
                            var e = n.util.createBuffer(t);
                            return (t = new Array(4))[0] = e.getInt32(), t[1] = e.getInt32(), t[2] = e.getInt32(), t[3] = e.getInt32(), t
                        }, r.cipher = function(t, e) {
                            return n.aes._updateBlock(t, e, i, !1), s.putInt32(i[0]), s.putInt32(i[1]), s.putInt32(i[2]), s.putInt32(i[3]), s.getBytes()
                        }, r.increment = function(t) {
                            return ++t[3], t
                        }, r.md = n.md.sha256;
                        var o = a(),
                            u = null,
                            c = n.util.globalScope;
                        if (c) {
                            var h = c.crypto || c.msCrypto;
                            h && h.getRandomValues && (u = function(t) {
                                return h.getRandomValues(t)
                            })
                        } else u = function(t) {
                            return InfosecGetRandomValues(t)
                        };
                        if (n.options.usePureJavaScript || !n.util.isNodejs && !u) {
                            if ("undefined" == typeof window || window.document, o.collectInt(+new Date, 32), "undefined" != typeof navigator) {
                                var l = "";
                                for (var f in navigator) try {
                                    "string" == typeof navigator[f] && (l += navigator[f])
                                } catch (t) {}
                                o.collect(l), l = null
                            }
                            e && (e().mousemove((function(t) {
                                o.collectInt(t.clientX, 16), o.collectInt(t.clientY, 16)
                            })), e().keypress((function(t) {
                                o.collectInt(t.charCode, 8)
                            })))
                        }
                        if (n.random)
                            for (var f in o) n.random[f] = o[f];
                        else n.random = o;
                        n.random.createInstance = a, t.exports = n.random
                    }("undefined" != typeof jQuery ? jQuery : null)
                }, function(t, e, r) {
                    var n = r(0);
                    r(1), r(6);
                    var i = t.exports = n.asn1 = n.asn1 || {};

                    function s(t, e, r) {
                        if (r > e) {
                            var n = new Error("Too few bytes to parse DER.");
                            throw n.available = t.length(), n.remaining = e, n.requested = r, n
                        }
                    }
                    i.Class = {
                        UNIVERSAL: 0,
                        APPLICATION: 64,
                        CONTEXT_SPECIFIC: 128,
                        PRIVATE: 192
                    }, i.Type = {
                        NONE: 0,
                        BOOLEAN: 1,
                        INTEGER: 2,
                        BITSTRING: 3,
                        OCTETSTRING: 4,
                        NULL: 5,
                        OID: 6,
                        ODESC: 7,
                        EXTERNAL: 8,
                        REAL: 9,
                        ENUMERATED: 10,
                        EMBEDDED: 11,
                        UTF8: 12,
                        ROID: 13,
                        SEQUENCE: 16,
                        SET: 17,
                        PRINTABLESTRING: 19,
                        IA5STRING: 22,
                        UTCTIME: 23,
                        GENERALIZEDTIME: 24,
                        BMPSTRING: 30
                    }, i.create = function(t, e, r, s, a) {
                        if (n.util.isArray(s)) {
                            for (var o = [], u = 0; u < s.length; ++u) void 0 !== s[u] && o.push(s[u]);
                            s = o
                        }
                        var c = {
                            tagClass: t,
                            type: e,
                            constructed: r,
                            composed: r || n.util.isArray(s),
                            value: s
                        };
                        return a && "bitStringContents" in a && (c.bitStringContents = a.bitStringContents, c.original = i.copy(c)), c
                    }, i.copy = function(t, e) {
                        var r;
                        if (n.util.isArray(t)) {
                            r = [];
                            for (var s = 0; s < t.length; ++s) r.push(i.copy(t[s], e));
                            return r
                        }
                        return "string" == typeof t ? t : (r = {
                            tagClass: t.tagClass,
                            type: t.type,
                            constructed: t.constructed,
                            composed: t.composed,
                            value: i.copy(t.value, e)
                        }, e && !e.excludeBitStringContents && (r.bitStringContents = t.bitStringContents), r)
                    }, i.equals = function(t, e, r) {
                        if (n.util.isArray(t)) {
                            if (!n.util.isArray(e)) return !1;
                            if (t.length !== e.length) return !1;
                            for (var s = 0; s < t.length; ++s)
                                if (!i.equals(t[s], e[s])) return !1;
                            return !0
                        }
                        if (h(t) !== h(e)) return !1;
                        if ("string" == typeof t) return t === e;
                        var a = t.tagClass === e.tagClass && t.type === e.type && t.constructed === e.constructed && t.composed === e.composed && i.equals(t.value, e.value);
                        return r && r.includeBitStringContents && (a = a && t.bitStringContents === e.bitStringContents), a
                    }, i.getBerValueLength = function(t) {
                        var e = t.getByte();
                        if (128 !== e) return 128 & e ? t.getInt((127 & e) << 3) : e
                    }, i.fromDer = function(t, e) {
                        return void 0 === e && (e = {
                                strict: !0,
                                decodeBitStrings: !0
                            }), "boolean" == typeof e && (e = {
                                strict: e,
                                decodeBitStrings: !0
                            }), "strict" in e || (e.strict = !0), "decodeBitStrings" in e || (e.decodeBitStrings = !0), "string" == typeof t && (t = n.util.createBuffer(t)),
                            function t(e, r, n, a) {
                                var o;
                                s(e, r, 2);
                                var u = e.getByte();
                                r--;
                                var c = 192 & u,
                                    h = 31 & u;
                                o = e.length();
                                var l, f, p = function(t, e) {
                                    var r = t.getByte();
                                    if (e--, 128 !== r) {
                                        var n;
                                        if (128 & r) {
                                            var i = 127 & r;
                                            s(t, e, i), n = t.getInt(i << 3)
                                        } else n = r;
                                        if (n < 0) throw new Error("Negative length: " + n);
                                        return n
                                    }
                                }(e, r);
                                if (r -= o - e.length(), void 0 !== p && p > r) {
                                    if (a.strict) {
                                        var d = new Error("Too few bytes to read ASN.1 value.");
                                        throw d.available = e.length(), d.remaining = r, d.requested = p, d
                                    }
                                    p = r
                                }
                                var g = 32 == (32 & u);
                                if (g)
                                    if (l = [], void 0 === p)
                                        for (;;) {
                                            if (s(e, r, 2), e.bytes(2) === String.fromCharCode(0, 0)) {
                                                e.getBytes(2), r -= 2;
                                                break
                                            }
                                            o = e.length(), l.push(t(e, r, n + 1, a)), r -= o - e.length()
                                        } else
                                            for (; p > 0;) o = e.length(), l.push(t(e, p, n + 1, a)), r -= o - e.length(), p -= o - e.length();
                                if (void 0 === l && c === i.Class.UNIVERSAL && h === i.Type.BITSTRING && (f = e.bytes(p)), void 0 === l && a.decodeBitStrings && c === i.Class.UNIVERSAL && h === i.Type.BITSTRING && p > 1) {
                                    var y = e.read,
                                        v = r,
                                        m = 0;
                                    if (h === i.Type.BITSTRING && (s(e, r, 1), m = e.getByte(), r--), 0 === m) try {
                                        o = e.length();
                                        var E = {
                                                verbose: a.verbose,
                                                strict: !0,
                                                decodeBitStrings: !0
                                            },
                                            S = t(e, r, n + 1, E),
                                            b = o - e.length();
                                        r -= b, h == i.Type.BITSTRING && b++;
                                        var C = S.tagClass;
                                        b !== p || C !== i.Class.UNIVERSAL && C !== i.Class.CONTEXT_SPECIFIC || (l = [S])
                                    } catch (t) {}
                                    void 0 === l && (e.read = y, r = v)
                                }
                                if (void 0 === l) {
                                    if (void 0 === p) {
                                        if (a.strict) throw new Error("Non-constructed ASN.1 object of indefinite length.");
                                        p = r
                                    }
                                    if (h === i.Type.BMPSTRING)
                                        for (l = ""; p > 0; p -= 2) s(e, r, 2), l += String.fromCharCode(e.getInt16()), r -= 2;
                                    else l = e.getBytes(p)
                                }
                                var A = void 0 === f ? null : {
                                    bitStringContents: f
                                };
                                return i.create(c, h, g, l, A)
                            }(t, t.length(), 0, e)
                    }, i.toDer = function(t) {
                        var e = n.util.createBuffer(),
                            r = t.tagClass | t.type,
                            s = n.util.createBuffer(),
                            a = !1;
                        if ("bitStringContents" in t && (a = !0, t.original && (a = i.equals(t, t.original))), a) s.putBytes(t.bitStringContents);
                        else if (t.composed) {
                            t.constructed ? r |= 32 : s.putByte(0);
                            for (var o = 0; o < t.value.length; ++o) void 0 !== t.value[o] && s.putBuffer(i.toDer(t.value[o]))
                        } else if (t.type === i.Type.BMPSTRING)
                            for (o = 0; o < t.value.length; ++o) s.putInt16(t.value.charCodeAt(o));
                        else t.type === i.Type.INTEGER && t.value.length > 1 && (0 === t.value.charCodeAt(0) && 0 == (128 & t.value.charCodeAt(1)) || 255 === t.value.charCodeAt(0) && 128 == (128 & t.value.charCodeAt(1))) ? s.putBytes(t.value.substr(1)) : s.putBytes(t.value);
                        if (e.putByte(r), s.length() <= 127) e.putByte(127 & s.length());
                        else {
                            var u = s.length(),
                                c = "";
                            do {
                                c += String.fromCharCode(255 & u), u >>>= 8
                            } while (u > 0);
                            for (e.putByte(128 | c.length), o = c.length - 1; o >= 0; --o) e.putByte(c.charCodeAt(o))
                        }
                        return e.putBuffer(s), e
                    }, i.oidToDer = function(t) {
                        var e, r, i, s, a = t.split("."),
                            o = n.util.createBuffer();
                        o.putByte(40 * parseInt(a[0], 10) + parseInt(a[1], 10));
                        for (var u = 2; u < a.length; ++u) {
                            e = !0, r = [], i = parseInt(a[u], 10);
                            do {
                                s = 127 & i, i >>>= 7, e || (s |= 128), r.push(s), e = !1
                            } while (i > 0);
                            for (var c = r.length - 1; c >= 0; --c) o.putByte(r[c])
                        }
                        return o
                    }, i.derToOid = function(t) {
                        var e;
                        "string" == typeof t && (t = n.util.createBuffer(t));
                        var r = t.getByte();
                        e = Math.floor(r / 40) + "." + r % 40;
                        for (var i = 0; t.length() > 0;) i <<= 7, 128 & (r = t.getByte()) ? i += 127 & r : (e += "." + (i + r), i = 0);
                        return e
                    }, i.utcTimeToDate = function(t) {
                        var e = new Date,
                            r = parseInt(t.substr(0, 2), 10);
                        r = r >= 50 ? 1900 + r : 2e3 + r;
                        var n = parseInt(t.substr(2, 2), 10) - 1,
                            i = parseInt(t.substr(4, 2), 10),
                            s = parseInt(t.substr(6, 2), 10),
                            a = parseInt(t.substr(8, 2), 10),
                            o = 0;
                        if (t.length > 11) {
                            var u = t.charAt(10),
                                c = 10;
                            "+" !== u && "-" !== u && (o = parseInt(t.substr(10, 2), 10), c += 2)
                        }
                        if (e.setUTCFullYear(r, n, i), e.setUTCHours(s, a, o, 0), c && ("+" === (u = t.charAt(c)) || "-" === u)) {
                            var h = 60 * parseInt(t.substr(c + 1, 2), 10) + parseInt(t.substr(c + 4, 2), 10);
                            h *= 6e4, "+" === u ? e.setTime(+e - h) : e.setTime(+e + h)
                        }
                        return e
                    }, i.generalizedTimeToDate = function(t) {
                        var e = new Date,
                            r = parseInt(t.substr(0, 4), 10),
                            n = parseInt(t.substr(4, 2), 10) - 1,
                            i = parseInt(t.substr(6, 2), 10),
                            s = parseInt(t.substr(8, 2), 10),
                            a = parseInt(t.substr(10, 2), 10),
                            o = parseInt(t.substr(12, 2), 10),
                            u = 0,
                            c = 0,
                            h = !1;
                        "Z" === t.charAt(t.length - 1) && (h = !0);
                        var l = t.length - 5,
                            f = t.charAt(l);
                        return "+" !== f && "-" !== f || (c = 60 * parseInt(t.substr(l + 1, 2), 10) + parseInt(t.substr(l + 4, 2), 10), c *= 6e4, "+" === f && (c *= -1), h = !0), "." === t.charAt(14) && (u = 1e3 * parseFloat(t.substr(14), 10)), h ? (e.setUTCFullYear(r, n, i), e.setUTCHours(s, a, o, u), e.setTime(+e + c)) : (e.setFullYear(r, n, i), e.setHours(s, a, o, u)), e
                    }, i.dateToUtcTime = function(t) {
                        if ("string" == typeof t) return t;
                        var e = "",
                            r = [];
                        r.push(("" + t.getUTCFullYear()).substr(2)), r.push("" + (t.getUTCMonth() + 1)), r.push("" + t.getUTCDate()), r.push("" + t.getUTCHours()), r.push("" + t.getUTCMinutes()), r.push("" + t.getUTCSeconds());
                        for (var n = 0; n < r.length; ++n) r[n].length < 2 && (e += "0"), e += r[n];
                        return e += "Z"
                    }, i.dateToGeneralizedTime = function(t) {
                        if ("string" == typeof t) return t;
                        var e = "",
                            r = [];
                        r.push("" + t.getUTCFullYear()), r.push("" + (t.getUTCMonth() + 1)), r.push("" + t.getUTCDate()), r.push("" + t.getUTCHours()), r.push("" + t.getUTCMinutes()), r.push("" + t.getUTCSeconds());
                        for (var n = 0; n < r.length; ++n) r[n].length < 2 && (e += "0"), e += r[n];
                        return e += "Z"
                    }, i.integerToDer = function(t) {
                        var e = n.util.createBuffer();
                        if (t >= -128 && t < 128) return e.putSignedInt(t, 8);
                        if (t >= -32768 && t < 32768) return e.putSignedInt(t, 16);
                        if (t >= -8388608 && t < 8388608) return e.putSignedInt(t, 24);
                        if (t >= -2147483648 && t < 2147483648) return e.putSignedInt(t, 32);
                        var r = new Error("Integer too large; max is 32-bits.");
                        throw r.integer = t, r
                    }, i.derToInteger = function(t) {
                        "string" == typeof t && (t = n.util.createBuffer(t));
                        var e = 8 * t.length();
                        if (e > 32) throw new Error("Integer too large; max is 32-bits.");
                        return t.getSignedInt(e)
                    }, i.validate = function(t, e, r, s) {
                        var a = !1;
                        if (t.tagClass !== e.tagClass && void 0 !== e.tagClass || t.type !== e.type && void 0 !== e.type) s && (t.tagClass !== e.tagClass && s.push("[" + e.name + '] Expected tag class "' + e.tagClass + '", got "' + t.tagClass + '"'), t.type !== e.type && s.push("[" + e.name + '] Expected type "' + e.type + '", got "' + t.type + '"'));
                        else if (t.constructed === e.constructed || void 0 === e.constructed) {
                            if (a = !0, e.value && n.util.isArray(e.value))
                                for (var o = 0, u = 0; a && u < e.value.length; ++u) a = e.value[u].optional || !1, t.value[o] && ((a = i.validate(t.value[o], e.value[u], r, s)) ? ++o : e.value[u].optional && (a = !0)), !a && s && s.push("[" + e.name + '] Tag class "' + e.tagClass + '", type "' + e.type + '" expected value length "' + e.value.length + '", got "' + t.value.length + '"');
                            if (a && r && (e.capture && (r[e.capture] = t.value), e.captureAsn1 && (r[e.captureAsn1] = t), e.captureBitStringContents && "bitStringContents" in t && (r[e.captureBitStringContents] = t.bitStringContents), e.captureBitStringValue && "bitStringContents" in t))
                                if (t.bitStringContents.length < 2) r[e.captureBitStringValue] = "";
                                else {
                                    if (0 !== t.bitStringContents.charCodeAt(0)) throw new Error("captureBitStringValue only supported for zero unused bits");
                                    r[e.captureBitStringValue] = t.bitStringContents.slice(1)
                                }
                        } else s && s.push("[" + e.name + '] Expected constructed "' + e.constructed + '", got "' + t.constructed + '"');
                        return a
                    };
                    var a = /[^\\u0000-\\u00ff]/;
                    i.prettyPrint = function(t, e, r) {
                        var s = "";
                        r = r || 2, (e = e || 0) > 0 && (s += "\n");
                        for (var o = "", u = 0; u < e * r; ++u) o += " ";
                        switch (s += o + "Tag: ", t.tagClass) {
                            case i.Class.UNIVERSAL:
                                s += "Universal:";
                                break;
                            case i.Class.APPLICATION:
                                s += "Application:";
                                break;
                            case i.Class.CONTEXT_SPECIFIC:
                                s += "Context-Specific:";
                                break;
                            case i.Class.PRIVATE:
                                s += "Private:"
                        }
                        if (t.tagClass === i.Class.UNIVERSAL) switch (s += t.type, t.type) {
                            case i.Type.NONE:
                                s += " (None)";
                                break;
                            case i.Type.BOOLEAN:
                                s += " (Boolean)";
                                break;
                            case i.Type.INTEGER:
                                s += " (Integer)";
                                break;
                            case i.Type.BITSTRING:
                                s += " (Bit string)";
                                break;
                            case i.Type.OCTETSTRING:
                                s += " (Octet string)";
                                break;
                            case i.Type.NULL:
                                s += " (Null)";
                                break;
                            case i.Type.OID:
                                s += " (Object Identifier)";
                                break;
                            case i.Type.ODESC:
                                s += " (Object Descriptor)";
                                break;
                            case i.Type.EXTERNAL:
                                s += " (External or Instance of)";
                                break;
                            case i.Type.REAL:
                                s += " (Real)";
                                break;
                            case i.Type.ENUMERATED:
                                s += " (Enumerated)";
                                break;
                            case i.Type.EMBEDDED:
                                s += " (Embedded PDV)";
                                break;
                            case i.Type.UTF8:
                                s += " (UTF8)";
                                break;
                            case i.Type.ROID:
                                s += " (Relative Object Identifier)";
                                break;
                            case i.Type.SEQUENCE:
                                s += " (Sequence)";
                                break;
                            case i.Type.SET:
                                s += " (Set)";
                                break;
                            case i.Type.PRINTABLESTRING:
                                s += " (Printable String)";
                                break;
                            case i.Type.IA5String:
                                s += " (IA5String (ASCII))";
                                break;
                            case i.Type.UTCTIME:
                                s += " (UTC time)";
                                break;
                            case i.Type.GENERALIZEDTIME:
                                s += " (Generalized time)";
                                break;
                            case i.Type.BMPSTRING:
                                s += " (BMP String)"
                        } else s += t.type;
                        if (s += "\n", s += o + "Constructed: " + t.constructed + "\n", t.composed) {
                            var c = 0,
                                h = "";
                            for (u = 0; u < t.value.length; ++u) void 0 !== t.value[u] && (c += 1, h += i.prettyPrint(t.value[u], e + 1, r), u + 1 < t.value.length && (h += ","));
                            s += o + "Sub values: " + c + h
                        } else {
                            if (s += o + "Value: ", t.type === i.Type.OID) {
                                var l = i.derToOid(t.value);
                                s += l, n.pki && n.pki.oids && l in n.pki.oids && (s += " (" + n.pki.oids[l] + ") ")
                            }
                            if (t.type === i.Type.INTEGER) try {
                                s += i.derToInteger(t.value)
                            } catch (e) {
                                s += "0x" + n.util.bytesToHex(t.value)
                            } else if (t.type === i.Type.BITSTRING) {
                                if (t.value.length > 1 ? s += "0x" + n.util.bytesToHex(t.value.slice(1)) : s += "(none)", t.value.length > 0) {
                                    var f = t.value.charCodeAt(0);
                                    1 == f ? s += " (1 unused bit shown)" : f > 1 && (s += " (" + f + " unused bits shown)")
                                }
                            } else t.type === i.Type.OCTETSTRING ? (a.test(t.value) || (s += "(" + t.value + ") "), s += "0x" + n.util.bytesToHex(t.value)) : t.type === i.Type.UTF8 ? s += n.util.decodeUtf8(t.value) : t.type === i.Type.PRINTABLESTRING || t.type === i.Type.IA5String ? s += t.value : a.test(t.value) ? s += "0x" + n.util.bytesToHex(t.value) : 0 === t.value.length ? s += "[null]" : s += t.value
                        }
                        return s
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    t.exports = n.md = n.md || {}, n.md.algorithms = n.md.algorithms || {}
                }, function(t, e, r) {
                    var n = r(0);

                    function i(t, e) {
                        n.cipher.registerAlgorithm(t, (function() {
                            return new n.aes.Algorithm(t, e)
                        }))
                    }
                    r(13), r(19), r(1), t.exports = n.aes = n.aes || {}, n.aes.startEncrypting = function(t, e, r, n) {
                        var i = d({
                            key: t,
                            output: r,
                            decrypt: !1,
                            mode: n
                        });
                        return i.start(e), i
                    }, n.aes.createEncryptionCipher = function(t, e) {
                        return d({
                            key: t,
                            output: null,
                            decrypt: !1,
                            mode: e
                        })
                    }, n.aes.startDecrypting = function(t, e, r, n) {
                        var i = d({
                            key: t,
                            output: r,
                            decrypt: !0,
                            mode: n
                        });
                        return i.start(e), i
                    }, n.aes.createDecryptionCipher = function(t, e) {
                        return d({
                            key: t,
                            output: null,
                            decrypt: !0,
                            mode: e
                        })
                    }, n.aes.Algorithm = function(t, e) {
                        h || l();
                        var r = this;
                        r.name = t, r.mode = new e({
                            blockSize: 16,
                            cipher: {
                                encrypt: function(t, e) {
                                    return p(r._w, t, e, !1)
                                },
                                decrypt: function(t, e) {
                                    return p(r._w, t, e, !0)
                                }
                            }
                        }), r._init = !1
                    }, n.aes.Algorithm.prototype.initialize = function(t) {
                        if (!this._init) {
                            var e, r = t.key;
                            if ("string" != typeof r || 16 !== r.length && 24 !== r.length && 32 !== r.length) {
                                if (n.util.isArray(r) && (16 === r.length || 24 === r.length || 32 === r.length)) {
                                    e = r, r = n.util.createBuffer();
                                    for (var i = 0; i < e.length; ++i) r.putByte(e[i])
                                }
                            } else r = n.util.createBuffer(r);
                            if (!n.util.isArray(r)) {
                                e = r, r = [];
                                var s = e.length();
                                if (16 === s || 24 === s || 32 === s)
                                    for (s >>>= 2, i = 0; i < s; ++i) r.push(e.getInt32())
                            }
                            if (!n.util.isArray(r) || 4 !== r.length && 6 !== r.length && 8 !== r.length) throw new Error("Invalid key parameter.");
                            var a = this.mode.name,
                                o = -1 !== ["CFB", "OFB", "CTR", "GCM"].indexOf(a);
                            this._w = f(r, t.decrypt && !o), this._init = !0
                        }
                    }, n.aes._expandKey = function(t, e) {
                        return h || l(), f(t, e)
                    }, n.aes._updateBlock = p, i("AES-ECB", n.cipher.modes.ecb), i("AES-CBC", n.cipher.modes.cbc), i("AES-CFB", n.cipher.modes.cfb), i("AES-OFB", n.cipher.modes.ofb), i("AES-CTR", n.cipher.modes.ctr), i("AES-GCM", n.cipher.modes.gcm);
                    var s, a, o, u, c, h = !1;

                    function l() {
                        h = !0, o = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
                        for (var t = new Array(256), e = 0; e < 128; ++e) t[e] = e << 1, t[e + 128] = e + 128 << 1 ^ 283;
                        for (s = new Array(256), a = new Array(256), u = new Array(4), c = new Array(4), e = 0; e < 4; ++e) u[e] = new Array(256), c[e] = new Array(256);
                        var r, n, i, l, f, p, d, g = 0,
                            y = 0;
                        for (e = 0; e < 256; ++e) {
                            l = (l = y ^ y << 1 ^ y << 2 ^ y << 3 ^ y << 4) >> 8 ^ 255 & l ^ 99, s[g] = l, a[l] = g, p = (f = t[l]) << 24 ^ l << 16 ^ l << 8 ^ l ^ f, d = ((r = t[g]) ^ (n = t[r]) ^ (i = t[n])) << 24 ^ (g ^ i) << 16 ^ (g ^ n ^ i) << 8 ^ g ^ r ^ i;
                            for (var v = 0; v < 4; ++v) u[v][g] = p, c[v][l] = d, p = p << 24 | p >>> 8, d = d << 24 | d >>> 8;
                            0 === g ? g = y = 1 : (g = r ^ t[t[t[r ^ i]]], y ^= t[t[y]])
                        }
                    }

                    function f(t, e) {
                        for (var r, n = t.slice(0), i = 1, a = n.length, u = 4 * (a + 6 + 1), h = a; h < u; ++h) r = n[h - 1], h % a == 0 ? (r = s[r >>> 16 & 255] << 24 ^ s[r >>> 8 & 255] << 16 ^ s[255 & r] << 8 ^ s[r >>> 24] ^ o[i] << 24, i++) : a > 6 && h % a == 4 && (r = s[r >>> 24] << 24 ^ s[r >>> 16 & 255] << 16 ^ s[r >>> 8 & 255] << 8 ^ s[255 & r]), n[h] = n[h - a] ^ r;
                        if (e) {
                            for (var l, f = c[0], p = c[1], d = c[2], g = c[3], y = n.slice(0), v = (h = 0, (u = n.length) - 4); h < u; h += 4, v -= 4)
                                if (0 === h || h === u - 4) y[h] = n[v], y[h + 1] = n[v + 3], y[h + 2] = n[v + 2], y[h + 3] = n[v + 1];
                                else
                                    for (var m = 0; m < 4; ++m) l = n[v + m], y[h + (3 & -m)] = f[s[l >>> 24]] ^ p[s[l >>> 16 & 255]] ^ d[s[l >>> 8 & 255]] ^ g[s[255 & l]];
                            n = y
                        }
                        return n
                    }

                    function p(t, e, r, n) {
                        var i, o, h, l, f, p, d, g, y, v, m, E, S = t.length / 4 - 1;
                        n ? (i = c[0], o = c[1], h = c[2], l = c[3], f = a) : (i = u[0], o = u[1], h = u[2], l = u[3], f = s), p = e[0] ^ t[0], d = e[n ? 3 : 1] ^ t[1], g = e[2] ^ t[2], y = e[n ? 1 : 3] ^ t[3];
                        for (var b = 3, C = 1; C < S; ++C) v = i[p >>> 24] ^ o[d >>> 16 & 255] ^ h[g >>> 8 & 255] ^ l[255 & y] ^ t[++b], m = i[d >>> 24] ^ o[g >>> 16 & 255] ^ h[y >>> 8 & 255] ^ l[255 & p] ^ t[++b], E = i[g >>> 24] ^ o[y >>> 16 & 255] ^ h[p >>> 8 & 255] ^ l[255 & d] ^ t[++b], y = i[y >>> 24] ^ o[p >>> 16 & 255] ^ h[d >>> 8 & 255] ^ l[255 & g] ^ t[++b], p = v, d = m, g = E;
                        r[0] = f[p >>> 24] << 24 ^ f[d >>> 16 & 255] << 16 ^ f[g >>> 8 & 255] << 8 ^ f[255 & y] ^ t[++b], r[n ? 3 : 1] = f[d >>> 24] << 24 ^ f[g >>> 16 & 255] << 16 ^ f[y >>> 8 & 255] << 8 ^ f[255 & p] ^ t[++b], r[2] = f[g >>> 24] << 24 ^ f[y >>> 16 & 255] << 16 ^ f[p >>> 8 & 255] << 8 ^ f[255 & d] ^ t[++b], r[n ? 1 : 3] = f[y >>> 24] << 24 ^ f[p >>> 16 & 255] << 16 ^ f[d >>> 8 & 255] << 8 ^ f[255 & g] ^ t[++b]
                    }

                    function d(t) {
                        var e, r = "AES-" + ((t = t || {}).mode || "CBC").toUpperCase(),
                            i = (e = t.decrypt ? n.cipher.createDecipher(r, t.key) : n.cipher.createCipher(r, t.key)).start;
                        return e.start = function(t, r) {
                            var s = null;
                            r instanceof n.util.ByteBuffer && (s = r, r = {}), (r = r || {}).output = s, r.iv = t, i.call(e, r)
                        }, e
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    n.pki = n.pki || {};
                    var i = t.exports = n.pki.oids = n.oids = n.oids || {};

                    function s(t, e) {
                        i[t] = e, i[e] = t
                    }

                    function a(t, e) {
                        i[t] = e
                    }
                    s("1.2.840.113549.1.1.1", "rsaEncryption"), s("1.2.840.113549.1.1.4", "md5WithRSAEncryption"), s("1.2.840.113549.1.1.5", "sha1WithRSAEncryption"), s("1.2.840.113549.1.1.7", "RSAES-OAEP"), s("1.2.840.113549.1.1.8", "mgf1"), s("1.2.840.113549.1.1.9", "pSpecified"), s("1.2.840.113549.1.1.10", "RSASSA-PSS"), s("1.2.840.113549.1.1.11", "sha256WithRSAEncryption"), s("1.2.840.113549.1.1.12", "sha384WithRSAEncryption"), s("1.2.840.113549.1.1.13", "sha512WithRSAEncryption"), s("1.3.101.112", "EdDSA25519"), s("1.2.840.10040.4.3", "dsa-with-sha1"), s("1.3.14.3.2.7", "desCBC"), s("1.3.14.3.2.26", "sha1"), s("2.16.840.1.101.3.4.2.1", "sha256"), s("2.16.840.1.101.3.4.2.2", "sha384"), s("2.16.840.1.101.3.4.2.3", "sha512"), s("1.2.840.113549.2.5", "md5"), s("1.2.840.113549.1.7.1", "data"), s("1.2.840.113549.1.7.2", "signedData"), s("1.2.840.113549.1.7.3", "envelopedData"), s("1.2.840.113549.1.7.4", "signedAndEnvelopedData"), s("1.2.840.113549.1.7.5", "digestedData"), s("1.2.840.113549.1.7.6", "encryptedData"), s("1.2.840.113549.1.9.1", "emailAddress"), s("1.2.840.113549.1.9.2", "unstructuredName"), s("1.2.840.113549.1.9.3", "contentType"), s("1.2.840.113549.1.9.4", "messageDigest"), s("1.2.840.113549.1.9.5", "signingTime"), s("1.2.840.113549.1.9.6", "counterSignature"), s("1.2.840.113549.1.9.7", "challengePassword"), s("1.2.840.113549.1.9.8", "unstructuredAddress"), s("1.2.840.113549.1.9.14", "extensionRequest"), s("1.2.840.113549.1.9.20", "friendlyName"), s("1.2.840.113549.1.9.21", "localKeyId"), s("1.2.840.113549.1.9.22.1", "x509Certificate"), s("1.2.840.113549.1.12.10.1.1", "keyBag"), s("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag"), s("1.2.840.113549.1.12.10.1.3", "certBag"), s("1.2.840.113549.1.12.10.1.4", "crlBag"), s("1.2.840.113549.1.12.10.1.5", "secretBag"), s("1.2.840.113549.1.12.10.1.6", "safeContentsBag"), s("1.2.840.113549.1.5.13", "pkcs5PBES2"), s("1.2.840.113549.1.5.12", "pkcs5PBKDF2"), s("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4"), s("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4"), s("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC"), s("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC"), s("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC"), s("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC"), s("1.2.840.113549.2.7", "hmacWithSHA1"), s("1.2.840.113549.2.8", "hmacWithSHA224"), s("1.2.840.113549.2.9", "hmacWithSHA256"), s("1.2.840.113549.2.10", "hmacWithSHA384"), s("1.2.840.113549.2.11", "hmacWithSHA512"), s("1.2.840.113549.3.7", "des-EDE3-CBC"), s("2.16.840.1.101.3.4.1.2", "aes128-CBC"), s("2.16.840.1.101.3.4.1.22", "aes192-CBC"), s("2.16.840.1.101.3.4.1.42", "aes256-CBC"), s("2.5.4.3", "commonName"), s("2.5.4.5", "serialName"), s("2.5.4.6", "countryName"), s("2.5.4.7", "localityName"), s("2.5.4.8", "stateOrProvinceName"), s("2.5.4.9", "streetAddress"), s("2.5.4.10", "organizationName"), s("2.5.4.11", "organizationalUnitName"), s("2.5.4.13", "description"), s("2.5.4.15", "businessCategory"), s("2.5.4.17", "postalCode"), s("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName"), s("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName"), s("2.16.840.1.113730.1.1", "nsCertType"), s("2.16.840.1.113730.1.13", "nsComment"), a("2.5.29.1", "authorityKeyIdentifier"), a("2.5.29.2", "keyAttributes"), a("2.5.29.3", "certificatePolicies"), a("2.5.29.4", "keyUsageRestriction"), a("2.5.29.5", "policyMapping"), a("2.5.29.6", "subtreesConstraint"), a("2.5.29.7", "subjectAltName"), a("2.5.29.8", "issuerAltName"), a("2.5.29.9", "subjectDirectoryAttributes"), a("2.5.29.10", "basicConstraints"), a("2.5.29.11", "nameConstraints"), a("2.5.29.12", "policyConstraints"), a("2.5.29.13", "basicConstraints"), s("2.5.29.14", "subjectKeyIdentifier"), s("2.5.29.15", "keyUsage"), a("2.5.29.16", "privateKeyUsagePeriod"), s("2.5.29.17", "subjectAltName"), s("2.5.29.18", "issuerAltName"), s("2.5.29.19", "basicConstraints"), a("2.5.29.20", "cRLNumber"), a("2.5.29.21", "cRLReason"), a("2.5.29.22", "expirationDate"), a("2.5.29.23", "instructionCode"), a("2.5.29.24", "invalidityDate"), a("2.5.29.25", "cRLDistributionPoints"), a("2.5.29.26", "issuingDistributionPoint"), a("2.5.29.27", "deltaCRLIndicator"), a("2.5.29.28", "issuingDistributionPoint"), a("2.5.29.29", "certificateIssuer"), a("2.5.29.30", "nameConstraints"), s("2.5.29.31", "cRLDistributionPoints"), s("2.5.29.32", "certificatePolicies"), a("2.5.29.33", "policyMappings"), a("2.5.29.34", "policyConstraints"), s("2.5.29.35", "authorityKeyIdentifier"), a("2.5.29.36", "policyConstraints"), s("2.5.29.37", "extKeyUsage"), a("2.5.29.46", "freshestCRL"), a("2.5.29.54", "inhibitAnyPolicy"), s("1.3.6.1.4.1.11129.2.4.2", "timestampList"), s("1.3.6.1.5.5.7.1.1", "authorityInfoAccess"), s("1.3.6.1.5.5.7.3.1", "serverAuth"), s("1.3.6.1.5.5.7.3.2", "clientAuth"), s("1.3.6.1.5.5.7.3.3", "codeSigning"), s("1.3.6.1.5.5.7.3.4", "emailProtection"), s("1.3.6.1.5.5.7.3.8", "timeStamping")
                }, function(t, e, r) {
                    var n = r(0);
                    r(1);
                    var i = t.exports = n.pem = n.pem || {};

                    function s(t) {
                        for (var e = t.name + ": ", r = [], n = function(t, e) {
                                return " " + e
                            }, i = 0; i < t.values.length; ++i) r.push(t.values[i].replace(/^(\S+\r\n)/, n));
                        e += r.join(",") + "\r\n";
                        var s = 0,
                            a = -1;
                        for (i = 0; i < e.length; ++i, ++s)
                            if (s > 65 && -1 !== a) {
                                var o = e[a];
                                "," === o ? (++a, e = e.substr(0, a) + "\r\n " + e.substr(a)) : e = e.substr(0, a) + "\r\n" + o + e.substr(a + 1), s = i - a - 1, a = -1, ++i
                            } else " " !== e[i] && "\t" !== e[i] && "," !== e[i] || (a = i);
                        return e
                    }

                    function a(t) {
                        return t.replace(/^\s+/, "")
                    }
                    i.encode = function(t, e) {
                        e = e || {};
                        var r, i = "-----BEGIN " + t.type + "-----\r\n";
                        if (t.procType && (i += s(r = {
                                name: "Proc-Type",
                                values: [String(t.procType.version), t.procType.type]
                            })), t.contentDomain && (i += s(r = {
                                name: "Content-Domain",
                                values: [t.contentDomain]
                            })), t.dekInfo && (r = {
                                name: "DEK-Info",
                                values: [t.dekInfo.algorithm]
                            }, t.dekInfo.parameters && r.values.push(t.dekInfo.parameters), i += s(r)), t.headers)
                            for (var a = 0; a < t.headers.length; ++a) i += s(t.headers[a]);
                        return t.procType && (i += "\r\n"), i += n.util.encode64(t.body, e.maxline || 64) + "\r\n", i += "-----END " + t.type + "-----\r\n"
                    }, i.decode = function(t) {
                        for (var e, r = [], i = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, s = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, o = /\r?\n/; e = i.exec(t);) {
                            var u = {
                                type: e[1],
                                procType: null,
                                contentDomain: null,
                                dekInfo: null,
                                headers: [],
                                body: n.util.decode64(e[3])
                            };
                            if (r.push(u), e[2]) {
                                for (var c = e[2].split(o), h = 0; e && h < c.length;) {
                                    for (var l = c[h].replace(/\s+$/, ""), f = h + 1; f < c.length; ++f) {
                                        var p = c[f];
                                        if (!/\s/.test(p[0])) break;
                                        l += p, h = f
                                    }
                                    if (e = l.match(s)) {
                                        for (var d = {
                                                name: e[1],
                                                values: []
                                            }, g = e[2].split(","), y = 0; y < g.length; ++y) d.values.push(a(g[y]));
                                        if (u.procType)
                                            if (u.contentDomain || "Content-Domain" !== d.name)
                                                if (u.dekInfo || "DEK-Info" !== d.name) u.headers.push(d);
                                                else {
                                                    if (0 === d.values.length) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                                                    u.dekInfo = {
                                                        algorithm: g[0],
                                                        parameters: g[1] || null
                                                    }
                                                }
                                        else u.contentDomain = g[0] || "";
                                        else {
                                            if ("Proc-Type" !== d.name) throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
                                            if (2 !== d.values.length) throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
                                            u.procType = {
                                                version: g[0],
                                                type: g[1]
                                            }
                                        }
                                    }++h
                                }
                                if ("ENCRYPTED" === u.procType && !u.dekInfo) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".')
                            }
                        }
                        if (0 === r.length) throw new Error("Invalid PEM formatted message.");
                        return r
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(4), r(1), (t.exports = n.hmac = n.hmac || {}).create = function() {
                        var t = null,
                            e = null,
                            r = null,
                            i = null,
                            s = {
                                start: function(s, a) {
                                    if (null !== s)
                                        if ("string" == typeof s) {
                                            if (!((s = s.toLowerCase()) in n.md.algorithms)) throw new Error('Unknown hash algorithm "' + s + '"');
                                            e = n.md.algorithms[s].create()
                                        } else e = s;
                                    if (null === a) a = t;
                                    else {
                                        if ("string" == typeof a) a = n.util.createBuffer(a);
                                        else if (n.util.isArray(a)) {
                                            var o = a;
                                            a = n.util.createBuffer();
                                            for (var u = 0; u < o.length; ++u) a.putByte(o[u])
                                        }
                                        var c = a.length();
                                        for (c > e.blockLength && (e.start(), e.update(a.bytes()), a = e.digest()), r = n.util.createBuffer(), i = n.util.createBuffer(), c = a.length(), u = 0; u < c; ++u) o = a.at(u), r.putByte(54 ^ o), i.putByte(92 ^ o);
                                        if (c < e.blockLength)
                                            for (o = e.blockLength - c, u = 0; u < o; ++u) r.putByte(54), i.putByte(92);
                                        t = a, r = r.bytes(), i = i.bytes()
                                    }
                                    e.start(), e.update(r)
                                },
                                update: function(t) {
                                    e.update(t)
                                },
                                getMac: function() {
                                    var t = e.digest().bytes();
                                    return e.start(), e.update(i), e.update(t), e.digest()
                                }
                            };
                        return s.digest = s.getMac, s
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(4), r(1);
                    var i = t.exports = n.sha1 = n.sha1 || {};
                    n.md.sha1 = n.md.algorithms.sha1 = i, i.create = function() {
                        a || (s = String.fromCharCode(128), s += n.util.fillString(String.fromCharCode(0), 64), a = !0);
                        var t = null,
                            e = n.util.createBuffer(),
                            r = new Array(80),
                            i = {
                                algorithm: "sha1",
                                blockLength: 64,
                                digestLength: 20,
                                messageLength: 0,
                                fullMessageLength: null,
                                messageLengthSize: 8,
                                start: function() {
                                    i.messageLength = 0, i.fullMessageLength = i.messageLength64 = [];
                                    for (var r = i.messageLengthSize / 4, s = 0; s < r; ++s) i.fullMessageLength.push(0);
                                    return e = n.util.createBuffer(), t = {
                                        h0: 1732584193,
                                        h1: 4023233417,
                                        h2: 2562383102,
                                        h3: 271733878,
                                        h4: 3285377520
                                    }, i
                                }
                            };
                        return i.start(), i.update = function(s, a) {
                            "utf8" === a && (s = n.util.encodeUtf8(s));
                            var u = s.length;
                            i.messageLength += u, u = [u / 4294967296 >>> 0, u >>> 0];
                            for (var c = i.fullMessageLength.length - 1; c >= 0; --c) i.fullMessageLength[c] += u[1], u[1] = u[0] + (i.fullMessageLength[c] / 4294967296 >>> 0), i.fullMessageLength[c] = i.fullMessageLength[c] >>> 0, u[0] = u[1] / 4294967296 >>> 0;
                            return e.putBytes(s), o(t, r, e), (e.read > 2048 || 0 === e.length()) && e.compact(), i
                        }, i.digest = function() {
                            var a = n.util.createBuffer();
                            a.putBytes(e.bytes());
                            var u, c = i.fullMessageLength[i.fullMessageLength.length - 1] + i.messageLengthSize & i.blockLength - 1;
                            a.putBytes(s.substr(0, i.blockLength - c));
                            for (var h = 8 * i.fullMessageLength[0], l = 0; l < i.fullMessageLength.length - 1; ++l) h += (u = 8 * i.fullMessageLength[l + 1]) / 4294967296 >>> 0, a.putInt32(h >>> 0), h = u >>> 0;
                            a.putInt32(h);
                            var f = {
                                h0: t.h0,
                                h1: t.h1,
                                h2: t.h2,
                                h3: t.h3,
                                h4: t.h4
                            };
                            o(f, r, a);
                            var p = n.util.createBuffer();
                            return p.putInt32(f.h0), p.putInt32(f.h1), p.putInt32(f.h2), p.putInt32(f.h3), p.putInt32(f.h4), p
                        }, i
                    };
                    var s = null,
                        a = !1;

                    function o(t, e, r) {
                        for (var n, i, s, a, o, u, c, h = r.length(); h >= 64;) {
                            for (i = t.h0, s = t.h1, a = t.h2, o = t.h3, u = t.h4, c = 0; c < 16; ++c) n = r.getInt32(), e[c] = n, n = (i << 5 | i >>> 27) + (o ^ s & (a ^ o)) + u + 1518500249 + n, u = o, o = a, a = (s << 30 | s >>> 2) >>> 0, s = i, i = n;
                            for (; c < 20; ++c) n = (n = e[c - 3] ^ e[c - 8] ^ e[c - 14] ^ e[c - 16]) << 1 | n >>> 31, e[c] = n, n = (i << 5 | i >>> 27) + (o ^ s & (a ^ o)) + u + 1518500249 + n, u = o, o = a, a = (s << 30 | s >>> 2) >>> 0, s = i, i = n;
                            for (; c < 32; ++c) n = (n = e[c - 3] ^ e[c - 8] ^ e[c - 14] ^ e[c - 16]) << 1 | n >>> 31, e[c] = n, n = (i << 5 | i >>> 27) + (s ^ a ^ o) + u + 1859775393 + n, u = o, o = a, a = (s << 30 | s >>> 2) >>> 0, s = i, i = n;
                            for (; c < 40; ++c) n = (n = e[c - 6] ^ e[c - 16] ^ e[c - 28] ^ e[c - 32]) << 2 | n >>> 30, e[c] = n, n = (i << 5 | i >>> 27) + (s ^ a ^ o) + u + 1859775393 + n, u = o, o = a, a = (s << 30 | s >>> 2) >>> 0, s = i, i = n;
                            for (; c < 60; ++c) n = (n = e[c - 6] ^ e[c - 16] ^ e[c - 28] ^ e[c - 32]) << 2 | n >>> 30, e[c] = n, n = (i << 5 | i >>> 27) + (s & a | o & (s ^ a)) + u + 2400959708 + n, u = o, o = a, a = (s << 30 | s >>> 2) >>> 0, s = i, i = n;
                            for (; c < 80; ++c) n = (n = e[c - 6] ^ e[c - 16] ^ e[c - 28] ^ e[c - 32]) << 2 | n >>> 30, e[c] = n, n = (i << 5 | i >>> 27) + (s ^ a ^ o) + u + 3395469782 + n, u = o, o = a, a = (s << 30 | s >>> 2) >>> 0, s = i, i = n;
                            t.h0 = t.h0 + i | 0, t.h1 = t.h1 + s | 0, t.h2 = t.h2 + a | 0, t.h3 = t.h3 + o | 0, t.h4 = t.h4 + u | 0, h -= 64
                        }
                    }
                }, function(t, e, r) {
                    var n = r(0);

                    function i(t, e) {
                        n.cipher.registerAlgorithm(t, (function() {
                            return new n.des.Algorithm(t, e)
                        }))
                    }
                    r(13), r(19), r(1), t.exports = n.des = n.des || {}, n.des.startEncrypting = function(t, e, r, n) {
                        var i = d({
                            key: t,
                            output: r,
                            decrypt: !1,
                            mode: n || (null === e ? "ECB" : "CBC")
                        });
                        return i.start(e), i
                    }, n.des.createEncryptionCipher = function(t, e) {
                        return d({
                            key: t,
                            output: null,
                            decrypt: !1,
                            mode: e
                        })
                    }, n.des.startDecrypting = function(t, e, r, n) {
                        var i = d({
                            key: t,
                            output: r,
                            decrypt: !0,
                            mode: n || (null === e ? "ECB" : "CBC")
                        });
                        return i.start(e), i
                    }, n.des.createDecryptionCipher = function(t, e) {
                        return d({
                            key: t,
                            output: null,
                            decrypt: !0,
                            mode: e
                        })
                    }, n.des.Algorithm = function(t, e) {
                        var r = this;
                        r.name = t, r.mode = new e({
                            blockSize: 8,
                            cipher: {
                                encrypt: function(t, e) {
                                    return p(r._keys, t, e, !1)
                                },
                                decrypt: function(t, e) {
                                    return p(r._keys, t, e, !0)
                                }
                            }
                        }), r._init = !1
                    }, n.des.Algorithm.prototype.initialize = function(t) {
                        if (!this._init) {
                            var e = n.util.createBuffer(t.key);
                            if (0 === this.name.indexOf("3DES") && 24 !== e.length()) throw new Error("Invalid Triple-DES key size: " + 8 * e.length());
                            this._keys = function(t) {
                                for (var e, r = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], n = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], i = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], s = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], a = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], o = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], u = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], c = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], h = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], l = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], f = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], p = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], d = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], g = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], y = t.length() > 8 ? 3 : 1, v = [], m = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], E = 0, S = 0; S < y; S++) {
                                    var b = t.getInt32(),
                                        C = t.getInt32();
                                    b ^= (e = 252645135 & (b >>> 4 ^ C)) << 4, b ^= e = 65535 & ((C ^= e) >>> -16 ^ b), b ^= (e = 858993459 & (b >>> 2 ^ (C ^= e << -16))) << 2, b ^= e = 65535 & ((C ^= e) >>> -16 ^ b), b ^= (e = 1431655765 & (b >>> 1 ^ (C ^= e << -16))) << 1, b ^= e = 16711935 & ((C ^= e) >>> 8 ^ b), e = (b ^= (e = 1431655765 & (b >>> 1 ^ (C ^= e << 8))) << 1) << 8 | (C ^= e) >>> 20 & 240, b = C << 24 | C << 8 & 16711680 | C >>> 8 & 65280 | C >>> 24 & 240, C = e;
                                    for (var A = 0; A < m.length; ++A) {
                                        m[A] ? (b = b << 2 | b >>> 26, C = C << 2 | C >>> 26) : (b = b << 1 | b >>> 27, C = C << 1 | C >>> 27);
                                        var w = r[(b &= -15) >>> 28] | n[b >>> 24 & 15] | i[b >>> 20 & 15] | s[b >>> 16 & 15] | a[b >>> 12 & 15] | o[b >>> 8 & 15] | u[b >>> 4 & 15],
                                            T = c[(C &= -15) >>> 28] | h[C >>> 24 & 15] | l[C >>> 20 & 15] | f[C >>> 16 & 15] | p[C >>> 12 & 15] | d[C >>> 8 & 15] | g[C >>> 4 & 15];
                                        e = 65535 & (T >>> 16 ^ w), v[E++] = w ^ e, v[E++] = T ^ e << 16
                                    }
                                }
                                return v
                            }(e), this._init = !0
                        }
                    }, i("DES-ECB", n.cipher.modes.ecb), i("DES-CBC", n.cipher.modes.cbc), i("DES-CFB", n.cipher.modes.cfb), i("DES-OFB", n.cipher.modes.ofb), i("DES-CTR", n.cipher.modes.ctr), i("3DES-ECB", n.cipher.modes.ecb), i("3DES-CBC", n.cipher.modes.cbc), i("3DES-CFB", n.cipher.modes.cfb), i("3DES-OFB", n.cipher.modes.ofb), i("3DES-CTR", n.cipher.modes.ctr);
                    var s = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756],
                        a = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344],
                        o = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584],
                        u = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928],
                        c = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080],
                        h = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312],
                        l = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154],
                        f = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];

                    function p(t, e, r, n) {
                        var i, p, d = 32 === t.length ? 3 : 9;
                        i = 3 === d ? n ? [30, -2, -2] : [0, 32, 2] : n ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
                        var g = e[0],
                            y = e[1];
                        g ^= (p = 252645135 & (g >>> 4 ^ y)) << 4, g ^= (p = 65535 & (g >>> 16 ^ (y ^= p))) << 16, g ^= p = 858993459 & ((y ^= p) >>> 2 ^ g), g ^= p = 16711935 & ((y ^= p << 2) >>> 8 ^ g), g = (g ^= (p = 1431655765 & (g >>> 1 ^ (y ^= p << 8))) << 1) << 1 | g >>> 31, y = (y ^= p) << 1 | y >>> 31;
                        for (var v = 0; v < d; v += 3) {
                            for (var m = i[v + 1], E = i[v + 2], S = i[v]; S != m; S += E) {
                                var b = y ^ t[S],
                                    C = (y >>> 4 | y << 28) ^ t[S + 1];
                                p = g, g = y, y = p ^ (a[b >>> 24 & 63] | u[b >>> 16 & 63] | h[b >>> 8 & 63] | f[63 & b] | s[C >>> 24 & 63] | o[C >>> 16 & 63] | c[C >>> 8 & 63] | l[63 & C])
                            }
                            p = g, g = y, y = p
                        }
                        y = y >>> 1 | y << 31, y ^= p = 1431655765 & ((g = g >>> 1 | g << 31) >>> 1 ^ y), y ^= (p = 16711935 & (y >>> 8 ^ (g ^= p << 1))) << 8, y ^= (p = 858993459 & (y >>> 2 ^ (g ^= p))) << 2, y ^= p = 65535 & ((g ^= p) >>> 16 ^ y), y ^= p = 252645135 & ((g ^= p << 16) >>> 4 ^ y), g ^= p << 4, r[0] = g, r[1] = y
                    }

                    function d(t) {
                        var e, r = "DES-" + ((t = t || {}).mode || "CBC").toUpperCase(),
                            i = (e = t.decrypt ? n.cipher.createDecipher(r, t.key) : n.cipher.createCipher(r, t.key)).start;
                        return e.start = function(t, r) {
                            var s = null;
                            r instanceof n.util.ByteBuffer && (s = r, r = {}), (r = r || {}).output = s, r.iv = t, i.call(e, r)
                        }, e
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    if (r(3), r(12), r(6), r(26), r(27), r(2), r(1), void 0 === i) var i = n.jsbn.BigInteger;
                    var s = n.util.isNodejs ? r(16) : null,
                        a = n.asn1,
                        o = n.util;
                    n.pki = n.pki || {}, t.exports = n.pki.rsa = n.rsa = n.rsa || {};
                    var u = n.pki,
                        c = [6, 4, 2, 4, 2, 4, 6, 2],
                        l = {
                            name: "PrivateKeyInfo",
                            tagClass: a.Class.UNIVERSAL,
                            type: a.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "PrivateKeyInfo.version",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.INTEGER,
                                constructed: !1,
                                capture: "privateKeyVersion"
                            }, {
                                name: "PrivateKeyInfo.privateKeyAlgorithm",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.SEQUENCE,
                                constructed: !0,
                                value: [{
                                    name: "AlgorithmIdentifier.algorithm",
                                    tagClass: a.Class.UNIVERSAL,
                                    type: a.Type.OID,
                                    constructed: !1,
                                    capture: "privateKeyOid"
                                }]
                            }, {
                                name: "PrivateKeyInfo",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.OCTETSTRING,
                                constructed: !1,
                                capture: "privateKey"
                            }]
                        },
                        f = {
                            name: "RSAPrivateKey",
                            tagClass: a.Class.UNIVERSAL,
                            type: a.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "RSAPrivateKey.version",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.INTEGER,
                                constructed: !1,
                                capture: "privateKeyVersion"
                            }, {
                                name: "RSAPrivateKey.modulus",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.INTEGER,
                                constructed: !1,
                                capture: "privateKeyModulus"
                            }, {
                                name: "RSAPrivateKey.publicExponent",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.INTEGER,
                                constructed: !1,
                                capture: "privateKeyPublicExponent"
                            }, {
                                name: "RSAPrivateKey.privateExponent",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.INTEGER,
                                constructed: !1,
                                capture: "privateKeyPrivateExponent"
                            }, {
                                name: "RSAPrivateKey.prime1",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.INTEGER,
                                constructed: !1,
                                capture: "privateKeyPrime1"
                            }, {
                                name: "RSAPrivateKey.prime2",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.INTEGER,
                                constructed: !1,
                                capture: "privateKeyPrime2"
                            }, {
                                name: "RSAPrivateKey.exponent1",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.INTEGER,
                                constructed: !1,
                                capture: "privateKeyExponent1"
                            }, {
                                name: "RSAPrivateKey.exponent2",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.INTEGER,
                                constructed: !1,
                                capture: "privateKeyExponent2"
                            }, {
                                name: "RSAPrivateKey.coefficient",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.INTEGER,
                                constructed: !1,
                                capture: "privateKeyCoefficient"
                            }]
                        },
                        p = {
                            name: "RSAPublicKey",
                            tagClass: a.Class.UNIVERSAL,
                            type: a.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "RSAPublicKey.modulus",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.INTEGER,
                                constructed: !1,
                                capture: "publicKeyModulus"
                            }, {
                                name: "RSAPublicKey.exponent",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.INTEGER,
                                constructed: !1,
                                capture: "publicKeyExponent"
                            }]
                        },
                        d = n.pki.rsa.publicKeyValidator = {
                            name: "SubjectPublicKeyInfo",
                            tagClass: a.Class.UNIVERSAL,
                            type: a.Type.SEQUENCE,
                            constructed: !0,
                            captureAsn1: "subjectPublicKeyInfo",
                            value: [{
                                name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.SEQUENCE,
                                constructed: !0,
                                value: [{
                                    name: "AlgorithmIdentifier.algorithm",
                                    tagClass: a.Class.UNIVERSAL,
                                    type: a.Type.OID,
                                    constructed: !1,
                                    capture: "publicKeyOid"
                                }]
                            }, {
                                name: "SubjectPublicKeyInfo.subjectPublicKey",
                                tagClass: a.Class.UNIVERSAL,
                                type: a.Type.BITSTRING,
                                constructed: !1,
                                value: [{
                                    name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
                                    tagClass: a.Class.UNIVERSAL,
                                    type: a.Type.SEQUENCE,
                                    constructed: !0,
                                    optional: !0,
                                    captureAsn1: "rsaPublicKey"
                                }]
                            }]
                        },
                        g = function(t) {
                            var e;
                            if (!(t.algorithm in u.oids)) {
                                var r = new Error("Unknown message digest algorithm.");
                                throw r.algorithm = t.algorithm, r
                            }
                            e = u.oids[t.algorithm];
                            var n = a.oidToDer(e).getBytes(),
                                i = a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, !0, []),
                                s = a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, !0, []);
                            s.value.push(a.create(a.Class.UNIVERSAL, a.Type.OID, !1, n)), s.value.push(a.create(a.Class.UNIVERSAL, a.Type.NULL, !1, ""));
                            var o = a.create(a.Class.UNIVERSAL, a.Type.OCTETSTRING, !1, t.digest().getBytes());
                            return i.value.push(s), i.value.push(o), a.toDer(i).getBytes()
                        },
                        y = function(t, e, r) {
                            if (r) return t.modPow(e.e, e.n);
                            if (!e.p || !e.q) return t.modPow(e.d, e.n);
                            var s;
                            e.dP || (e.dP = e.d.mod(e.p.subtract(i.ONE))), e.dQ || (e.dQ = e.d.mod(e.q.subtract(i.ONE))), e.qInv || (e.qInv = e.q.modInverse(e.p));
                            do {
                                s = new i(n.util.bytesToHex(n.random.getBytes(e.n.bitLength() / 8)), 16)
                            } while (s.compareTo(e.n) >= 0 || !s.gcd(e.n).equals(i.ONE));
                            for (var a = (t = t.multiply(s.modPow(e.e, e.n)).mod(e.n)).mod(e.p).modPow(e.dP, e.p), o = t.mod(e.q).modPow(e.dQ, e.q); a.compareTo(o) < 0;) a = a.add(e.p);
                            var u = a.subtract(o).multiply(e.qInv).mod(e.p).multiply(e.q).add(o);
                            return u = u.multiply(s.modInverse(e.n)).mod(e.n)
                        };

                    function v(t, e, r) {
                        var i = n.util.createBuffer(),
                            s = Math.ceil(e.n.bitLength() / 8);
                        if (t.length > s - 11) {
                            var a = new Error("Message is too long for PKCS#1 v1.5 padding.");
                            throw a.length = t.length, a.max = s - 11, a
                        }
                        i.putByte(0), i.putByte(r);
                        var o, u = s - 3 - t.length;
                        if (0 === r || 1 === r) {
                            o = 0 === r ? 0 : 255;
                            for (var c = 0; c < u; ++c) i.putByte(o)
                        } else
                            for (; u > 0;) {
                                var h = 0,
                                    l = n.random.getBytes(u);
                                for (c = 0; c < u; ++c) 0 === (o = l.charCodeAt(c)) ? ++h : i.putByte(o);
                                u = h
                            }
                        return i.putByte(0), i.putBytes(t), i
                    }

                    function m(t, e, r, i) {
                        var s = Math.ceil(e.n.bitLength() / 8),
                            a = n.util.createBuffer(t),
                            o = a.getByte(),
                            u = a.getByte();
                        if (0 !== o || r && 0 !== u && 1 !== u || !r && 2 != u || r && 0 === u && void 0 === i) throw new Error("Encryption block is invalid.");
                        var c = 0;
                        if (0 === u) {
                            c = s - 3 - i;
                            for (var h = 0; h < c; ++h)
                                if (0 !== a.getByte()) throw new Error("Encryption block is invalid.")
                        } else if (1 === u)
                            for (c = 0; a.length() > 1;) {
                                if (255 !== a.getByte()) {
                                    --a.read;
                                    break
                                }++c
                            } else if (2 === u)
                                for (c = 0; a.length() > 1;) {
                                    if (0 === a.getByte()) {
                                        --a.read;
                                        break
                                    }++c
                                }
                        if (0 !== a.getByte() || c !== s - 3 - a.length()) throw new Error("Encryption block is invalid.");
                        return a.getBytes()
                    }

                    function E(t, e, r) {
                        "function" == typeof e && (r = e, e = {});
                        var s = {
                            algorithm: {
                                name: (e = e || {}).algorithm || "PRIMEINC",
                                options: {
                                    workers: e.workers || 2,
                                    workLoad: e.workLoad || 100,
                                    workerScript: e.workerScript
                                }
                            }
                        };

                        function a() {
                            o(t.pBits, (function(e, n) {
                                return e ? r(e) : (t.p = n, null !== t.q ? c(e, t.q) : void o(t.qBits, c))
                            }))
                        }

                        function o(t, e) {
                            n.prime.generateProbablePrime(t, s, e)
                        }

                        function c(e, n) {
                            if (e) return r(e);
                            if (t.q = n, t.p.compareTo(t.q) < 0) {
                                var s = t.p;
                                t.p = t.q, t.q = s
                            }
                            if (0 !== t.p.subtract(i.ONE).gcd(t.e).compareTo(i.ONE)) return t.p = null, void a();
                            if (0 !== t.q.subtract(i.ONE).gcd(t.e).compareTo(i.ONE)) return t.q = null, void o(t.qBits, c);
                            if (t.p1 = t.p.subtract(i.ONE), t.q1 = t.q.subtract(i.ONE), t.phi = t.p1.multiply(t.q1), 0 !== t.phi.gcd(t.e).compareTo(i.ONE)) return t.p = t.q = null, void a();
                            if (t.n = t.p.multiply(t.q), t.n.bitLength() !== t.bits) return t.q = null, void o(t.qBits, c);
                            var h = t.e.modInverse(t.phi);
                            t.keys = {
                                privateKey: u.rsa.setPrivateKey(t.n, t.e, h, t.p, t.q, h.mod(t.p1), h.mod(t.q1), t.q.modInverse(t.p)),
                                publicKey: u.rsa.setPublicKey(t.n, t.e)
                            }, r(null, t.keys)
                        }
                        "prng" in e && (s.prng = e.prng), a()
                    }

                    function S(t) {
                        var e = t.toString(16);
                        e[0] >= "8" && (e = "00" + e);
                        var r = n.util.hexToBytes(e);
                        return r.length > 1 && (0 === r.charCodeAt(0) && 0 == (128 & r.charCodeAt(1)) || 255 === r.charCodeAt(0) && 128 == (128 & r.charCodeAt(1))) ? r.substr(1) : r
                    }

                    function b(t) {
                        return t <= 100 ? 27 : t <= 150 ? 18 : t <= 200 ? 15 : t <= 250 ? 12 : t <= 300 ? 9 : t <= 350 ? 8 : t <= 400 ? 7 : t <= 500 ? 6 : t <= 600 ? 5 : t <= 800 ? 4 : t <= 1250 ? 3 : 2
                    }

                    function C(t) {
                        return n.util.isNodejs && "function" == typeof s[t]
                    }

                    function A(t) {
                        return void 0 !== o.globalScope && "object" === h(o.globalScope.crypto) && "object" === h(o.globalScope.crypto.subtle) && "function" == typeof o.globalScope.crypto.subtle[t]
                    }

                    function w(t) {
                        return void 0 !== o.globalScope && "object" === h(o.globalScope.msCrypto) && "object" === h(o.globalScope.msCrypto.subtle) && "function" == typeof o.globalScope.msCrypto.subtle[t]
                    }

                    function T(t) {
                        for (var e = n.util.hexToBytes(t.toString(16)), r = new Uint8Array(e.length), i = 0; i < e.length; ++i) r[i] = e.charCodeAt(i);
                        return r
                    }
                    u.rsa.encrypt = function(t, e, r) {
                        var s, a = r,
                            o = Math.ceil(e.n.bitLength() / 8);
                        !1 !== r && !0 !== r ? (a = 2 === r, s = v(t, e, r)) : (s = n.util.createBuffer()).putBytes(t);
                        for (var u = new i(s.toHex(), 16), c = y(u, e, a).toString(16), h = n.util.createBuffer(), l = o - Math.ceil(c.length / 2); l > 0;) h.putByte(0), --l;
                        return h.putBytes(n.util.hexToBytes(c)), h.getBytes()
                    }, u.rsa.decrypt = function(t, e, r, s) {
                        var a = Math.ceil(e.n.bitLength() / 8);
                        if (t.length !== a) {
                            var o = new Error("Encrypted message length is invalid.");
                            throw o.length = t.length, o.expected = a, o
                        }
                        var u = new i(n.util.createBuffer(t).toHex(), 16);
                        if (u.compareTo(e.n) >= 0) throw new Error("Encrypted message is invalid.");
                        for (var c = y(u, e, r).toString(16), h = n.util.createBuffer(), l = a - Math.ceil(c.length / 2); l > 0;) h.putByte(0), --l;
                        return h.putBytes(n.util.hexToBytes(c)), !1 !== s ? m(h.getBytes(), e, r) : h.getBytes()
                    }, u.rsa.createKeyPairGenerationState = function(t, e, r) {
                        "string" == typeof t && (t = parseInt(t, 10)), t = t || 2048;
                        var s, a = (r = r || {}).prng || n.random,
                            o = {
                                nextBytes: function(t) {
                                    for (var e = a.getBytesSync(t.length), r = 0; r < t.length; ++r) t[r] = e.charCodeAt(r)
                                }
                            },
                            u = r.algorithm || "PRIMEINC";
                        if ("PRIMEINC" !== u) throw new Error("Invalid key generation algorithm: " + u);
                        return (s = {
                            algorithm: u,
                            state: 0,
                            bits: t,
                            rng: o,
                            eInt: e || 65537,
                            e: new i(null),
                            p: null,
                            q: null,
                            qBits: t >> 1,
                            pBits: t - (t >> 1),
                            pqState: 0,
                            num: null,
                            keys: null
                        }).e.fromInt(s.eInt), s
                    }, u.rsa.stepKeyPairGenerationState = function(t, e) {
                        "algorithm" in t || (t.algorithm = "PRIMEINC");
                        var r = new i(null);
                        r.fromInt(30);
                        for (var n, s = 0, a = function(t, e) {
                                return t | e
                            }, o = +new Date, h = 0; null === t.keys && (e <= 0 || h < e);) {
                            if (0 === t.state) {
                                var l = null === t.p ? t.pBits : t.qBits,
                                    f = l - 1;
                                0 === t.pqState ? (t.num = new i(l, t.rng), t.num.testBit(f) || t.num.bitwiseTo(i.ONE.shiftLeft(f), a, t.num), t.num.dAddOffset(31 - t.num.mod(r).byteValue(), 0), s = 0, ++t.pqState) : 1 === t.pqState ? t.num.bitLength() > l ? t.pqState = 0 : t.num.isProbablePrime(b(t.num.bitLength())) ? ++t.pqState : t.num.dAddOffset(c[s++ % 8], 0) : 2 === t.pqState ? t.pqState = 0 === t.num.subtract(i.ONE).gcd(t.e).compareTo(i.ONE) ? 3 : 0 : 3 === t.pqState && (t.pqState = 0, null === t.p ? t.p = t.num : t.q = t.num, null !== t.p && null !== t.q && ++t.state, t.num = null)
                            } else if (1 === t.state) t.p.compareTo(t.q) < 0 && (t.num = t.p, t.p = t.q, t.q = t.num), ++t.state;
                            else if (2 === t.state) t.p1 = t.p.subtract(i.ONE), t.q1 = t.q.subtract(i.ONE), t.phi = t.p1.multiply(t.q1), ++t.state;
                            else if (3 === t.state) 0 === t.phi.gcd(t.e).compareTo(i.ONE) ? ++t.state : (t.p = null, t.q = null, t.state = 0);
                            else if (4 === t.state) t.n = t.p.multiply(t.q), t.n.bitLength() === t.bits ? ++t.state : (t.q = null, t.state = 0);
                            else if (5 === t.state) {
                                var p = t.e.modInverse(t.phi);
                                t.keys = {
                                    privateKey: u.rsa.setPrivateKey(t.n, t.e, p, t.p, t.q, p.mod(t.p1), p.mod(t.q1), t.q.modInverse(t.p)),
                                    publicKey: u.rsa.setPublicKey(t.n, t.e)
                                }
                            }
                            h += (n = +new Date) - o, o = n
                        }
                        return null !== t.keys
                    }, u.rsa.generateKeyPair = function(t, e, r, i) {
                        if (1 === arguments.length ? "object" === h(t) ? (r = t, t = void 0) : "function" == typeof t && (i = t, t = void 0) : 2 === arguments.length ? "number" == typeof t ? "function" == typeof e ? (i = e, e = void 0) : "number" != typeof e && (r = e, e = void 0) : (r = t, i = e, t = void 0, e = void 0) : 3 === arguments.length && ("number" == typeof e ? "function" == typeof r && (i = r, r = void 0) : (i = r, r = e, e = void 0)), r = r || {}, void 0 === t && (t = r.bits || 2048), void 0 === e && (e = r.e || 65537), !n.options.usePureJavaScript && !r.prng && t >= 256 && t <= 16384 && (65537 === e || 3 === e))
                            if (i) {
                                if (C("generateKeyPair")) return s.generateKeyPair("rsa", {
                                    modulusLength: t,
                                    publicExponent: e,
                                    publicKeyEncoding: {
                                        type: "spki",
                                        format: "pem"
                                    },
                                    privateKeyEncoding: {
                                        type: "pkcs8",
                                        format: "pem"
                                    }
                                }, (function(t, e, r) {
                                    if (t) return i(t);
                                    i(null, {
                                        privateKey: u.privateKeyFromPem(r),
                                        publicKey: u.publicKeyFromPem(e)
                                    })
                                }));
                                if (A("generateKey") && A("exportKey")) return o.globalScope.crypto.subtle.generateKey({
                                    name: "RSASSA-PKCS1-v1_5",
                                    modulusLength: t,
                                    publicExponent: T(e),
                                    hash: {
                                        name: "SHA-256"
                                    }
                                }, !0, ["sign", "verify"]).then((function(t) {
                                    return o.globalScope.crypto.subtle.exportKey("pkcs8", t.privateKey)
                                })).then(void 0, (function(t) {
                                    i(t)
                                })).then((function(t) {
                                    if (t) {
                                        var e = u.privateKeyFromAsn1(a.fromDer(n.util.createBuffer(t)));
                                        i(null, {
                                            privateKey: e,
                                            publicKey: u.setRsaPublicKey(e.n, e.e)
                                        })
                                    }
                                }));
                                if (w("generateKey") && w("exportKey")) {
                                    var c = o.globalScope.msCrypto.subtle.generateKey({
                                        name: "RSASSA-PKCS1-v1_5",
                                        modulusLength: t,
                                        publicExponent: T(e),
                                        hash: {
                                            name: "SHA-256"
                                        }
                                    }, !0, ["sign", "verify"]);
                                    return c.oncomplete = function(t) {
                                        var e = t.target.result,
                                            r = o.globalScope.msCrypto.subtle.exportKey("pkcs8", e.privateKey);
                                        r.oncomplete = function(t) {
                                            var e = t.target.result,
                                                r = u.privateKeyFromAsn1(a.fromDer(n.util.createBuffer(e)));
                                            i(null, {
                                                privateKey: r,
                                                publicKey: u.setRsaPublicKey(r.n, r.e)
                                            })
                                        }, r.onerror = function(t) {
                                            i(t)
                                        }
                                    }, void(c.onerror = function(t) {
                                        i(t)
                                    })
                                }
                            } else if (C("generateKeyPairSync")) {
                            var l = s.generateKeyPairSync("rsa", {
                                modulusLength: t,
                                publicExponent: e,
                                publicKeyEncoding: {
                                    type: "spki",
                                    format: "pem"
                                },
                                privateKeyEncoding: {
                                    type: "pkcs8",
                                    format: "pem"
                                }
                            });
                            return {
                                privateKey: u.privateKeyFromPem(l.privateKey),
                                publicKey: u.publicKeyFromPem(l.publicKey)
                            }
                        }
                        var f = u.rsa.createKeyPairGenerationState(t, e, r);
                        if (!i) return u.rsa.stepKeyPairGenerationState(f, 0), f.keys;
                        E(f, r, i)
                    }, u.setRsaPublicKey = u.rsa.setPublicKey = function(t, e) {
                        var r = {
                            n: t,
                            e: e,
                            encrypt: function(t, e, i) {
                                if ("string" == typeof e ? e = e.toUpperCase() : void 0 === e && (e = "RSAES-PKCS1-V1_5"), "RSAES-PKCS1-V1_5" === e) e = {
                                    encode: function(t, e, r) {
                                        return v(t, e, 2).getBytes()
                                    }
                                };
                                else if ("RSA-OAEP" === e || "RSAES-OAEP" === e) e = {
                                    encode: function(t, e) {
                                        return n.pkcs1.encode_rsa_oaep(e, t, i)
                                    }
                                };
                                else if (-1 !== ["RAW", "NONE", "NULL", null].indexOf(e)) e = {
                                    encode: function(t) {
                                        return t
                                    }
                                };
                                else if ("string" == typeof e) throw new Error('Unsupported encryption scheme: "' + e + '".');
                                var s = e.encode(t, r, !0);
                                return u.rsa.encrypt(s, r, !0)
                            },
                            verify: function(t, e, n) {
                                "string" == typeof n ? n = n.toUpperCase() : void 0 === n && (n = "RSASSA-PKCS1-V1_5"), "RSASSA-PKCS1-V1_5" === n ? n = {
                                    verify: function(t, e) {
                                        return e = m(e, r, !0), t === a.fromDer(e).value[1].value
                                    }
                                } : "NONE" !== n && "NULL" !== n && null !== n || (n = {
                                    verify: function(t, e) {
                                        return t === (e = m(e, r, !0))
                                    }
                                });
                                var i = u.rsa.decrypt(e, r, !0, !1);
                                return n.verify(t, i, r.n.bitLength())
                            }
                        };
                        return r
                    }, u.setRsaPrivateKey = u.rsa.setPrivateKey = function(t, e, r, i, s, a, o, c) {
                        var h = {
                            n: t,
                            e: e,
                            d: r,
                            p: i,
                            q: s,
                            dP: a,
                            dQ: o,
                            qInv: c,
                            decrypt: function(t, e, r) {
                                "string" == typeof e ? e = e.toUpperCase() : void 0 === e && (e = "RSAES-PKCS1-V1_5");
                                var i = u.rsa.decrypt(t, h, !1, !1);
                                if ("RSAES-PKCS1-V1_5" === e) e = {
                                    decode: m
                                };
                                else if ("RSA-OAEP" === e || "RSAES-OAEP" === e) e = {
                                    decode: function(t, e) {
                                        return n.pkcs1.decode_rsa_oaep(e, t, r)
                                    }
                                };
                                else {
                                    if (-1 === ["RAW", "NONE", "NULL", null].indexOf(e)) throw new Error('Unsupported encryption scheme: "' + e + '".');
                                    e = {
                                        decode: function(t) {
                                            return t
                                        }
                                    }
                                }
                                return e.decode(i, h, !1)
                            },
                            sign: function(t, e) {
                                var r = !1;
                                "string" == typeof e && (e = e.toUpperCase()), void 0 === e || "RSASSA-PKCS1-V1_5" === e ? (e = {
                                    encode: g
                                }, r = 1) : "NONE" !== e && "NULL" !== e && null !== e || (e = {
                                    encode: function() {
                                        return t
                                    }
                                }, r = 1);
                                var n = e.encode(t, h.n.bitLength());
                                return u.rsa.encrypt(n, h, r)
                            }
                        };
                        return h
                    }, u.wrapRsaPrivateKey = function(t) {
                        return a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, !0, [a.create(a.Class.UNIVERSAL, a.Type.INTEGER, !1, a.integerToDer(0).getBytes()), a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, !0, [a.create(a.Class.UNIVERSAL, a.Type.OID, !1, a.oidToDer(u.oids.rsaEncryption).getBytes()), a.create(a.Class.UNIVERSAL, a.Type.NULL, !1, "")]), a.create(a.Class.UNIVERSAL, a.Type.OCTETSTRING, !1, a.toDer(t).getBytes())])
                    }, u.privateKeyFromAsn1 = function(t) {
                        var e, r, s, o, c, h, p, d, g = {},
                            y = [];
                        if (a.validate(t, l, g, y) && (t = a.fromDer(n.util.createBuffer(g.privateKey))), g = {}, y = [], !a.validate(t, f, g, y)) {
                            var v = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
                            throw v.errors = y, v
                        }
                        return e = n.util.createBuffer(g.privateKeyModulus).toHex(), r = n.util.createBuffer(g.privateKeyPublicExponent).toHex(), s = n.util.createBuffer(g.privateKeyPrivateExponent).toHex(), o = n.util.createBuffer(g.privateKeyPrime1).toHex(), c = n.util.createBuffer(g.privateKeyPrime2).toHex(), h = n.util.createBuffer(g.privateKeyExponent1).toHex(), p = n.util.createBuffer(g.privateKeyExponent2).toHex(), d = n.util.createBuffer(g.privateKeyCoefficient).toHex(), u.setRsaPrivateKey(new i(e, 16), new i(r, 16), new i(s, 16), new i(o, 16), new i(c, 16), new i(h, 16), new i(p, 16), new i(d, 16))
                    }, u.privateKeyToAsn1 = u.privateKeyToRSAPrivateKey = function(t) {
                        return a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, !0, [a.create(a.Class.UNIVERSAL, a.Type.INTEGER, !1, a.integerToDer(0).getBytes()), a.create(a.Class.UNIVERSAL, a.Type.INTEGER, !1, S(t.n)), a.create(a.Class.UNIVERSAL, a.Type.INTEGER, !1, S(t.e)), a.create(a.Class.UNIVERSAL, a.Type.INTEGER, !1, S(t.d)), a.create(a.Class.UNIVERSAL, a.Type.INTEGER, !1, S(t.p)), a.create(a.Class.UNIVERSAL, a.Type.INTEGER, !1, S(t.q)), a.create(a.Class.UNIVERSAL, a.Type.INTEGER, !1, S(t.dP)), a.create(a.Class.UNIVERSAL, a.Type.INTEGER, !1, S(t.dQ)), a.create(a.Class.UNIVERSAL, a.Type.INTEGER, !1, S(t.qInv))])
                    }, u.publicKeyFromAsn1 = function(t) {
                        var e = {},
                            r = [];
                        if (a.validate(t, d, e, r) && (a.derToOid(e.publicKeyOid), t = e.rsaPublicKey), r = [], !a.validate(t, p, e, r)) {
                            var s = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
                            throw s.errors = r, s
                        }
                        var o = n.util.createBuffer(e.publicKeyModulus).toHex(),
                            c = n.util.createBuffer(e.publicKeyExponent).toHex();
                        return u.setRsaPublicKey(new i(o, 16), new i(c, 16))
                    }, u.publicKeyToAsn1 = u.publicKeyToSubjectPublicKeyInfo = function(t) {
                        return a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, !0, [a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, !0, [a.create(a.Class.UNIVERSAL, a.Type.OID, !1, a.oidToDer(u.oids.rsaEncryption).getBytes()), a.create(a.Class.UNIVERSAL, a.Type.NULL, !1, "")]), a.create(a.Class.UNIVERSAL, a.Type.BITSTRING, !1, [u.publicKeyToRSAPublicKey(t)])])
                    }, u.publicKeyToRSAPublicKey = function(t) {
                        return a.create(a.Class.UNIVERSAL, a.Type.SEQUENCE, !0, [a.create(a.Class.UNIVERSAL, a.Type.INTEGER, !1, S(t.n)), a.create(a.Class.UNIVERSAL, a.Type.INTEGER, !1, S(t.e))])
                    }
                }, function(t, e, r) {
                    var n, i = r(0);

                    function s(t, e, r) {
                        this.data = [], null != t && ("number" == typeof t ? this.fromNumber(t, e, r) : null == e && "string" != typeof t ? this.fromString(t, 256) : this.fromString(t, e))
                    }

                    function a() {
                        return new s(null)
                    }

                    function o(t, e, r, n, i, s) {
                        for (var a = 16383 & e, o = e >> 14; --s >= 0;) {
                            var u = 16383 & this.data[t],
                                c = this.data[t++] >> 14,
                                h = o * u + c * a;
                            i = ((u = a * u + ((16383 & h) << 14) + r.data[n] + i) >> 28) + (h >> 14) + o * c, r.data[n++] = 268435455 & u
                        }
                        return i
                    }
                    t.exports = i.jsbn = i.jsbn || {}, i.jsbn.BigInteger = s, "undefined" == typeof navigator ? (s.prototype.am = o, n = 28) : "Microsoft Internet Explorer" == navigator.appName ? (s.prototype.am = function(t, e, r, n, i, s) {
                        for (var a = 32767 & e, o = e >> 15; --s >= 0;) {
                            var u = 32767 & this.data[t],
                                c = this.data[t++] >> 15,
                                h = o * u + c * a;
                            i = ((u = a * u + ((32767 & h) << 15) + r.data[n] + (1073741823 & i)) >>> 30) + (h >>> 15) + o * c + (i >>> 30), r.data[n++] = 1073741823 & u
                        }
                        return i
                    }, n = 30) : "Netscape" != navigator.appName ? (s.prototype.am = function(t, e, r, n, i, s) {
                        for (; --s >= 0;) {
                            var a = e * this.data[t++] + r.data[n] + i;
                            i = Math.floor(a / 67108864), r.data[n++] = 67108863 & a
                        }
                        return i
                    }, n = 26) : (s.prototype.am = o, n = 28), s.prototype.DB = n, s.prototype.DM = (1 << n) - 1, s.prototype.DV = 1 << n, s.prototype.FV = Math.pow(2, 52), s.prototype.F1 = 52 - n, s.prototype.F2 = 2 * n - 52;
                    var u, c, h = new Array;
                    for (u = "0".charCodeAt(0), c = 0; c <= 9; ++c) h[u++] = c;
                    for (u = "a".charCodeAt(0), c = 10; c < 36; ++c) h[u++] = c;
                    for (u = "A".charCodeAt(0), c = 10; c < 36; ++c) h[u++] = c;

                    function l(t) {
                        return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(t)
                    }

                    function f(t, e) {
                        var r = h[t.charCodeAt(e)];
                        return null == r ? -1 : r
                    }

                    function p(t) {
                        var e = a();
                        return e.fromInt(t), e
                    }

                    function d(t) {
                        var e, r = 1;
                        return 0 != (e = t >>> 16) && (t = e, r += 16), 0 != (e = t >> 8) && (t = e, r += 8), 0 != (e = t >> 4) && (t = e, r += 4), 0 != (e = t >> 2) && (t = e, r += 2), 0 != (e = t >> 1) && (t = e, r += 1), r
                    }

                    function g(t) {
                        this.m = t
                    }

                    function y(t) {
                        this.m = t, this.mp = t.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << t.DB - 15) - 1, this.mt2 = 2 * t.t
                    }

                    function v(t, e) {
                        return t & e
                    }

                    function m(t, e) {
                        return t | e
                    }

                    function E(t, e) {
                        return t ^ e
                    }

                    function S(t, e) {
                        return t & ~e
                    }

                    function b(t) {
                        if (0 == t) return -1;
                        var e = 0;
                        return 0 == (65535 & t) && (t >>= 16, e += 16), 0 == (255 & t) && (t >>= 8, e += 8), 0 == (15 & t) && (t >>= 4, e += 4), 0 == (3 & t) && (t >>= 2, e += 2), 0 == (1 & t) && ++e, e
                    }

                    function C(t) {
                        for (var e = 0; 0 != t;) t &= t - 1, ++e;
                        return e
                    }

                    function A() {}

                    function w(t) {
                        return t
                    }

                    function T(t) {
                        this.r2 = a(), this.q3 = a(), s.ONE.dlShiftTo(2 * t.t, this.r2), this.mu = this.r2.divide(t), this.m = t
                    }
                    g.prototype.convert = function(t) {
                        return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t
                    }, g.prototype.revert = function(t) {
                        return t
                    }, g.prototype.reduce = function(t) {
                        t.divRemTo(this.m, null, t)
                    }, g.prototype.mulTo = function(t, e, r) {
                        t.multiplyTo(e, r), this.reduce(r)
                    }, g.prototype.sqrTo = function(t, e) {
                        t.squareTo(e), this.reduce(e)
                    }, y.prototype.convert = function(t) {
                        var e = a();
                        return t.abs().dlShiftTo(this.m.t, e), e.divRemTo(this.m, null, e), t.s < 0 && e.compareTo(s.ZERO) > 0 && this.m.subTo(e, e), e
                    }, y.prototype.revert = function(t) {
                        var e = a();
                        return t.copyTo(e), this.reduce(e), e
                    }, y.prototype.reduce = function(t) {
                        for (; t.t <= this.mt2;) t.data[t.t++] = 0;
                        for (var e = 0; e < this.m.t; ++e) {
                            var r = 32767 & t.data[e],
                                n = r * this.mpl + ((r * this.mph + (t.data[e] >> 15) * this.mpl & this.um) << 15) & t.DM;
                            for (r = e + this.m.t, t.data[r] += this.m.am(0, n, t, e, 0, this.m.t); t.data[r] >= t.DV;) t.data[r] -= t.DV, t.data[++r]++
                        }
                        t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t)
                    }, y.prototype.mulTo = function(t, e, r) {
                        t.multiplyTo(e, r), this.reduce(r)
                    }, y.prototype.sqrTo = function(t, e) {
                        t.squareTo(e), this.reduce(e)
                    }, s.prototype.copyTo = function(t) {
                        for (var e = this.t - 1; e >= 0; --e) t.data[e] = this.data[e];
                        t.t = this.t, t.s = this.s
                    }, s.prototype.fromInt = function(t) {
                        this.t = 1, this.s = t < 0 ? -1 : 0, t > 0 ? this.data[0] = t : t < -1 ? this.data[0] = t + this.DV : this.t = 0
                    }, s.prototype.fromString = function(t, e) {
                        var r;
                        if (16 == e) r = 4;
                        else if (8 == e) r = 3;
                        else if (256 == e) r = 8;
                        else if (2 == e) r = 1;
                        else if (32 == e) r = 5;
                        else {
                            if (4 != e) return void this.fromRadix(t, e);
                            r = 2
                        }
                        this.t = 0, this.s = 0;
                        for (var n = t.length, i = !1, a = 0; --n >= 0;) {
                            var o = 8 == r ? 255 & t[n] : f(t, n);
                            o < 0 ? "-" == t.charAt(n) && (i = !0) : (i = !1, 0 == a ? this.data[this.t++] = o : a + r > this.DB ? (this.data[this.t - 1] |= (o & (1 << this.DB - a) - 1) << a, this.data[this.t++] = o >> this.DB - a) : this.data[this.t - 1] |= o << a, (a += r) >= this.DB && (a -= this.DB))
                        }
                        8 == r && 0 != (128 & t[0]) && (this.s = -1, a > 0 && (this.data[this.t - 1] |= (1 << this.DB - a) - 1 << a)), this.clamp(), i && s.ZERO.subTo(this, this)
                    }, s.prototype.clamp = function() {
                        for (var t = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == t;) --this.t
                    }, s.prototype.dlShiftTo = function(t, e) {
                        var r;
                        for (r = this.t - 1; r >= 0; --r) e.data[r + t] = this.data[r];
                        for (r = t - 1; r >= 0; --r) e.data[r] = 0;
                        e.t = this.t + t, e.s = this.s
                    }, s.prototype.drShiftTo = function(t, e) {
                        for (var r = t; r < this.t; ++r) e.data[r - t] = this.data[r];
                        e.t = Math.max(this.t - t, 0), e.s = this.s
                    }, s.prototype.lShiftTo = function(t, e) {
                        var r, n = t % this.DB,
                            i = this.DB - n,
                            s = (1 << i) - 1,
                            a = Math.floor(t / this.DB),
                            o = this.s << n & this.DM;
                        for (r = this.t - 1; r >= 0; --r) e.data[r + a + 1] = this.data[r] >> i | o, o = (this.data[r] & s) << n;
                        for (r = a - 1; r >= 0; --r) e.data[r] = 0;
                        e.data[a] = o, e.t = this.t + a + 1, e.s = this.s, e.clamp()
                    }, s.prototype.rShiftTo = function(t, e) {
                        e.s = this.s;
                        var r = Math.floor(t / this.DB);
                        if (r >= this.t) e.t = 0;
                        else {
                            var n = t % this.DB,
                                i = this.DB - n,
                                s = (1 << n) - 1;
                            e.data[0] = this.data[r] >> n;
                            for (var a = r + 1; a < this.t; ++a) e.data[a - r - 1] |= (this.data[a] & s) << i, e.data[a - r] = this.data[a] >> n;
                            n > 0 && (e.data[this.t - r - 1] |= (this.s & s) << i), e.t = this.t - r, e.clamp()
                        }
                    }, s.prototype.subTo = function(t, e) {
                        for (var r = 0, n = 0, i = Math.min(t.t, this.t); r < i;) n += this.data[r] - t.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
                        if (t.t < this.t) {
                            for (n -= t.s; r < this.t;) n += this.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
                            n += this.s
                        } else {
                            for (n += this.s; r < t.t;) n -= t.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
                            n -= t.s
                        }
                        e.s = n < 0 ? -1 : 0, n < -1 ? e.data[r++] = this.DV + n : n > 0 && (e.data[r++] = n), e.t = r, e.clamp()
                    }, s.prototype.multiplyTo = function(t, e) {
                        var r = this.abs(),
                            n = t.abs(),
                            i = r.t;
                        for (e.t = i + n.t; --i >= 0;) e.data[i] = 0;
                        for (i = 0; i < n.t; ++i) e.data[i + r.t] = r.am(0, n.data[i], e, i, 0, r.t);
                        e.s = 0, e.clamp(), this.s != t.s && s.ZERO.subTo(e, e)
                    }, s.prototype.squareTo = function(t) {
                        for (var e = this.abs(), r = t.t = 2 * e.t; --r >= 0;) t.data[r] = 0;
                        for (r = 0; r < e.t - 1; ++r) {
                            var n = e.am(r, e.data[r], t, 2 * r, 0, 1);
                            (t.data[r + e.t] += e.am(r + 1, 2 * e.data[r], t, 2 * r + 1, n, e.t - r - 1)) >= e.DV && (t.data[r + e.t] -= e.DV, t.data[r + e.t + 1] = 1)
                        }
                        t.t > 0 && (t.data[t.t - 1] += e.am(r, e.data[r], t, 2 * r, 0, 1)), t.s = 0, t.clamp()
                    }, s.prototype.divRemTo = function(t, e, r) {
                        var n = t.abs();
                        if (!(n.t <= 0)) {
                            var i = this.abs();
                            if (i.t < n.t) return null != e && e.fromInt(0), void(null != r && this.copyTo(r));
                            null == r && (r = a());
                            var o = a(),
                                u = this.s,
                                c = t.s,
                                h = this.DB - d(n.data[n.t - 1]);
                            h > 0 ? (n.lShiftTo(h, o), i.lShiftTo(h, r)) : (n.copyTo(o), i.copyTo(r));
                            var l = o.t,
                                f = o.data[l - 1];
                            if (0 != f) {
                                var p = f * (1 << this.F1) + (l > 1 ? o.data[l - 2] >> this.F2 : 0),
                                    g = this.FV / p,
                                    y = (1 << this.F1) / p,
                                    v = 1 << this.F2,
                                    m = r.t,
                                    E = m - l,
                                    S = null == e ? a() : e;
                                for (o.dlShiftTo(E, S), r.compareTo(S) >= 0 && (r.data[r.t++] = 1, r.subTo(S, r)), s.ONE.dlShiftTo(l, S), S.subTo(o, o); o.t < l;) o.data[o.t++] = 0;
                                for (; --E >= 0;) {
                                    var b = r.data[--m] == f ? this.DM : Math.floor(r.data[m] * g + (r.data[m - 1] + v) * y);
                                    if ((r.data[m] += o.am(0, b, r, E, 0, l)) < b)
                                        for (o.dlShiftTo(E, S), r.subTo(S, r); r.data[m] < --b;) r.subTo(S, r)
                                }
                                null != e && (r.drShiftTo(l, e), u != c && s.ZERO.subTo(e, e)), r.t = l, r.clamp(), h > 0 && r.rShiftTo(h, r), u < 0 && s.ZERO.subTo(r, r)
                            }
                        }
                    }, s.prototype.invDigit = function() {
                        if (this.t < 1) return 0;
                        var t = this.data[0];
                        if (0 == (1 & t)) return 0;
                        var e = 3 & t;
                        return (e = (e = (e = (e = e * (2 - (15 & t) * e) & 15) * (2 - (255 & t) * e) & 255) * (2 - ((65535 & t) * e & 65535)) & 65535) * (2 - t * e % this.DV) % this.DV) > 0 ? this.DV - e : -e
                    }, s.prototype.isEven = function() {
                        return 0 == (this.t > 0 ? 1 & this.data[0] : this.s)
                    }, s.prototype.exp = function(t, e) {
                        if (t > 4294967295 || t < 1) return s.ONE;
                        var r = a(),
                            n = a(),
                            i = e.convert(this),
                            o = d(t) - 1;
                        for (i.copyTo(r); --o >= 0;)
                            if (e.sqrTo(r, n), (t & 1 << o) > 0) e.mulTo(n, i, r);
                            else {
                                var u = r;
                                r = n, n = u
                            }
                        return e.revert(r)
                    }, s.prototype.toString = function(t) {
                        if (this.s < 0) return "-" + this.negate().toString(t);
                        var e;
                        if (16 == t) e = 4;
                        else if (8 == t) e = 3;
                        else if (2 == t) e = 1;
                        else if (32 == t) e = 5;
                        else {
                            if (4 != t) return this.toRadix(t);
                            e = 2
                        }
                        var r, n = (1 << e) - 1,
                            i = !1,
                            s = "",
                            a = this.t,
                            o = this.DB - a * this.DB % e;
                        if (a-- > 0)
                            for (o < this.DB && (r = this.data[a] >> o) > 0 && (i = !0, s = l(r)); a >= 0;) o < e ? (r = (this.data[a] & (1 << o) - 1) << e - o, r |= this.data[--a] >> (o += this.DB - e)) : (r = this.data[a] >> (o -= e) & n, o <= 0 && (o += this.DB, --a)), r > 0 && (i = !0), i && (s += l(r));
                        return i ? s : "0"
                    }, s.prototype.negate = function() {
                        var t = a();
                        return s.ZERO.subTo(this, t), t
                    }, s.prototype.abs = function() {
                        return this.s < 0 ? this.negate() : this
                    }, s.prototype.compareTo = function(t) {
                        var e = this.s - t.s;
                        if (0 != e) return e;
                        var r = this.t;
                        if (0 != (e = r - t.t)) return this.s < 0 ? -e : e;
                        for (; --r >= 0;)
                            if (0 != (e = this.data[r] - t.data[r])) return e;
                        return 0
                    }, s.prototype.bitLength = function() {
                        return this.t <= 0 ? 0 : this.DB * (this.t - 1) + d(this.data[this.t - 1] ^ this.s & this.DM)
                    }, s.prototype.mod = function(t) {
                        var e = a();
                        return this.abs().divRemTo(t, null, e), this.s < 0 && e.compareTo(s.ZERO) > 0 && t.subTo(e, e), e
                    }, s.prototype.modPowInt = function(t, e) {
                        var r;
                        return r = t < 256 || e.isEven() ? new g(e) : new y(e), this.exp(t, r)
                    }, s.ZERO = p(0), s.ONE = p(1), A.prototype.convert = w, A.prototype.revert = w, A.prototype.mulTo = function(t, e, r) {
                        t.multiplyTo(e, r)
                    }, A.prototype.sqrTo = function(t, e) {
                        t.squareTo(e)
                    }, T.prototype.convert = function(t) {
                        if (t.s < 0 || t.t > 2 * this.m.t) return t.mod(this.m);
                        if (t.compareTo(this.m) < 0) return t;
                        var e = a();
                        return t.copyTo(e), this.reduce(e), e
                    }, T.prototype.revert = function(t) {
                        return t
                    }, T.prototype.reduce = function(t) {
                        for (t.drShiftTo(this.m.t - 1, this.r2), t.t > this.m.t + 1 && (t.t = this.m.t + 1, t.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t.compareTo(this.r2) < 0;) t.dAddOffset(1, this.m.t + 1);
                        for (t.subTo(this.r2, t); t.compareTo(this.m) >= 0;) t.subTo(this.m, t)
                    }, T.prototype.mulTo = function(t, e, r) {
                        t.multiplyTo(e, r), this.reduce(r)
                    }, T.prototype.sqrTo = function(t, e) {
                        t.squareTo(e), this.reduce(e)
                    };
                    var x = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509],
                        I = (1 << 26) / x[x.length - 1];
                    s.prototype.chunkSize = function(t) {
                        return Math.floor(Math.LN2 * this.DB / Math.log(t))
                    }, s.prototype.toRadix = function(t) {
                        if (null == t && (t = 10), 0 == this.signum() || t < 2 || t > 36) return "0";
                        var e = this.chunkSize(t),
                            r = Math.pow(t, e),
                            n = p(r),
                            i = a(),
                            s = a(),
                            o = "";
                        for (this.divRemTo(n, i, s); i.signum() > 0;) o = (r + s.intValue()).toString(t).substr(1) + o, i.divRemTo(n, i, s);
                        return s.intValue().toString(t) + o
                    }, s.prototype.fromRadix = function(t, e) {
                        this.fromInt(0), null == e && (e = 10);
                        for (var r = this.chunkSize(e), n = Math.pow(e, r), i = !1, a = 0, o = 0, u = 0; u < t.length; ++u) {
                            var c = f(t, u);
                            c < 0 ? "-" == t.charAt(u) && 0 == this.signum() && (i = !0) : (o = e * o + c, ++a >= r && (this.dMultiply(n), this.dAddOffset(o, 0), a = 0, o = 0))
                        }
                        a > 0 && (this.dMultiply(Math.pow(e, a)), this.dAddOffset(o, 0)), i && s.ZERO.subTo(this, this)
                    }, s.prototype.fromNumber = function(t, e, r) {
                        if ("number" == typeof e)
                            if (t < 2) this.fromInt(1);
                            else
                                for (this.fromNumber(t, r), this.testBit(t - 1) || this.bitwiseTo(s.ONE.shiftLeft(t - 1), m, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e);) this.dAddOffset(2, 0), this.bitLength() > t && this.subTo(s.ONE.shiftLeft(t - 1), this);
                        else {
                            var n = new Array,
                                i = 7 & t;
                            n.length = 1 + (t >> 3), e.nextBytes(n), i > 0 ? n[0] &= (1 << i) - 1 : n[0] = 0, this.fromString(n, 256)
                        }
                    }, s.prototype.bitwiseTo = function(t, e, r) {
                        var n, i, s = Math.min(t.t, this.t);
                        for (n = 0; n < s; ++n) r.data[n] = e(this.data[n], t.data[n]);
                        if (t.t < this.t) {
                            for (i = t.s & this.DM, n = s; n < this.t; ++n) r.data[n] = e(this.data[n], i);
                            r.t = this.t
                        } else {
                            for (i = this.s & this.DM, n = s; n < t.t; ++n) r.data[n] = e(i, t.data[n]);
                            r.t = t.t
                        }
                        r.s = e(this.s, t.s), r.clamp()
                    }, s.prototype.changeBit = function(t, e) {
                        var r = s.ONE.shiftLeft(t);
                        return this.bitwiseTo(r, e, r), r
                    }, s.prototype.addTo = function(t, e) {
                        for (var r = 0, n = 0, i = Math.min(t.t, this.t); r < i;) n += this.data[r] + t.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
                        if (t.t < this.t) {
                            for (n += t.s; r < this.t;) n += this.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
                            n += this.s
                        } else {
                            for (n += this.s; r < t.t;) n += t.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
                            n += t.s
                        }
                        e.s = n < 0 ? -1 : 0, n > 0 ? e.data[r++] = n : n < -1 && (e.data[r++] = this.DV + n), e.t = r, e.clamp()
                    }, s.prototype.dMultiply = function(t) {
                        this.data[this.t] = this.am(0, t - 1, this, 0, 0, this.t), ++this.t, this.clamp()
                    }, s.prototype.dAddOffset = function(t, e) {
                        if (0 != t) {
                            for (; this.t <= e;) this.data[this.t++] = 0;
                            for (this.data[e] += t; this.data[e] >= this.DV;) this.data[e] -= this.DV, ++e >= this.t && (this.data[this.t++] = 0), ++this.data[e]
                        }
                    }, s.prototype.multiplyLowerTo = function(t, e, r) {
                        var n, i = Math.min(this.t + t.t, e);
                        for (r.s = 0, r.t = i; i > 0;) r.data[--i] = 0;
                        for (n = r.t - this.t; i < n; ++i) r.data[i + this.t] = this.am(0, t.data[i], r, i, 0, this.t);
                        for (n = Math.min(t.t, e); i < n; ++i) this.am(0, t.data[i], r, i, 0, e - i);
                        r.clamp()
                    }, s.prototype.multiplyUpperTo = function(t, e, r) {
                        --e;
                        var n = r.t = this.t + t.t - e;
                        for (r.s = 0; --n >= 0;) r.data[n] = 0;
                        for (n = Math.max(e - this.t, 0); n < t.t; ++n) r.data[this.t + n - e] = this.am(e - n, t.data[n], r, 0, 0, this.t + n - e);
                        r.clamp(), r.drShiftTo(1, r)
                    }, s.prototype.modInt = function(t) {
                        if (t <= 0) return 0;
                        var e = this.DV % t,
                            r = this.s < 0 ? t - 1 : 0;
                        if (this.t > 0)
                            if (0 == e) r = this.data[0] % t;
                            else
                                for (var n = this.t - 1; n >= 0; --n) r = (e * r + this.data[n]) % t;
                        return r
                    }, s.prototype.millerRabin = function(t) {
                        var e = this.subtract(s.ONE),
                            r = e.getLowestSetBit();
                        if (r <= 0) return !1;
                        for (var n, i = e.shiftRight(r), a = {
                                nextBytes: function(t) {
                                    for (var e = 0; e < t.length; ++e) t[e] = Math.floor(256 * Math.random())
                                }
                            }, o = 0; o < t; ++o) {
                            do {
                                n = new s(this.bitLength(), a)
                            } while (n.compareTo(s.ONE) <= 0 || n.compareTo(e) >= 0);
                            var u = n.modPow(i, this);
                            if (0 != u.compareTo(s.ONE) && 0 != u.compareTo(e)) {
                                for (var c = 1; c++ < r && 0 != u.compareTo(e);)
                                    if (0 == (u = u.modPowInt(2, this)).compareTo(s.ONE)) return !1;
                                if (0 != u.compareTo(e)) return !1
                            }
                        }
                        return !0
                    }, s.prototype.clone = function() {
                        var t = a();
                        return this.copyTo(t), t
                    }, s.prototype.intValue = function() {
                        if (this.s < 0) {
                            if (1 == this.t) return this.data[0] - this.DV;
                            if (0 == this.t) return -1
                        } else {
                            if (1 == this.t) return this.data[0];
                            if (0 == this.t) return 0
                        }
                        return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0]
                    }, s.prototype.byteValue = function() {
                        return 0 == this.t ? this.s : this.data[0] << 24 >> 24
                    }, s.prototype.shortValue = function() {
                        return 0 == this.t ? this.s : this.data[0] << 16 >> 16
                    }, s.prototype.signum = function() {
                        return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this.data[0] <= 0 ? 0 : 1
                    }, s.prototype.toByteArray = function() {
                        var t = this.t,
                            e = new Array;
                        e[0] = this.s;
                        var r, n = this.DB - t * this.DB % 8,
                            i = 0;
                        if (t-- > 0)
                            for (n < this.DB && (r = this.data[t] >> n) != (this.s & this.DM) >> n && (e[i++] = r | this.s << this.DB - n); t >= 0;) n < 8 ? (r = (this.data[t] & (1 << n) - 1) << 8 - n, r |= this.data[--t] >> (n += this.DB - 8)) : (r = this.data[t] >> (n -= 8) & 255, n <= 0 && (n += this.DB, --t)), 0 != (128 & r) && (r |= -256), 0 == i && (128 & this.s) != (128 & r) && ++i, (i > 0 || r != this.s) && (e[i++] = r);
                        return e
                    }, s.prototype.equals = function(t) {
                        return 0 == this.compareTo(t)
                    }, s.prototype.min = function(t) {
                        return this.compareTo(t) < 0 ? this : t
                    }, s.prototype.max = function(t) {
                        return this.compareTo(t) > 0 ? this : t
                    }, s.prototype.and = function(t) {
                        var e = a();
                        return this.bitwiseTo(t, v, e), e
                    }, s.prototype.or = function(t) {
                        var e = a();
                        return this.bitwiseTo(t, m, e), e
                    }, s.prototype.xor = function(t) {
                        var e = a();
                        return this.bitwiseTo(t, E, e), e
                    }, s.prototype.andNot = function(t) {
                        var e = a();
                        return this.bitwiseTo(t, S, e), e
                    }, s.prototype.not = function() {
                        for (var t = a(), e = 0; e < this.t; ++e) t.data[e] = this.DM & ~this.data[e];
                        return t.t = this.t, t.s = ~this.s, t
                    }, s.prototype.shiftLeft = function(t) {
                        var e = a();
                        return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e), e
                    }, s.prototype.shiftRight = function(t) {
                        var e = a();
                        return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e), e
                    }, s.prototype.getLowestSetBit = function() {
                        for (var t = 0; t < this.t; ++t)
                            if (0 != this.data[t]) return t * this.DB + b(this.data[t]);
                        return this.s < 0 ? this.t * this.DB : -1
                    }, s.prototype.bitCount = function() {
                        for (var t = 0, e = this.s & this.DM, r = 0; r < this.t; ++r) t += C(this.data[r] ^ e);
                        return t
                    }, s.prototype.testBit = function(t) {
                        var e = Math.floor(t / this.DB);
                        return e >= this.t ? 0 != this.s : 0 != (this.data[e] & 1 << t % this.DB)
                    }, s.prototype.setBit = function(t) {
                        return this.changeBit(t, m)
                    }, s.prototype.clearBit = function(t) {
                        return this.changeBit(t, S)
                    }, s.prototype.flipBit = function(t) {
                        return this.changeBit(t, E)
                    }, s.prototype.add = function(t) {
                        var e = a();
                        return this.addTo(t, e), e
                    }, s.prototype.subtract = function(t) {
                        var e = a();
                        return this.subTo(t, e), e
                    }, s.prototype.multiply = function(t) {
                        var e = a();
                        return this.multiplyTo(t, e), e
                    }, s.prototype.divide = function(t) {
                        var e = a();
                        return this.divRemTo(t, e, null), e
                    }, s.prototype.remainder = function(t) {
                        var e = a();
                        return this.divRemTo(t, null, e), e
                    }, s.prototype.divideAndRemainder = function(t) {
                        var e = a(),
                            r = a();
                        return this.divRemTo(t, e, r), new Array(e, r)
                    }, s.prototype.modPow = function(t, e) {
                        var r, n, i = t.bitLength(),
                            s = p(1);
                        if (i <= 0) return s;
                        r = i < 18 ? 1 : i < 48 ? 3 : i < 144 ? 4 : i < 768 ? 5 : 6, n = i < 8 ? new g(e) : e.isEven() ? new T(e) : new y(e);
                        var o = new Array,
                            u = 3,
                            c = r - 1,
                            h = (1 << r) - 1;
                        if (o[1] = n.convert(this), r > 1) {
                            var l = a();
                            for (n.sqrTo(o[1], l); u <= h;) o[u] = a(), n.mulTo(l, o[u - 2], o[u]), u += 2
                        }
                        var f, v, m = t.t - 1,
                            E = !0,
                            S = a();
                        for (i = d(t.data[m]) - 1; m >= 0;) {
                            for (i >= c ? f = t.data[m] >> i - c & h : (f = (t.data[m] & (1 << i + 1) - 1) << c - i, m > 0 && (f |= t.data[m - 1] >> this.DB + i - c)), u = r; 0 == (1 & f);) f >>= 1, --u;
                            if ((i -= u) < 0 && (i += this.DB, --m), E) o[f].copyTo(s), E = !1;
                            else {
                                for (; u > 1;) n.sqrTo(s, S), n.sqrTo(S, s), u -= 2;
                                u > 0 ? n.sqrTo(s, S) : (v = s, s = S, S = v), n.mulTo(S, o[f], s)
                            }
                            for (; m >= 0 && 0 == (t.data[m] & 1 << i);) n.sqrTo(s, S), v = s, s = S, S = v, --i < 0 && (i = this.DB - 1, --m)
                        }
                        return n.revert(s)
                    }, s.prototype.modInverse = function(t) {
                        var e = t.isEven();
                        if (this.isEven() && e || 0 == t.signum()) return s.ZERO;
                        for (var r = t.clone(), n = this.clone(), i = p(1), a = p(0), o = p(0), u = p(1); 0 != r.signum();) {
                            for (; r.isEven();) r.rShiftTo(1, r), e ? (i.isEven() && a.isEven() || (i.addTo(this, i), a.subTo(t, a)), i.rShiftTo(1, i)) : a.isEven() || a.subTo(t, a), a.rShiftTo(1, a);
                            for (; n.isEven();) n.rShiftTo(1, n), e ? (o.isEven() && u.isEven() || (o.addTo(this, o), u.subTo(t, u)), o.rShiftTo(1, o)) : u.isEven() || u.subTo(t, u), u.rShiftTo(1, u);
                            r.compareTo(n) >= 0 ? (r.subTo(n, r), e && i.subTo(o, i), a.subTo(u, a)) : (n.subTo(r, n), e && o.subTo(i, o), u.subTo(a, u))
                        }
                        return 0 != n.compareTo(s.ONE) ? s.ZERO : u.compareTo(t) >= 0 ? u.subtract(t) : u.signum() < 0 ? (u.addTo(t, u), u.signum() < 0 ? u.add(t) : u) : u
                    }, s.prototype.pow = function(t) {
                        return this.exp(t, new A)
                    }, s.prototype.gcd = function(t) {
                        var e = this.s < 0 ? this.negate() : this.clone(),
                            r = t.s < 0 ? t.negate() : t.clone();
                        if (e.compareTo(r) < 0) {
                            var n = e;
                            e = r, r = n
                        }
                        var i = e.getLowestSetBit(),
                            s = r.getLowestSetBit();
                        if (s < 0) return e;
                        for (i < s && (s = i), s > 0 && (e.rShiftTo(s, e), r.rShiftTo(s, r)); e.signum() > 0;)(i = e.getLowestSetBit()) > 0 && e.rShiftTo(i, e), (i = r.getLowestSetBit()) > 0 && r.rShiftTo(i, r), e.compareTo(r) >= 0 ? (e.subTo(r, e), e.rShiftTo(1, e)) : (r.subTo(e, r), r.rShiftTo(1, r));
                        return s > 0 && r.lShiftTo(s, r), r
                    }, s.prototype.isProbablePrime = function(t) {
                        var e, r = this.abs();
                        if (1 == r.t && r.data[0] <= x[x.length - 1]) {
                            for (e = 0; e < x.length; ++e)
                                if (r.data[0] == x[e]) return !0;
                            return !1
                        }
                        if (r.isEven()) return !1;
                        for (e = 1; e < x.length;) {
                            for (var n = x[e], i = e + 1; i < x.length && n < I;) n *= x[i++];
                            for (n = r.modInt(n); e < i;)
                                if (n % x[e++] == 0) return !1
                        }
                        return r.millerRabin(t)
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(1), t.exports = n.cipher = n.cipher || {}, n.cipher.algorithms = n.cipher.algorithms || {}, n.cipher.createCipher = function(t, e) {
                        var r = t;
                        if ("string" == typeof r && (r = n.cipher.getAlgorithm(r)) && (r = r()), !r) throw new Error("Unsupported algorithm: " + t);
                        return new n.cipher.BlockCipher({
                            algorithm: r,
                            key: e,
                            decrypt: !1
                        })
                    }, n.cipher.createDecipher = function(t, e) {
                        var r = t;
                        if ("string" == typeof r && (r = n.cipher.getAlgorithm(r)) && (r = r()), !r) throw new Error("Unsupported algorithm: " + t);
                        return new n.cipher.BlockCipher({
                            algorithm: r,
                            key: e,
                            decrypt: !0
                        })
                    }, n.cipher.registerAlgorithm = function(t, e) {
                        t = t.toUpperCase(), n.cipher.algorithms[t] = e
                    }, n.cipher.getAlgorithm = function(t) {
                        return (t = t.toUpperCase()) in n.cipher.algorithms ? n.cipher.algorithms[t] : null
                    };
                    var i = n.cipher.BlockCipher = function(t) {
                        this.algorithm = t.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = !1, this._input = null, this.output = null, this._op = t.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = t.decrypt, this.algorithm.initialize(t)
                    };
                    i.prototype.start = function(t) {
                        t = t || {};
                        var e = {};
                        for (var r in t) e[r] = t[r];
                        e.decrypt = this._decrypt, this._finish = !1, this._input = n.util.createBuffer(), this.output = t.output || n.util.createBuffer(), this.mode.start(e)
                    }, i.prototype.update = function(t) {
                        for (t && this._input.putBuffer(t); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish;);
                        this._input.compact()
                    }, i.prototype.finish = function(t) {
                        !t || "ECB" !== this.mode.name && "CBC" !== this.mode.name || (this.mode.pad = function(e) {
                            return t(this.blockSize, e, !1)
                        }, this.mode.unpad = function(e) {
                            return t(this.blockSize, e, !0)
                        });
                        var e = {};
                        return e.decrypt = this._decrypt, e.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, e) || (this._finish = !0, this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, e) || this.mode.afterFinish && !this.mode.afterFinish(this.output, e)))
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(4), r(1);
                    var i = t.exports = n.md5 = n.md5 || {};
                    n.md.md5 = n.md.algorithms.md5 = i, i.create = function() {
                        c || function() {
                            s = String.fromCharCode(128), s += n.util.fillString(String.fromCharCode(0), 64), a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9], o = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21], u = new Array(64);
                            for (var t = 0; t < 64; ++t) u[t] = Math.floor(4294967296 * Math.abs(Math.sin(t + 1)));
                            c = !0
                        }();
                        var t = null,
                            e = n.util.createBuffer(),
                            r = new Array(16),
                            i = {
                                algorithm: "md5",
                                blockLength: 64,
                                digestLength: 16,
                                messageLength: 0,
                                fullMessageLength: null,
                                messageLengthSize: 8,
                                start: function() {
                                    i.messageLength = 0, i.fullMessageLength = i.messageLength64 = [];
                                    for (var r = i.messageLengthSize / 4, s = 0; s < r; ++s) i.fullMessageLength.push(0);
                                    return e = n.util.createBuffer(), t = {
                                        h0: 1732584193,
                                        h1: 4023233417,
                                        h2: 2562383102,
                                        h3: 271733878
                                    }, i
                                }
                            };
                        return i.start(), i.update = function(s, a) {
                            "utf8" === a && (s = n.util.encodeUtf8(s));
                            var o = s.length;
                            i.messageLength += o, o = [o / 4294967296 >>> 0, o >>> 0];
                            for (var u = i.fullMessageLength.length - 1; u >= 0; --u) i.fullMessageLength[u] += o[1], o[1] = o[0] + (i.fullMessageLength[u] / 4294967296 >>> 0), i.fullMessageLength[u] = i.fullMessageLength[u] >>> 0, o[0] = o[1] / 4294967296 >>> 0;
                            return e.putBytes(s), h(t, r, e), (e.read > 2048 || 0 === e.length()) && e.compact(), i
                        }, i.digest = function() {
                            var a = n.util.createBuffer();
                            a.putBytes(e.bytes());
                            var o = i.fullMessageLength[i.fullMessageLength.length - 1] + i.messageLengthSize & i.blockLength - 1;
                            a.putBytes(s.substr(0, i.blockLength - o));
                            for (var u, c = 0, l = i.fullMessageLength.length - 1; l >= 0; --l) c = (u = 8 * i.fullMessageLength[l] + c) / 4294967296 >>> 0, a.putInt32Le(u >>> 0);
                            var f = {
                                h0: t.h0,
                                h1: t.h1,
                                h2: t.h2,
                                h3: t.h3
                            };
                            h(f, r, a);
                            var p = n.util.createBuffer();
                            return p.putInt32Le(f.h0), p.putInt32Le(f.h1), p.putInt32Le(f.h2), p.putInt32Le(f.h3), p
                        }, i
                    };
                    var s = null,
                        a = null,
                        o = null,
                        u = null,
                        c = !1;

                    function h(t, e, r) {
                        for (var n, i, s, c, h, l, f, p = r.length(); p >= 64;) {
                            for (i = t.h0, s = t.h1, c = t.h2, h = t.h3, f = 0; f < 16; ++f) e[f] = r.getInt32Le(), n = i + (h ^ s & (c ^ h)) + u[f] + e[f], i = h, h = c, c = s, s += n << (l = o[f]) | n >>> 32 - l;
                            for (; f < 32; ++f) n = i + (c ^ h & (s ^ c)) + u[f] + e[a[f]], i = h, h = c, c = s, s += n << (l = o[f]) | n >>> 32 - l;
                            for (; f < 48; ++f) n = i + (s ^ c ^ h) + u[f] + e[a[f]], i = h, h = c, c = s, s += n << (l = o[f]) | n >>> 32 - l;
                            for (; f < 64; ++f) n = i + (c ^ (s | ~h)) + u[f] + e[a[f]], i = h, h = c, c = s, s += n << (l = o[f]) | n >>> 32 - l;
                            t.h0 = t.h0 + i | 0, t.h1 = t.h1 + s | 0, t.h2 = t.h2 + c | 0, t.h3 = t.h3 + h | 0, p -= 64
                        }
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(8), r(4), r(1);
                    var s, a = n.pkcs5 = n.pkcs5 || {};
                    n.util.isNodejs && !n.options.usePureJavaScript && (s = r(16)), t.exports = n.pbkdf2 = a.pbkdf2 = function(t, e, r, a, o, u) {
                        if ("function" == typeof o && (u = o, o = null), n.util.isNodejs && !n.options.usePureJavaScript && s.pbkdf2 && (null === o || "object" !== h(o)) && (s.pbkdf2Sync.length > 4 || !o || "sha1" === o)) return "string" != typeof o && (o = "sha1"), t = i.from(t, "binary"), e = i.from(e, "binary"), u ? 4 === s.pbkdf2Sync.length ? s.pbkdf2(t, e, r, a, (function(t, e) {
                            if (t) return u(t);
                            u(null, e.toString("binary"))
                        })) : s.pbkdf2(t, e, r, a, o, (function(t, e) {
                            if (t) return u(t);
                            u(null, e.toString("binary"))
                        })) : 4 === s.pbkdf2Sync.length ? s.pbkdf2Sync(t, e, r, a).toString("binary") : s.pbkdf2Sync(t, e, r, a, o).toString("binary");
                        if (null == o && (o = "sha1"), "string" == typeof o) {
                            if (!(o in n.md.algorithms)) throw new Error("Unknown hash algorithm: " + o);
                            o = n.md[o].create()
                        }
                        var c = o.digestLength;
                        if (a > 4294967295 * c) {
                            var l = new Error("Derived key is too long.");
                            if (u) return u(l);
                            throw l
                        }
                        var f = Math.ceil(a / c),
                            p = a - (f - 1) * c,
                            d = n.hmac.create();
                        d.start(o, t);
                        var g, y, v, m = "";
                        if (!u) {
                            for (var E = 1; E <= f; ++E) {
                                d.start(null, null), d.update(e), d.update(n.util.int32ToBytes(E)), g = v = d.digest().getBytes();
                                for (var S = 2; S <= r; ++S) d.start(null, null), d.update(v), y = d.digest().getBytes(), g = n.util.xorBytes(g, y, c), v = y;
                                m += E < f ? g : g.substr(0, p)
                            }
                            return m
                        }

                        function b() {
                            if (E > f) return u(null, m);
                            d.start(null, null), d.update(e), d.update(n.util.int32ToBytes(E)), g = v = d.digest().getBytes(), S = 2, C()
                        }

                        function C() {
                            if (S <= r) return d.start(null, null), d.update(v), y = d.digest().getBytes(), g = n.util.xorBytes(g, y, c), v = y, ++S, n.util.setImmediate(C);
                            m += E < f ? g : g.substr(0, p), ++E, b()
                        }
                        E = 1, b()
                    }
                }, function(t, e) {}, function(t, e, r) {
                    var n = r(0);
                    r(5), r(3), r(10), r(4), r(39), r(6), r(7), r(18), r(11), r(1);
                    var i = n.asn1,
                        s = t.exports = n.pki = n.pki || {},
                        a = s.oids,
                        o = {};
                    o.CN = a.commonName, o.commonName = "CN", o.C = a.countryName, o.countryName = "C", o.L = a.localityName, o.localityName = "L", o.ST = a.stateOrProvinceName, o.stateOrProvinceName = "ST", o.O = a.organizationName, o.organizationName = "O", o.OU = a.organizationalUnitName, o.organizationalUnitName = "OU", o.E = a.emailAddress, o.emailAddress = "E";
                    var u = n.pki.rsa.publicKeyValidator,
                        c = {
                            name: "Certificate",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "Certificate.TBSCertificate",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.SEQUENCE,
                                constructed: !0,
                                captureAsn1: "tbsCertificate",
                                value: [{
                                    name: "Certificate.TBSCertificate.version",
                                    tagClass: i.Class.CONTEXT_SPECIFIC,
                                    type: 0,
                                    constructed: !0,
                                    optional: !0,
                                    value: [{
                                        name: "Certificate.TBSCertificate.version.integer",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.INTEGER,
                                        constructed: !1,
                                        capture: "certVersion"
                                    }]
                                }, {
                                    name: "Certificate.TBSCertificate.serialNumber",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Type.INTEGER,
                                    constructed: !1,
                                    capture: "certSerialNumber"
                                }, {
                                    name: "Certificate.TBSCertificate.signature",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Type.SEQUENCE,
                                    constructed: !0,
                                    value: [{
                                        name: "Certificate.TBSCertificate.signature.algorithm",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.OID,
                                        constructed: !1,
                                        capture: "certinfoSignatureOid"
                                    }, {
                                        name: "Certificate.TBSCertificate.signature.parameters",
                                        tagClass: i.Class.UNIVERSAL,
                                        optional: !0,
                                        captureAsn1: "certinfoSignatureParams"
                                    }]
                                }, {
                                    name: "Certificate.TBSCertificate.issuer",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Type.SEQUENCE,
                                    constructed: !0,
                                    captureAsn1: "certIssuer"
                                }, {
                                    name: "Certificate.TBSCertificate.validity",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Type.SEQUENCE,
                                    constructed: !0,
                                    value: [{
                                        name: "Certificate.TBSCertificate.validity.notBefore (utc)",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.UTCTIME,
                                        constructed: !1,
                                        optional: !0,
                                        capture: "certValidity1UTCTime"
                                    }, {
                                        name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.GENERALIZEDTIME,
                                        constructed: !1,
                                        optional: !0,
                                        capture: "certValidity2GeneralizedTime"
                                    }, {
                                        name: "Certificate.TBSCertificate.validity.notAfter (utc)",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.UTCTIME,
                                        constructed: !1,
                                        optional: !0,
                                        capture: "certValidity3UTCTime"
                                    }, {
                                        name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.GENERALIZEDTIME,
                                        constructed: !1,
                                        optional: !0,
                                        capture: "certValidity4GeneralizedTime"
                                    }]
                                }, {
                                    name: "Certificate.TBSCertificate.subject",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Type.SEQUENCE,
                                    constructed: !0,
                                    captureAsn1: "certSubject"
                                }, u, {
                                    name: "Certificate.TBSCertificate.issuerUniqueID",
                                    tagClass: i.Class.CONTEXT_SPECIFIC,
                                    type: 1,
                                    constructed: !0,
                                    optional: !0,
                                    value: [{
                                        name: "Certificate.TBSCertificate.issuerUniqueID.id",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.BITSTRING,
                                        constructed: !1,
                                        captureBitStringValue: "certIssuerUniqueId"
                                    }]
                                }, {
                                    name: "Certificate.TBSCertificate.subjectUniqueID",
                                    tagClass: i.Class.CONTEXT_SPECIFIC,
                                    type: 2,
                                    constructed: !0,
                                    optional: !0,
                                    value: [{
                                        name: "Certificate.TBSCertificate.subjectUniqueID.id",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.BITSTRING,
                                        constructed: !1,
                                        captureBitStringValue: "certSubjectUniqueId"
                                    }]
                                }, {
                                    name: "Certificate.TBSCertificate.extensions",
                                    tagClass: i.Class.CONTEXT_SPECIFIC,
                                    type: 3,
                                    constructed: !0,
                                    captureAsn1: "certExtensions",
                                    optional: !0
                                }]
                            }, {
                                name: "Certificate.signatureAlgorithm",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.SEQUENCE,
                                constructed: !0,
                                value: [{
                                    name: "Certificate.signatureAlgorithm.algorithm",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Type.OID,
                                    constructed: !1,
                                    capture: "certSignatureOid"
                                }, {
                                    name: "Certificate.TBSCertificate.signature.parameters",
                                    tagClass: i.Class.UNIVERSAL,
                                    optional: !0,
                                    captureAsn1: "certSignatureParams"
                                }]
                            }, {
                                name: "Certificate.signatureValue",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.BITSTRING,
                                constructed: !1,
                                captureBitStringValue: "certSignature"
                            }]
                        },
                        l = {
                            name: "rsapss",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "rsapss.hashAlgorithm",
                                tagClass: i.Class.CONTEXT_SPECIFIC,
                                type: 0,
                                constructed: !0,
                                value: [{
                                    name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Class.SEQUENCE,
                                    constructed: !0,
                                    optional: !0,
                                    value: [{
                                        name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.OID,
                                        constructed: !1,
                                        capture: "hashOid"
                                    }]
                                }]
                            }, {
                                name: "rsapss.maskGenAlgorithm",
                                tagClass: i.Class.CONTEXT_SPECIFIC,
                                type: 1,
                                constructed: !0,
                                value: [{
                                    name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Class.SEQUENCE,
                                    constructed: !0,
                                    optional: !0,
                                    value: [{
                                        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.OID,
                                        constructed: !1,
                                        capture: "maskGenOid"
                                    }, {
                                        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.SEQUENCE,
                                        constructed: !0,
                                        value: [{
                                            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
                                            tagClass: i.Class.UNIVERSAL,
                                            type: i.Type.OID,
                                            constructed: !1,
                                            capture: "maskGenHashOid"
                                        }]
                                    }]
                                }]
                            }, {
                                name: "rsapss.saltLength",
                                tagClass: i.Class.CONTEXT_SPECIFIC,
                                type: 2,
                                optional: !0,
                                value: [{
                                    name: "rsapss.saltLength.saltLength",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Class.INTEGER,
                                    constructed: !1,
                                    capture: "saltLength"
                                }]
                            }, {
                                name: "rsapss.trailerField",
                                tagClass: i.Class.CONTEXT_SPECIFIC,
                                type: 3,
                                optional: !0,
                                value: [{
                                    name: "rsapss.trailer.trailer",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Class.INTEGER,
                                    constructed: !1,
                                    capture: "trailer"
                                }]
                            }]
                        },
                        f = {
                            name: "CertificationRequestInfo",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            captureAsn1: "certificationRequestInfo",
                            value: [{
                                name: "CertificationRequestInfo.integer",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.INTEGER,
                                constructed: !1,
                                capture: "certificationRequestInfoVersion"
                            }, {
                                name: "CertificationRequestInfo.subject",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.SEQUENCE,
                                constructed: !0,
                                captureAsn1: "certificationRequestInfoSubject"
                            }, u, {
                                name: "CertificationRequestInfo.attributes",
                                tagClass: i.Class.CONTEXT_SPECIFIC,
                                type: 0,
                                constructed: !0,
                                optional: !0,
                                capture: "certificationRequestInfoAttributes",
                                value: [{
                                    name: "CertificationRequestInfo.attributes",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Type.SEQUENCE,
                                    constructed: !0,
                                    value: [{
                                        name: "CertificationRequestInfo.attributes.type",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.OID,
                                        constructed: !1
                                    }, {
                                        name: "CertificationRequestInfo.attributes.value",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.SET,
                                        constructed: !0
                                    }]
                                }]
                            }]
                        },
                        p = {
                            name: "CertificationRequest",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            captureAsn1: "csr",
                            value: [f, {
                                name: "CertificationRequest.signatureAlgorithm",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.SEQUENCE,
                                constructed: !0,
                                value: [{
                                    name: "CertificationRequest.signatureAlgorithm.algorithm",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Type.OID,
                                    constructed: !1,
                                    capture: "csrSignatureOid"
                                }, {
                                    name: "CertificationRequest.signatureAlgorithm.parameters",
                                    tagClass: i.Class.UNIVERSAL,
                                    optional: !0,
                                    captureAsn1: "csrSignatureParams"
                                }]
                            }, {
                                name: "CertificationRequest.signature",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.BITSTRING,
                                constructed: !1,
                                captureBitStringValue: "csrSignature"
                            }]
                        };

                    function d(t, e) {
                        "string" == typeof e && (e = {
                            shortName: e
                        });
                        for (var r, n = null, i = 0; null === n && i < t.attributes.length; ++i) r = t.attributes[i], (e.type && e.type === r.type || e.name && e.name === r.name || e.shortName && e.shortName === r.shortName) && (n = r);
                        return n
                    }
                    s.RDNAttributesAsArray = function(t, e) {
                        for (var r, n, s, u = [], c = 0; c < t.value.length; ++c) {
                            r = t.value[c];
                            for (var h = 0; h < r.value.length; ++h) s = {}, n = r.value[h], s.type = i.derToOid(n.value[0].value), s.value = n.value[1].value, s.valueTagClass = n.value[1].type, s.type in a && (s.name = a[s.type], s.name in o && (s.shortName = o[s.name])), e && (e.update(s.type), e.update(s.value)), u.push(s)
                        }
                        return u
                    }, s.CRIAttributesAsArray = function(t) {
                        for (var e = [], r = 0; r < t.length; ++r)
                            for (var n = t[r], u = i.derToOid(n.value[0].value), c = n.value[1].value, h = 0; h < c.length; ++h) {
                                var l = {};
                                if (l.type = u, l.value = c[h].value, l.valueTagClass = c[h].type, l.type in a && (l.name = a[l.type], l.name in o && (l.shortName = o[l.name])), l.type === a.extensionRequest) {
                                    l.extensions = [];
                                    for (var f = 0; f < l.value.length; ++f) l.extensions.push(s.certificateExtensionFromAsn1(l.value[f]))
                                }
                                e.push(l)
                            }
                        return e
                    };
                    var g = function(t, e, r) {
                        var n = {};
                        if (t !== a["RSASSA-PSS"]) return n;
                        r && (n = {
                            hash: {
                                algorithmOid: a.sha1
                            },
                            mgf: {
                                algorithmOid: a.mgf1,
                                hash: {
                                    algorithmOid: a.sha1
                                }
                            },
                            saltLength: 20
                        });
                        var s = {},
                            o = [];
                        if (!i.validate(e, l, s, o)) {
                            var u = new Error("Cannot read RSASSA-PSS parameter block.");
                            throw u.errors = o, u
                        }
                        return void 0 !== s.hashOid && (n.hash = n.hash || {}, n.hash.algorithmOid = i.derToOid(s.hashOid)), void 0 !== s.maskGenOid && (n.mgf = n.mgf || {}, n.mgf.algorithmOid = i.derToOid(s.maskGenOid), n.mgf.hash = n.mgf.hash || {}, n.mgf.hash.algorithmOid = i.derToOid(s.maskGenHashOid)), void 0 !== s.saltLength && (n.saltLength = s.saltLength.charCodeAt(0)), n
                    };

                    function y(t) {
                        for (var e, r, s = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, []), a = t.attributes, o = 0; o < a.length; ++o) {
                            var u = (e = a[o]).value,
                                c = i.Type.PRINTABLESTRING;
                            "valueTagClass" in e && (c = e.valueTagClass) === i.Type.UTF8 && (u = n.util.encodeUtf8(u)), r = i.create(i.Class.UNIVERSAL, i.Type.SET, !0, [i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(e.type).getBytes()), i.create(i.Class.UNIVERSAL, c, !1, u)])]), s.value.push(r)
                        }
                        return s
                    }

                    function v(t) {
                        for (var e, r = 0; r < t.length; ++r) {
                            if (void 0 === (e = t[r]).name && (e.type && e.type in s.oids ? e.name = s.oids[e.type] : e.shortName && e.shortName in o && (e.name = s.oids[o[e.shortName]])), void 0 === e.type) {
                                if (!e.name || !(e.name in s.oids)) throw (u = new Error("Attribute type not specified.")).attribute = e, u;
                                e.type = s.oids[e.name]
                            }
                            if (void 0 === e.shortName && e.name && e.name in o && (e.shortName = o[e.name]), e.type === a.extensionRequest && (e.valueConstructed = !0, e.valueTagClass = i.Type.SEQUENCE, !e.value && e.extensions)) {
                                e.value = [];
                                for (var n = 0; n < e.extensions.length; ++n) e.value.push(s.certificateExtensionToAsn1(m(e.extensions[n])))
                            }
                            var u;
                            if (void 0 === e.value) throw (u = new Error("Attribute value not specified.")).attribute = e, u
                        }
                    }

                    function m(t, e) {
                        if (e = e || {}, void 0 === t.name && t.id && t.id in s.oids && (t.name = s.oids[t.id]), void 0 === t.id) {
                            if (!t.name || !(t.name in s.oids)) throw (b = new Error("Extension ID not specified.")).extension = t, b;
                            t.id = s.oids[t.name]
                        }
                        if (void 0 !== t.value) return t;
                        if ("keyUsage" === t.name) {
                            var r = 0,
                                o = 0,
                                u = 0;
                            t.digitalSignature && (o |= 128, r = 7), t.nonRepudiation && (o |= 64, r = 6), t.keyEncipherment && (o |= 32, r = 5), t.dataEncipherment && (o |= 16, r = 4), t.keyAgreement && (o |= 8, r = 3), t.keyCertSign && (o |= 4, r = 2), t.cRLSign && (o |= 2, r = 1), t.encipherOnly && (o |= 1, r = 0), t.decipherOnly && (u |= 128, r = 7);
                            var c = String.fromCharCode(r);
                            0 !== u ? c += String.fromCharCode(o) + String.fromCharCode(u) : 0 !== o && (c += String.fromCharCode(o)), t.value = i.create(i.Class.UNIVERSAL, i.Type.BITSTRING, !1, c)
                        } else if ("basicConstraints" === t.name) t.value = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, []), t.cA && t.value.value.push(i.create(i.Class.UNIVERSAL, i.Type.BOOLEAN, !1, String.fromCharCode(255))), "pathLenConstraint" in t && t.value.value.push(i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, i.integerToDer(t.pathLenConstraint).getBytes()));
                        else if ("extKeyUsage" === t.name) {
                            t.value = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, []);
                            var h = t.value.value;
                            for (var l in t) !0 === t[l] && (l in a ? h.push(i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(a[l]).getBytes())) : -1 !== l.indexOf(".") && h.push(i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(l).getBytes())))
                        } else if ("nsCertType" === t.name) r = 0, o = 0, t.client && (o |= 128, r = 7), t.server && (o |= 64, r = 6), t.email && (o |= 32, r = 5), t.objsign && (o |= 16, r = 4), t.reserved && (o |= 8, r = 3), t.sslCA && (o |= 4, r = 2), t.emailCA && (o |= 2, r = 1), t.objCA && (o |= 1, r = 0), c = String.fromCharCode(r), 0 !== o && (c += String.fromCharCode(o)), t.value = i.create(i.Class.UNIVERSAL, i.Type.BITSTRING, !1, c);
                        else if ("subjectAltName" === t.name || "issuerAltName" === t.name) {
                            t.value = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, []);
                            for (var f = 0; f < t.altNames.length; ++f) {
                                if (c = (m = t.altNames[f]).value, 7 === m.type && m.ip) {
                                    if (null === (c = n.util.bytesFromIP(m.ip))) throw (b = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')).extension = t, b
                                } else 8 === m.type && (c = m.oid ? i.oidToDer(i.oidToDer(m.oid)) : i.oidToDer(c));
                                t.value.value.push(i.create(i.Class.CONTEXT_SPECIFIC, m.type, !1, c))
                            }
                        } else if ("nsComment" === t.name && e.cert) {
                            if (!/^[\x00-\x7F]*$/.test(t.comment) || t.comment.length < 1 || t.comment.length > 128) throw new Error('Invalid "nsComment" content.');
                            t.value = i.create(i.Class.UNIVERSAL, i.Type.IA5STRING, !1, t.comment)
                        } else if ("subjectKeyIdentifier" === t.name && e.cert) {
                            var p = e.cert.generateSubjectKeyIdentifier();
                            t.subjectKeyIdentifier = p.toHex(), t.value = i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, p.getBytes())
                        } else if ("authorityKeyIdentifier" === t.name && e.cert) {
                            if (t.value = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, []), h = t.value.value, t.keyIdentifier) {
                                var d = !0 === t.keyIdentifier ? e.cert.generateSubjectKeyIdentifier().getBytes() : t.keyIdentifier;
                                h.push(i.create(i.Class.CONTEXT_SPECIFIC, 0, !1, d))
                            }
                            if (t.authorityCertIssuer) {
                                var g = [i.create(i.Class.CONTEXT_SPECIFIC, 4, !0, [y(!0 === t.authorityCertIssuer ? e.cert.issuer : t.authorityCertIssuer)])];
                                h.push(i.create(i.Class.CONTEXT_SPECIFIC, 1, !0, g))
                            }
                            if (t.serialNumber) {
                                var v = n.util.hexToBytes(!0 === t.serialNumber ? e.cert.serialNumber : t.serialNumber);
                                h.push(i.create(i.Class.CONTEXT_SPECIFIC, 2, !1, v))
                            }
                        } else if ("cRLDistributionPoints" === t.name) {
                            t.value = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, []), h = t.value.value;
                            var m, E = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, []),
                                S = i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, []);
                            for (f = 0; f < t.altNames.length; ++f) {
                                if (c = (m = t.altNames[f]).value, 7 === m.type && m.ip) {
                                    if (null === (c = n.util.bytesFromIP(m.ip))) throw (b = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')).extension = t, b
                                } else 8 === m.type && (c = m.oid ? i.oidToDer(i.oidToDer(m.oid)) : i.oidToDer(c));
                                S.value.push(i.create(i.Class.CONTEXT_SPECIFIC, m.type, !1, c))
                            }
                            E.value.push(i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [S])), h.push(E)
                        }
                        var b;
                        if (void 0 === t.value) throw (b = new Error("Extension value not specified.")).extension = t, b;
                        return t
                    }

                    function E(t, e) {
                        switch (t) {
                            case a["RSASSA-PSS"]:
                                var r = [];
                                return void 0 !== e.hash.algorithmOid && r.push(i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(e.hash.algorithmOid).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.NULL, !1, "")])])), void 0 !== e.mgf.algorithmOid && r.push(i.create(i.Class.CONTEXT_SPECIFIC, 1, !0, [i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(e.mgf.algorithmOid).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(e.mgf.hash.algorithmOid).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.NULL, !1, "")])])])), void 0 !== e.saltLength && r.push(i.create(i.Class.CONTEXT_SPECIFIC, 2, !0, [i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, i.integerToDer(e.saltLength).getBytes())])), i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, r);
                            default:
                                return i.create(i.Class.UNIVERSAL, i.Type.NULL, !1, "")
                        }
                    }

                    function S(t) {
                        var e = i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, []);
                        if (0 === t.attributes.length) return e;
                        for (var r = t.attributes, s = 0; s < r.length; ++s) {
                            var a = r[s],
                                o = a.value,
                                u = i.Type.UTF8;
                            "valueTagClass" in a && (u = a.valueTagClass), u === i.Type.UTF8 && (o = n.util.encodeUtf8(o));
                            var c = !1;
                            "valueConstructed" in a && (c = a.valueConstructed);
                            var h = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(a.type).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.SET, !0, [i.create(i.Class.UNIVERSAL, u, c, o)])]);
                            e.value.push(h)
                        }
                        return e
                    }
                    s.certificateFromPemWithoutPubKey = function(t, e, r) {
                        var a = n.pem.decode(t)[0];
                        if ("CERTIFICATE" !== a.type && "X509 CERTIFICATE" !== a.type && "TRUSTED CERTIFICATE" !== a.type) {
                            var o = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
                            throw o.headerType = a.type, o
                        }
                        if (a.procType && "ENCRYPTED" === a.procType.type) throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
                        var u = i.fromDer(a.body, r);
                        return s.certificateFromAsn1WithoutPubKey(u, e)
                    }, s.certificateFromPem = function(t, e, r) {
                        var a = n.pem.decode(t)[0];
                        if ("CERTIFICATE" !== a.type && "X509 CERTIFICATE" !== a.type && "TRUSTED CERTIFICATE" !== a.type) {
                            var o = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
                            throw o.headerType = a.type, o
                        }
                        if (a.procType && "ENCRYPTED" === a.procType.type) throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
                        var u = i.fromDer(a.body, r);
                        return s.certificateFromAsn1(u, e)
                    }, s.certificateToPem = function(t, e) {
                        var r = {
                            type: "CERTIFICATE",
                            body: i.toDer(s.certificateToAsn1(t)).getBytes()
                        };
                        return n.pem.encode(r, {
                            maxline: e
                        })
                    }, s.publicKeyFromPem = function(t) {
                        var e = n.pem.decode(t)[0];
                        if ("PUBLIC KEY" !== e.type && "RSA PUBLIC KEY" !== e.type) {
                            var r = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
                            throw r.headerType = e.type, r
                        }
                        if (e.procType && "ENCRYPTED" === e.procType.type) throw new Error("Could not convert public key from PEM; PEM is encrypted.");
                        var a = i.fromDer(e.body);
                        return s.publicKeyFromAsn1(a)
                    }, s.publicKeyToPem = function(t, e) {
                        var r = {
                            type: "PUBLIC KEY",
                            body: i.toDer(s.publicKeyToAsn1(t)).getBytes()
                        };
                        return n.pem.encode(r, {
                            maxline: e
                        })
                    }, s.publicKeyToRSAPublicKeyPem = function(t, e) {
                        var r = {
                            type: "RSA PUBLIC KEY",
                            body: i.toDer(s.publicKeyToRSAPublicKey(t)).getBytes()
                        };
                        return n.pem.encode(r, {
                            maxline: e
                        })
                    }, s.getPublicKeyFingerprint = function(t, e) {
                        var r, a = (e = e || {}).md || n.md.sha1.create();
                        switch (e.type || "RSAPublicKey") {
                            case "RSAPublicKey":
                                r = i.toDer(s.publicKeyToRSAPublicKey(t)).getBytes();
                                break;
                            case "SubjectPublicKeyInfo":
                                r = i.toDer(s.publicKeyToAsn1(t)).getBytes();
                                break;
                            default:
                                throw new Error('Unknown fingerprint type "' + e.type + '".')
                        }
                        a.start(), a.update(r);
                        var o = a.digest();
                        if ("hex" === e.encoding) {
                            var u = o.toHex();
                            return e.delimiter ? u.match(/.{2}/g).join(e.delimiter) : u
                        }
                        if ("binary" === e.encoding) return o.getBytes();
                        if (e.encoding) throw new Error('Unknown encoding "' + e.encoding + '".');
                        return o
                    }, s.certificationRequestFromPem = function(t, e, r) {
                        var a = n.pem.decode(t)[0];
                        if ("CERTIFICATE REQUEST" !== a.type) {
                            var o = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
                            throw o.headerType = a.type, o
                        }
                        if (a.procType && "ENCRYPTED" === a.procType.type) throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
                        var u = i.fromDer(a.body, r);
                        return s.certificationRequestFromAsn1(u, e)
                    }, s.certificationRequestToPem = function(t, e) {
                        var r = {
                            type: "CERTIFICATE REQUEST",
                            body: i.toDer(s.certificationRequestToAsn1(t)).getBytes()
                        };
                        return n.pem.encode(r, {
                            maxline: e
                        })
                    }, s.createCertificate = function() {
                        var t = {
                            version: 2,
                            serialNumber: "00",
                            signatureOid: null,
                            signature: null,
                            siginfo: {}
                        };
                        return t.siginfo.algorithmOid = null, t.validity = {}, t.validity.notBefore = new Date, t.validity.notAfter = new Date, t.issuer = {}, t.issuer.getField = function(e) {
                            return d(t.issuer, e)
                        }, t.issuer.addField = function(e) {
                            v([e]), t.issuer.attributes.push(e)
                        }, t.issuer.attributes = [], t.issuer.hash = null, t.subject = {}, t.subject.getField = function(e) {
                            return d(t.subject, e)
                        }, t.subject.addField = function(e) {
                            v([e]), t.subject.attributes.push(e)
                        }, t.subject.attributes = [], t.subject.hash = null, t.extensions = [], t.publicKey = null, t.md = null, t.setSubject = function(e, r) {
                            v(e), t.subject.attributes = e, delete t.subject.uniqueId, r && (t.subject.uniqueId = r), t.subject.hash = null
                        }, t.setIssuer = function(e, r) {
                            v(e), t.issuer.attributes = e, delete t.issuer.uniqueId, r && (t.issuer.uniqueId = r), t.issuer.hash = null
                        }, t.setExtensions = function(e) {
                            for (var r = 0; r < e.length; ++r) m(e[r], {
                                cert: t
                            });
                            t.extensions = e
                        }, t.getExtension = function(e) {
                            "string" == typeof e && (e = {
                                name: e
                            });
                            for (var r, n = null, i = 0; null === n && i < t.extensions.length; ++i) r = t.extensions[i], (e.id && r.id === e.id || e.name && r.name === e.name) && (n = r);
                            return n
                        }, t.sign = function(e, r) {
                            t.md = r || n.md.sha1.create();
                            var o = a[t.md.algorithm + "WithRSAEncryption"];
                            if (!o) {
                                var u = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
                                throw u.algorithm = t.md.algorithm, u
                            }
                            t.signatureOid = t.siginfo.algorithmOid = o, t.tbsCertificate = s.getTBSCertificate(t);
                            var c = i.toDer(t.tbsCertificate);
                            t.md.update(c.getBytes()), t.signature = e.sign(t.md)
                        }, t.verify = function(e) {
                            var r = !1;
                            if (!t.issued(e)) {
                                var o = e.issuer,
                                    u = t.subject;
                                throw (g = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.")).expectedIssuer = o.attributes, g.actualIssuer = u.attributes, g
                            }
                            var c = e.md;
                            if (null === c) {
                                if (e.signatureOid in a) switch (a[e.signatureOid]) {
                                    case "sha1WithRSAEncryption":
                                        c = n.md.sha1.create();
                                        break;
                                    case "md5WithRSAEncryption":
                                        c = n.md.md5.create();
                                        break;
                                    case "sha256WithRSAEncryption":
                                        c = n.md.sha256.create();
                                        break;
                                    case "sha384WithRSAEncryption":
                                        c = n.md.sha384.create();
                                        break;
                                    case "sha512WithRSAEncryption":
                                        c = n.md.sha512.create();
                                        break;
                                    case "RSASSA-PSS":
                                        c = n.md.sha256.create()
                                }
                                if (null === c) throw (g = new Error("Could not compute certificate digest. Unknown signature OID.")).signatureOid = e.signatureOid, g;
                                var h = e.tbsCertificate || s.getTBSCertificate(e),
                                    l = i.toDer(h);
                                c.update(l.getBytes())
                            }
                            if (null !== c) {
                                var f;
                                switch (e.signatureOid) {
                                    case a.sha1WithRSAEncryption:
                                        f = void 0;
                                        break;
                                    case a["RSASSA-PSS"]:
                                        var p, d, g;
                                        if (void 0 === (p = a[e.signatureParameters.mgf.hash.algorithmOid]) || void 0 === n.md[p]) throw (g = new Error("Unsupported MGF hash function.")).oid = e.signatureParameters.mgf.hash.algorithmOid, g.name = p, g;
                                        if (void 0 === (d = a[e.signatureParameters.mgf.algorithmOid]) || void 0 === n.mgf[d]) throw (g = new Error("Unsupported MGF function.")).oid = e.signatureParameters.mgf.algorithmOid, g.name = d, g;
                                        if (d = n.mgf[d].create(n.md[p].create()), void 0 === (p = a[e.signatureParameters.hash.algorithmOid]) || void 0 === n.md[p]) throw {
                                            message: "Unsupported RSASSA-PSS hash function.",
                                            oid: e.signatureParameters.hash.algorithmOid,
                                            name: p
                                        };
                                        f = n.pss.create(n.md[p].create(), d, e.signatureParameters.saltLength)
                                }
                                r = t.publicKey.verify(c.digest().getBytes(), e.signature, f)
                            }
                            return r
                        }, t.isIssuer = function(e) {
                            var r = !1,
                                n = t.issuer,
                                i = e.subject;
                            if (n.hash && i.hash) r = n.hash === i.hash;
                            else if (n.attributes.length === i.attributes.length) {
                                var s, a;
                                r = !0;
                                for (var o = 0; r && o < n.attributes.length; ++o) s = n.attributes[o], a = i.attributes[o], s.type === a.type && s.value === a.value || (r = !1)
                            }
                            return r
                        }, t.issued = function(e) {
                            return e.isIssuer(t)
                        }, t.generateSubjectKeyIdentifier = function() {
                            return s.getPublicKeyFingerprint(t.publicKey, {
                                type: "RSAPublicKey"
                            })
                        }, t.verifySubjectKeyIdentifier = function() {
                            for (var e = a.subjectKeyIdentifier, r = 0; r < t.extensions.length; ++r) {
                                var i = t.extensions[r];
                                if (i.id === e) {
                                    var s = t.generateSubjectKeyIdentifier().getBytes();
                                    return n.util.hexToBytes(i.subjectKeyIdentifier) === s
                                }
                            }
                            return !1
                        }, t
                    }, s.certificateFromAsn1WithoutPubKey = function(t, e) {
                        var r = {},
                            o = [];
                        if (!i.validate(t, c, r, o)) throw (f = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.")).errors = o, f;
                        i.derToOid(r.publicKeyOid);
                        var u = s.createCertificate();
                        u.version = r.certVersion ? r.certVersion.charCodeAt(0) : 0;
                        var h = n.util.createBuffer(r.certSerialNumber);
                        u.serialNumber = h.toHex(), u.signatureOid = n.asn1.derToOid(r.certSignatureOid), u.signatureParameters = g(u.signatureOid, r.certSignatureParams, !0), u.siginfo.algorithmOid = n.asn1.derToOid(r.certinfoSignatureOid), u.siginfo.parameters = g(u.siginfo.algorithmOid, r.certinfoSignatureParams, !1), u.signature = r.certSignature;
                        var l = [];
                        if (void 0 !== r.certValidity1UTCTime && l.push(i.utcTimeToDate(r.certValidity1UTCTime)), void 0 !== r.certValidity2GeneralizedTime && l.push(i.generalizedTimeToDate(r.certValidity2GeneralizedTime)), void 0 !== r.certValidity3UTCTime && l.push(i.utcTimeToDate(r.certValidity3UTCTime)), void 0 !== r.certValidity4GeneralizedTime && l.push(i.generalizedTimeToDate(r.certValidity4GeneralizedTime)), l.length > 2) throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
                        if (l.length < 2) throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
                        if (u.validity.notBefore = l[0], u.validity.notAfter = l[1], u.tbsCertificate = r.tbsCertificate, e) {
                            var f;
                            if (u.md = null, u.signatureOid in a) switch (a[u.signatureOid]) {
                                case "sha1WithRSAEncryption":
                                    u.md = n.md.sha1.create();
                                    break;
                                case "md5WithRSAEncryption":
                                    u.md = n.md.md5.create();
                                    break;
                                case "sha256WithRSAEncryption":
                                    u.md = n.md.sha256.create();
                                    break;
                                case "sha384WithRSAEncryption":
                                    u.md = n.md.sha384.create();
                                    break;
                                case "sha512WithRSAEncryption":
                                    u.md = n.md.sha512.create();
                                    break;
                                case "RSASSA-PSS":
                                    u.md = n.md.sha256.create()
                            }
                            if (null === u.md) throw (f = new Error("Could not compute certificate digest. Unknown signature OID.")).signatureOid = u.signatureOid, f;
                            var p = i.toDer(u.tbsCertificate);
                            u.md.update(p.getBytes())
                        }
                        var y = n.md.sha1.create();
                        u.issuer.getField = function(t) {
                            return d(u.issuer, t)
                        }, u.issuer.addField = function(t) {
                            v([t]), u.issuer.attributes.push(t)
                        }, u.issuer.attributes = s.RDNAttributesAsArray(r.certIssuer, y), r.certIssuerUniqueId && (u.issuer.uniqueId = r.certIssuerUniqueId), u.issuer.hash = y.digest().toHex();
                        var m = n.md.sha1.create();
                        return u.subject.getField = function(t) {
                            return d(u.subject, t)
                        }, u.subject.addField = function(t) {
                            v([t]), u.subject.attributes.push(t)
                        }, u.subject.attributes = s.RDNAttributesAsArray(r.certSubject, m), r.certSubjectUniqueId && (u.subject.uniqueId = r.certSubjectUniqueId), u.subject.hash = m.digest().toHex(), r.certExtensions ? u.extensions = s.certificateExtensionsFromAsn1(r.certExtensions) : u.extensions = [], u
                    }, s.certificateFromAsn1 = function(t, e) {
                        var r = {},
                            o = [];
                        if (!i.validate(t, c, r, o)) throw (f = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.")).errors = o, f;
                        if (i.derToOid(r.publicKeyOid), "1.2.156.10197.1.501" == i.derToOid(r.certSignatureOid)) return {
                            code: "0",
                            msg: ""
                        };
                        var u = s.createCertificate();
                        u.version = r.certVersion ? r.certVersion.charCodeAt(0) : 0;
                        var h = n.util.createBuffer(r.certSerialNumber);
                        u.serialNumber = h.toHex(), u.signatureOid = n.asn1.derToOid(r.certSignatureOid), u.signatureParameters = g(u.signatureOid, r.certSignatureParams, !0), u.siginfo.algorithmOid = n.asn1.derToOid(r.certinfoSignatureOid), u.siginfo.parameters = g(u.siginfo.algorithmOid, r.certinfoSignatureParams, !1), u.signature = r.certSignature;
                        var l = [];
                        if (void 0 !== r.certValidity1UTCTime && l.push(i.utcTimeToDate(r.certValidity1UTCTime)), void 0 !== r.certValidity2GeneralizedTime && l.push(i.generalizedTimeToDate(r.certValidity2GeneralizedTime)), void 0 !== r.certValidity3UTCTime && l.push(i.utcTimeToDate(r.certValidity3UTCTime)), void 0 !== r.certValidity4GeneralizedTime && l.push(i.generalizedTimeToDate(r.certValidity4GeneralizedTime)), l.length > 2) throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
                        if (l.length < 2) throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
                        if (u.validity.notBefore = l[0], u.validity.notAfter = l[1], u.tbsCertificate = r.tbsCertificate, e) {
                            var f;
                            if (u.md = null, u.signatureOid in a) switch (a[u.signatureOid]) {
                                case "sha1WithRSAEncryption":
                                    u.md = n.md.sha1.create();
                                    break;
                                case "md5WithRSAEncryption":
                                    u.md = n.md.md5.create();
                                    break;
                                case "sha256WithRSAEncryption":
                                    u.md = n.md.sha256.create();
                                    break;
                                case "sha384WithRSAEncryption":
                                    u.md = n.md.sha384.create();
                                    break;
                                case "sha512WithRSAEncryption":
                                    u.md = n.md.sha512.create();
                                    break;
                                case "RSASSA-PSS":
                                    u.md = n.md.sha256.create()
                            }
                            if (null === u.md) throw (f = new Error("Could not compute certificate digest. Unknown signature OID.")).signatureOid = u.signatureOid, f;
                            var p = i.toDer(u.tbsCertificate);
                            u.md.update(p.getBytes())
                        }
                        var y = n.md.sha1.create();
                        u.issuer.getField = function(t) {
                            return d(u.issuer, t)
                        }, u.issuer.addField = function(t) {
                            v([t]), u.issuer.attributes.push(t)
                        }, u.issuer.attributes = s.RDNAttributesAsArray(r.certIssuer, y), r.certIssuerUniqueId && (u.issuer.uniqueId = r.certIssuerUniqueId), u.issuer.hash = y.digest().toHex();
                        var m = n.md.sha1.create();
                        return u.subject.getField = function(t) {
                            return d(u.subject, t)
                        }, u.subject.addField = function(t) {
                            v([t]), u.subject.attributes.push(t)
                        }, u.subject.attributes = s.RDNAttributesAsArray(r.certSubject, m), r.certSubjectUniqueId && (u.subject.uniqueId = r.certSubjectUniqueId), u.subject.hash = m.digest().toHex(), r.certExtensions ? u.extensions = s.certificateExtensionsFromAsn1(r.certExtensions) : u.extensions = [], u.publicKey = s.publicKeyFromAsn1(r.subjectPublicKeyInfo), u
                    }, s.certificateExtensionsFromAsn1 = function(t) {
                        for (var e = [], r = 0; r < t.value.length; ++r)
                            for (var n = t.value[r], i = 0; i < n.value.length; ++i) e.push(s.certificateExtensionFromAsn1(n.value[i]));
                        return e
                    }, s.certificateExtensionFromAsn1 = function(t) {
                        var e = {};
                        if (e.id = i.derToOid(t.value[0].value), e.critical = !1, t.value[1].type === i.Type.BOOLEAN ? (e.critical = 0 !== t.value[1].value.charCodeAt(0), e.value = t.value[2].value) : e.value = t.value[1].value, e.id in a)
                            if (e.name = a[e.id], "keyUsage" === e.name) {
                                var r = 0,
                                    s = 0;
                                (u = i.fromDer(e.value)).value.length > 1 && (r = u.value.charCodeAt(1), s = u.value.length > 2 ? u.value.charCodeAt(2) : 0), e.digitalSignature = 128 == (128 & r), e.nonRepudiation = 64 == (64 & r), e.keyEncipherment = 32 == (32 & r), e.dataEncipherment = 16 == (16 & r), e.keyAgreement = 8 == (8 & r), e.keyCertSign = 4 == (4 & r), e.cRLSign = 2 == (2 & r), e.encipherOnly = 1 == (1 & r), e.decipherOnly = 128 == (128 & s)
                            } else if ("basicConstraints" === e.name) {
                            (u = i.fromDer(e.value)).value.length > 0 && u.value[0].type === i.Type.BOOLEAN ? e.cA = 0 !== u.value[0].value.charCodeAt(0) : e.cA = !1;
                            var o = null;
                            u.value.length > 0 && u.value[0].type === i.Type.INTEGER ? o = u.value[0].value : u.value.length > 1 && (o = u.value[1].value), null !== o && (e.pathLenConstraint = i.derToInteger(o))
                        } else if ("extKeyUsage" === e.name)
                            for (var u = i.fromDer(e.value), c = 0; c < u.value.length; ++c) {
                                var h = i.derToOid(u.value[c].value);
                                h in a ? e[a[h]] = !0 : e[h] = !0
                            } else if ("nsCertType" === e.name) r = 0, (u = i.fromDer(e.value)).value.length > 1 && (r = u.value.charCodeAt(1)), e.client = 128 == (128 & r), e.server = 64 == (64 & r), e.email = 32 == (32 & r), e.objsign = 16 == (16 & r), e.reserved = 8 == (8 & r), e.sslCA = 4 == (4 & r), e.emailCA = 2 == (2 & r), e.objCA = 1 == (1 & r);
                            else if ("subjectAltName" === e.name || "issuerAltName" === e.name) {
                            var l;
                            e.altNames = [], u = i.fromDer(e.value);
                            for (var f = 0; f < u.value.length; ++f) {
                                var p = {
                                    type: (l = u.value[f]).type,
                                    value: l.value
                                };
                                switch (e.altNames.push(p), l.type) {
                                    case 1:
                                    case 2:
                                    case 6:
                                        break;
                                    case 7:
                                        p.ip = n.util.bytesToIP(l.value);
                                        break;
                                    case 8:
                                        p.oid = i.derToOid(l.value)
                                }
                            }
                        } else "subjectKeyIdentifier" === e.name && (u = i.fromDer(e.value), e.subjectKeyIdentifier = n.util.bytesToHex(u.value));
                        return e
                    }, s.certificationRequestFromAsn1 = function(t, e) {
                        var r = {},
                            o = [];
                        if (!i.validate(t, p, r, o)) throw (h = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.")).errors = o, h;
                        if (i.derToOid(r.publicKeyOid) !== s.oids.rsaEncryption) {
                            var u = s.createCertificationRequest();
                            return u.version = r.csrVersion ? r.csrVersion.charCodeAt(0) : 0, u.signatureOid = n.asn1.derToOid(r.csrSignatureOid), u.signatureParameters = g(u.signatureOid, r.csrSignatureParams, !0), u.siginfo.algorithmOid = n.asn1.derToOid(r.csrSignatureOid), u.siginfo.parameters = g(u.siginfo.algorithmOid, r.csrSignatureParams, !1), u.signature = n.util.bytesToHex(r.csrSignature), u.publicKey = n.util.bytesToHex(r.subjectPublicKeyInfo.value[1].value).slice(2), u.subject.getField = function(t) {
                                return d(u.subject, t)
                            }, u.subject.addField = function(t) {
                                v([t]), u.subject.attributes.push(t)
                            }, u.subject.attributes = s.RDNAttributesAsArray(r.certificationRequestInfoSubject), u.getAttribute = function(t) {
                                return d(u, t)
                            }, u.addAttribute = function(t) {
                                v([t]), u.attributes.push(t)
                            }, u.attributes = s.CRIAttributesAsArray(r.certificationRequestInfoAttributes || []), {
                                code: "0",
                                data: u
                            }
                        }
                        var c = s.createCertificationRequest();
                        if (c.version = r.csrVersion ? r.csrVersion.charCodeAt(0) : 0, c.signatureOid = n.asn1.derToOid(r.csrSignatureOid), c.signatureParameters = g(c.signatureOid, r.csrSignatureParams, !0), c.siginfo.algorithmOid = n.asn1.derToOid(r.csrSignatureOid), c.siginfo.parameters = g(c.siginfo.algorithmOid, r.csrSignatureParams, !1), c.signature = r.csrSignature, c.certificationRequestInfo = r.certificationRequestInfo, e) {
                            var h;
                            if (c.md = null, c.signatureOid in a) switch (a[c.signatureOid]) {
                                case "sha1WithRSAEncryption":
                                    c.md = n.md.sha1.create();
                                    break;
                                case "md5WithRSAEncryption":
                                    c.md = n.md.md5.create();
                                    break;
                                case "sha256WithRSAEncryption":
                                    c.md = n.md.sha256.create();
                                    break;
                                case "sha384WithRSAEncryption":
                                    c.md = n.md.sha384.create();
                                    break;
                                case "sha512WithRSAEncryption":
                                    c.md = n.md.sha512.create();
                                    break;
                                case "RSASSA-PSS":
                                    c.md = n.md.sha256.create()
                            }
                            if (null === c.md) throw (h = new Error("Could not compute certification request digest. Unknown signature OID.")).signatureOid = c.signatureOid, h;
                            var l = i.toDer(c.certificationRequestInfo);
                            c.md.update(l.getBytes())
                        }
                        var f = n.md.sha1.create();
                        return c.subject.getField = function(t) {
                            return d(c.subject, t)
                        }, c.subject.addField = function(t) {
                            v([t]), c.subject.attributes.push(t)
                        }, c.subject.attributes = s.RDNAttributesAsArray(r.certificationRequestInfoSubject, f), c.subject.hash = f.digest().toHex(), c.publicKey = s.publicKeyFromAsn1(r.subjectPublicKeyInfo), c.getAttribute = function(t) {
                            return d(c, t)
                        }, c.addAttribute = function(t) {
                            v([t]), c.attributes.push(t)
                        }, c.attributes = s.CRIAttributesAsArray(r.certificationRequestInfoAttributes || []), c
                    }, s.createCertificationRequest = function() {
                        var t = {
                            version: 0,
                            signatureOid: null,
                            signature: null,
                            siginfo: {}
                        };
                        return t.siginfo.algorithmOid = null, t.subject = {}, t.subject.getField = function(e) {
                            return d(t.subject, e)
                        }, t.subject.addField = function(e) {
                            v([e]), t.subject.attributes.push(e)
                        }, t.subject.attributes = [], t.subject.hash = null, t.publicKey = null, t.attributes = [], t.getAttribute = function(e) {
                            return d(t, e)
                        }, t.addAttribute = function(e) {
                            v([e]), t.attributes.push(e)
                        }, t.md = null, t.setSubject = function(e) {
                            v(e), t.subject.attributes = e, t.subject.hash = null
                        }, t.setAttributes = function(e) {
                            v(e), t.attributes = e
                        }, t.sign = function(e, r) {
                            t.md = r || n.md.sha1.create();
                            var o = a[t.md.algorithm + "WithRSAEncryption"];
                            if (!o) {
                                var u = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
                                throw u.algorithm = t.md.algorithm, u
                            }
                            t.signatureOid = t.siginfo.algorithmOid = o, t.certificationRequestInfo = s.getCertificationRequestInfo(t);
                            var c = i.toDer(t.certificationRequestInfo);
                            t.md.update(c.getBytes()), t.signature = e.sign(t.md)
                        }, t.verify = function() {
                            var e = !1,
                                r = t.md;
                            if (null === r) {
                                if (t.signatureOid in a) switch (a[t.signatureOid]) {
                                    case "sha1WithRSAEncryption":
                                        r = n.md.sha1.create();
                                        break;
                                    case "md5WithRSAEncryption":
                                        r = n.md.md5.create();
                                        break;
                                    case "sha256WithRSAEncryption":
                                        r = n.md.sha256.create();
                                        break;
                                    case "sha384WithRSAEncryption":
                                        r = n.md.sha384.create();
                                        break;
                                    case "sha512WithRSAEncryption":
                                        r = n.md.sha512.create();
                                        break;
                                    case "RSASSA-PSS":
                                        r = n.md.sha256.create()
                                }
                                if (null === r) throw (f = new Error("Could not compute certification request digest. Unknown signature OID.")).signatureOid = t.signatureOid, f;
                                var o = t.certificationRequestInfo || s.getCertificationRequestInfo(t),
                                    u = i.toDer(o);
                                r.update(u.getBytes())
                            }
                            if (null !== r) {
                                var c;
                                switch (t.signatureOid) {
                                    case a.sha1WithRSAEncryption:
                                        break;
                                    case a["RSASSA-PSS"]:
                                        var h, l, f;
                                        if (void 0 === (h = a[t.signatureParameters.mgf.hash.algorithmOid]) || void 0 === n.md[h]) throw (f = new Error("Unsupported MGF hash function.")).oid = t.signatureParameters.mgf.hash.algorithmOid, f.name = h, f;
                                        if (void 0 === (l = a[t.signatureParameters.mgf.algorithmOid]) || void 0 === n.mgf[l]) throw (f = new Error("Unsupported MGF function.")).oid = t.signatureParameters.mgf.algorithmOid, f.name = l, f;
                                        if (l = n.mgf[l].create(n.md[h].create()), void 0 === (h = a[t.signatureParameters.hash.algorithmOid]) || void 0 === n.md[h]) throw (f = new Error("Unsupported RSASSA-PSS hash function.")).oid = t.signatureParameters.hash.algorithmOid, f.name = h, f;
                                        c = n.pss.create(n.md[h].create(), l, t.signatureParameters.saltLength)
                                }
                                e = t.publicKey.verify(r.digest().getBytes(), t.signature, c)
                            }
                            return e
                        }, t
                    };
                    var b = new Date("1950-01-01T00:00:00Z"),
                        C = new Date("2050-01-01T00:00:00Z");

                    function A(t) {
                        return t >= b && t < C ? i.create(i.Class.UNIVERSAL, i.Type.UTCTIME, !1, i.dateToUtcTime(t)) : i.create(i.Class.UNIVERSAL, i.Type.GENERALIZEDTIME, !1, i.dateToGeneralizedTime(t))
                    }
                    s.getTBSCertificate = function(t) {
                        var e = A(t.validity.notBefore),
                            r = A(t.validity.notAfter),
                            a = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, i.integerToDer(t.version).getBytes())]), i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, n.util.hexToBytes(t.serialNumber)), i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(t.siginfo.algorithmOid).getBytes()), E(t.siginfo.algorithmOid, t.siginfo.parameters)]), y(t.issuer), i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [e, r]), y(t.subject), s.publicKeyToAsn1(t.publicKey)]);
                        return t.issuer.uniqueId && a.value.push(i.create(i.Class.CONTEXT_SPECIFIC, 1, !0, [i.create(i.Class.UNIVERSAL, i.Type.BITSTRING, !1, String.fromCharCode(0) + t.issuer.uniqueId)])), t.subject.uniqueId && a.value.push(i.create(i.Class.CONTEXT_SPECIFIC, 2, !0, [i.create(i.Class.UNIVERSAL, i.Type.BITSTRING, !1, String.fromCharCode(0) + t.subject.uniqueId)])), t.extensions.length > 0 && a.value.push(s.certificateExtensionsToAsn1(t.extensions)), a
                    }, s.getCertificationRequestInfo = function(t) {
                        return i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, i.integerToDer(t.version).getBytes()), y(t.subject), s.publicKeyToAsn1(t.publicKey), S(t)])
                    }, s.distinguishedNameToAsn1 = function(t) {
                        return y(t)
                    }, s.certificateToAsn1 = function(t) {
                        var e = t.tbsCertificate || s.getTBSCertificate(t);
                        return i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [e, i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(t.signatureOid).getBytes()), E(t.signatureOid, t.signatureParameters)]), i.create(i.Class.UNIVERSAL, i.Type.BITSTRING, !1, String.fromCharCode(0) + t.signature)])
                    }, s.certificateExtensionsToAsn1 = function(t) {
                        var e = i.create(i.Class.CONTEXT_SPECIFIC, 3, !0, []),
                            r = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, []);
                        e.value.push(r);
                        for (var n = 0; n < t.length; ++n) r.value.push(s.certificateExtensionToAsn1(t[n]));
                        return e
                    }, s.certificateExtensionToAsn1 = function(t) {
                        var e = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, []);
                        e.value.push(i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(t.id).getBytes())), t.critical && e.value.push(i.create(i.Class.UNIVERSAL, i.Type.BOOLEAN, !1, String.fromCharCode(255)));
                        var r = t.value;
                        return "string" != typeof t.value && (r = i.toDer(r).getBytes()), e.value.push(i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, r)), e
                    }, s.certificationRequestToAsn1 = function(t) {
                        var e = t.certificationRequestInfo || s.getCertificationRequestInfo(t);
                        return i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [e, i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(t.signatureOid).getBytes()), E(t.signatureOid, t.signatureParameters)]), i.create(i.Class.UNIVERSAL, i.Type.BITSTRING, !1, String.fromCharCode(0) + t.signature)])
                    }, s.createCaStore = function(t) {
                        var e = {
                            certs: {}
                        };

                        function r(t) {
                            return a(t), e.certs[t.hash] || null
                        }

                        function a(t) {
                            if (!t.hash) {
                                var e = n.md.sha1.create();
                                t.attributes = s.RDNAttributesAsArray(y(t), e), t.hash = e.digest().toHex()
                            }
                        }
                        if (e.getIssuer = function(t) {
                                return r(t.issuer)
                            }, e.addCertificate = function(t) {
                                if ("string" == typeof t && (t = n.pki.certificateFromPem(t)), a(t.subject), !e.hasCertificate(t))
                                    if (t.subject.hash in e.certs) {
                                        var r = e.certs[t.subject.hash];
                                        n.util.isArray(r) || (r = [r]), r.push(t), e.certs[t.subject.hash] = r
                                    } else e.certs[t.subject.hash] = t
                            }, e.hasCertificate = function(t) {
                                "string" == typeof t && (t = n.pki.certificateFromPem(t));
                                var e = r(t.subject);
                                if (!e) return !1;
                                n.util.isArray(e) || (e = [e]);
                                for (var a = i.toDer(s.certificateToAsn1(t)).getBytes(), o = 0; o < e.length; ++o)
                                    if (a === i.toDer(s.certificateToAsn1(e[o])).getBytes()) return !0;
                                return !1
                            }, e.listAllCertificates = function() {
                                var t = [];
                                for (var r in e.certs)
                                    if (e.certs.hasOwnProperty(r)) {
                                        var i = e.certs[r];
                                        if (n.util.isArray(i))
                                            for (var s = 0; s < i.length; ++s) t.push(i[s]);
                                        else t.push(i)
                                    }
                                return t
                            }, e.removeCertificate = function(t) {
                                var o;
                                if ("string" == typeof t && (t = n.pki.certificateFromPem(t)), a(t.subject), !e.hasCertificate(t)) return null;
                                var u = r(t.subject);
                                if (!n.util.isArray(u)) return o = e.certs[t.subject.hash], delete e.certs[t.subject.hash], o;
                                for (var c = i.toDer(s.certificateToAsn1(t)).getBytes(), h = 0; h < u.length; ++h) c === i.toDer(s.certificateToAsn1(u[h])).getBytes() && (o = u[h], u.splice(h, 1));
                                return 0 === u.length && delete e.certs[t.subject.hash], o
                            }, t)
                            for (var o = 0; o < t.length; ++o) {
                                var u = t[o];
                                e.addCertificate(u)
                            }
                        return e
                    }, s.certificateError = {
                        bad_certificate: "forge.pki.BadCertificate",
                        unsupported_certificate: "forge.pki.UnsupportedCertificate",
                        certificate_revoked: "forge.pki.CertificateRevoked",
                        certificate_expired: "forge.pki.CertificateExpired",
                        certificate_unknown: "forge.pki.CertificateUnknown",
                        unknown_ca: "forge.pki.UnknownCertificateAuthority"
                    }, s.verifyCertificateChain = function(t, e, r) {
                        "function" == typeof r && (r = {
                            verify: r
                        }), r = r || {};
                        var i = (e = e.slice(0)).slice(0),
                            a = r.validityCheckDate;
                        void 0 === a && (a = new Date);
                        var o = !0,
                            u = null,
                            c = 0;
                        do {
                            var l = e.shift(),
                                f = null,
                                p = !1;
                            if (a && (a < l.validity.notBefore || a > l.validity.notAfter) && (u = {
                                    message: "Certificate is not valid yet or has expired.",
                                    error: s.certificateError.certificate_expired,
                                    notBefore: l.validity.notBefore,
                                    notAfter: l.validity.notAfter,
                                    now: a
                                }), null === u) {
                                if (null === (f = e[0] || t.getIssuer(l)) && l.isIssuer(l) && (p = !0, f = l), f) {
                                    var d = f;
                                    n.util.isArray(d) || (d = [d]);
                                    for (var g = !1; !g && d.length > 0;) {
                                        f = d.shift();
                                        try {
                                            g = f.verify(l)
                                        } catch (t) {}
                                    }
                                    g || (u = {
                                        message: "Certificate signature is invalid.",
                                        error: s.certificateError.bad_certificate
                                    })
                                }
                                null !== u || f && !p || t.hasCertificate(l) || (u = {
                                    message: "Certificate is not trusted.",
                                    error: s.certificateError.unknown_ca
                                })
                            }
                            if (null === u && f && !l.isIssuer(f) && (u = {
                                    message: "Certificate issuer is invalid.",
                                    error: s.certificateError.bad_certificate
                                }), null === u)
                                for (var y = {
                                        keyUsage: !0,
                                        basicConstraints: !0
                                    }, v = 0; null === u && v < l.extensions.length; ++v) {
                                    var m = l.extensions[v];
                                    m.critical && !(m.name in y) && (u = {
                                        message: "Certificate has an unsupported critical extension.",
                                        error: s.certificateError.unsupported_certificate
                                    })
                                }
                            if (null === u && (!o || 0 === e.length && (!f || p))) {
                                var E = l.getExtension("basicConstraints"),
                                    S = l.getExtension("keyUsage");
                                null !== S && (S.keyCertSign && null !== E || (u = {
                                    message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                                    error: s.certificateError.bad_certificate
                                })), null !== u || null === E || E.cA || (u = {
                                    message: "Certificate basicConstraints indicates the certificate is not a CA.",
                                    error: s.certificateError.bad_certificate
                                }), null === u && null !== S && "pathLenConstraint" in E && c - 1 > E.pathLenConstraint && (u = {
                                    message: "Certificate basicConstraints pathLenConstraint violated.",
                                    error: s.certificateError.bad_certificate
                                })
                            }
                            var b = null === u || u.error,
                                C = r.verify ? r.verify(b, c, i) : b;
                            if (!0 !== C) throw !0 === b && (u = {
                                message: "The application rejected the certificate.",
                                error: s.certificateError.bad_certificate
                            }), (C || 0 === C) && ("object" !== h(C) || n.util.isArray(C) ? "string" == typeof C && (u.error = C) : (C.message && (u.message = C.message), C.error && (u.error = C.error))), u;
                            u = null, o = !1, ++c
                        } while (e.length > 0);
                        return !0
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(2), r(1), (t.exports = n.pss = n.pss || {}).create = function(t) {
                        3 === arguments.length && (t = {
                            md: arguments[0],
                            mgf: arguments[1],
                            saltLength: arguments[2]
                        });
                        var e, r = t.md,
                            i = t.mgf,
                            s = r.digestLength,
                            a = t.salt || null;
                        if ("string" == typeof a && (a = n.util.createBuffer(a)), "saltLength" in t) e = t.saltLength;
                        else {
                            if (null === a) throw new Error("Salt length not specified or specific salt not given.");
                            e = a.length()
                        }
                        if (null !== a && a.length() !== e) throw new Error("Given salt length does not match length of given salt.");
                        var o = t.prng || n.random,
                            u = {
                                encode: function(t, u) {
                                    var c, h, l = u - 1,
                                        f = Math.ceil(l / 8),
                                        p = t.digest().getBytes();
                                    if (f < s + e + 2) throw new Error("Message is too long to encrypt.");
                                    h = null === a ? o.getBytesSync(e) : a.bytes();
                                    var d = new n.util.ByteBuffer;
                                    d.fillWithByte(0, 8), d.putBytes(p), d.putBytes(h), r.start(), r.update(d.getBytes());
                                    var g = r.digest().getBytes(),
                                        y = new n.util.ByteBuffer;
                                    y.fillWithByte(0, f - e - s - 2), y.putByte(1), y.putBytes(h);
                                    var v = y.getBytes(),
                                        m = f - s - 1,
                                        E = i.generate(g, m),
                                        S = "";
                                    for (c = 0; c < m; c++) S += String.fromCharCode(v.charCodeAt(c) ^ E.charCodeAt(c));
                                    var b = 65280 >> 8 * f - l & 255;
                                    return (S = String.fromCharCode(S.charCodeAt(0) & ~b) + S.substr(1)) + g + String.fromCharCode(188)
                                },
                                verify: function(t, a, o) {
                                    var u, c = o - 1,
                                        h = Math.ceil(c / 8);
                                    if (a = a.substr(-h), h < s + e + 2) throw new Error("Inconsistent parameters to PSS signature verification.");
                                    if (188 !== a.charCodeAt(h - 1)) throw new Error("Encoded message does not end in 0xBC.");
                                    var l = h - s - 1,
                                        f = a.substr(0, l),
                                        p = a.substr(l, s),
                                        d = 65280 >> 8 * h - c & 255;
                                    if (0 != (f.charCodeAt(0) & d)) throw new Error("Bits beyond keysize not zero as expected.");
                                    var g = i.generate(p, l),
                                        y = "";
                                    for (u = 0; u < l; u++) y += String.fromCharCode(f.charCodeAt(u) ^ g.charCodeAt(u));
                                    y = String.fromCharCode(y.charCodeAt(0) & ~d) + y.substr(1);
                                    var v = h - s - e - 2;
                                    for (u = 0; u < v; u++)
                                        if (0 !== y.charCodeAt(u)) throw new Error("Leftmost octets not zero as expected");
                                    if (1 !== y.charCodeAt(v)) throw new Error("Inconsistent PSS signature, 0x01 marker not found");
                                    var m = y.substr(-e),
                                        E = new n.util.ByteBuffer;
                                    return E.fillWithByte(0, 8), E.putBytes(t), E.putBytes(m), r.start(), r.update(E.getBytes()), p === r.digest().getBytes()
                                }
                            };
                        return u
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(1), n.cipher = n.cipher || {};
                    var i = t.exports = n.cipher.modes = n.cipher.modes || {};

                    function s(t, e) {
                        if ("string" == typeof t && (t = n.util.createBuffer(t)), n.util.isArray(t) && t.length > 4) {
                            var r = t;
                            t = n.util.createBuffer();
                            for (var i = 0; i < r.length; ++i) t.putByte(r[i])
                        }
                        if (t.length() < e) throw new Error("Invalid IV length; got " + t.length() + " bytes and expected " + e + " bytes.");
                        if (!n.util.isArray(t)) {
                            var s = [],
                                a = e / 4;
                            for (i = 0; i < a; ++i) s.push(t.getInt32());
                            t = s
                        }
                        return t
                    }

                    function a(t) {
                        t[t.length - 1] = t[t.length - 1] + 1 & 4294967295
                    }

                    function o(t) {
                        return [t / 4294967296 | 0, 4294967295 & t]
                    }
                    i.ecb = function(t) {
                        t = t || {}, this.name = "ECB", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints)
                    }, i.ecb.prototype.start = function(t) {}, i.ecb.prototype.encrypt = function(t, e, r) {
                        if (t.length() < this.blockSize && !(r && t.length() > 0)) return !0;
                        for (var n = 0; n < this._ints; ++n) this._inBlock[n] = t.getInt32();
                        for (this.cipher.encrypt(this._inBlock, this._outBlock), n = 0; n < this._ints; ++n) e.putInt32(this._outBlock[n])
                    }, i.ecb.prototype.decrypt = function(t, e, r) {
                        if (t.length() < this.blockSize && !(r && t.length() > 0)) return !0;
                        for (var n = 0; n < this._ints; ++n) this._inBlock[n] = t.getInt32();
                        for (this.cipher.decrypt(this._inBlock, this._outBlock), n = 0; n < this._ints; ++n) e.putInt32(this._outBlock[n])
                    }, i.ecb.prototype.pad = function(t, e) {
                        var r = t.length() === this.blockSize ? this.blockSize : this.blockSize - t.length();
                        return t.fillWithByte(r, r), !0
                    }, i.ecb.prototype.unpad = function(t, e) {
                        if (e.overflow > 0) return !1;
                        var r = t.length(),
                            n = t.at(r - 1);
                        return !(n > this.blockSize << 2 || (t.truncate(n), 0))
                    }, i.cbc = function(t) {
                        t = t || {}, this.name = "CBC", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints)
                    }, i.cbc.prototype.start = function(t) {
                        if (null === t.iv) {
                            if (!this._prev) throw new Error("Invalid IV parameter.");
                            this._iv = this._prev.slice(0)
                        } else {
                            if (!("iv" in t)) throw new Error("Invalid IV parameter.");
                            this._iv = s(t.iv, this.blockSize), this._prev = this._iv.slice(0)
                        }
                    }, i.cbc.prototype.encrypt = function(t, e, r) {
                        if (t.length() < this.blockSize && !(r && t.length() > 0)) return !0;
                        for (var n = 0; n < this._ints; ++n) this._inBlock[n] = this._prev[n] ^ t.getInt32();
                        for (this.cipher.encrypt(this._inBlock, this._outBlock), n = 0; n < this._ints; ++n) e.putInt32(this._outBlock[n]);
                        this._prev = this._outBlock
                    }, i.cbc.prototype.decrypt = function(t, e, r) {
                        if (t.length() < this.blockSize && !(r && t.length() > 0)) return !0;
                        for (var n = 0; n < this._ints; ++n) this._inBlock[n] = t.getInt32();
                        for (this.cipher.decrypt(this._inBlock, this._outBlock), n = 0; n < this._ints; ++n) e.putInt32(this._prev[n] ^ this._outBlock[n]);
                        this._prev = this._inBlock.slice(0)
                    }, i.cbc.prototype.pad = function(t, e) {
                        var r = t.length() === this.blockSize ? this.blockSize : this.blockSize - t.length();
                        return t.fillWithByte(r, r), !0
                    }, i.cbc.prototype.unpad = function(t, e) {
                        if (e.overflow > 0) return !1;
                        var r = t.length(),
                            n = t.at(r - 1);
                        return !(n > this.blockSize << 2 || (t.truncate(n), 0))
                    }, i.cfb = function(t) {
                        t = t || {}, this.name = "CFB", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = n.util.createBuffer(), this._partialBytes = 0
                    }, i.cfb.prototype.start = function(t) {
                        if (!("iv" in t)) throw new Error("Invalid IV parameter.");
                        this._iv = s(t.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0
                    }, i.cfb.prototype.encrypt = function(t, e, r) {
                        var n = t.length();
                        if (0 === n) return !0;
                        if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && n >= this.blockSize)
                            for (var i = 0; i < this._ints; ++i) this._inBlock[i] = t.getInt32() ^ this._outBlock[i], e.putInt32(this._inBlock[i]);
                        else {
                            var s = (this.blockSize - n) % this.blockSize;
                            for (s > 0 && (s = this.blockSize - s), this._partialOutput.clear(), i = 0; i < this._ints; ++i) this._partialBlock[i] = t.getInt32() ^ this._outBlock[i], this._partialOutput.putInt32(this._partialBlock[i]);
                            if (s > 0) t.read -= this.blockSize;
                            else
                                for (i = 0; i < this._ints; ++i) this._inBlock[i] = this._partialBlock[i];
                            if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !r) return e.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), this._partialBytes = s, !0;
                            e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), this._partialBytes = 0
                        }
                    }, i.cfb.prototype.decrypt = function(t, e, r) {
                        var n = t.length();
                        if (0 === n) return !0;
                        if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && n >= this.blockSize)
                            for (var i = 0; i < this._ints; ++i) this._inBlock[i] = t.getInt32(), e.putInt32(this._inBlock[i] ^ this._outBlock[i]);
                        else {
                            var s = (this.blockSize - n) % this.blockSize;
                            for (s > 0 && (s = this.blockSize - s), this._partialOutput.clear(), i = 0; i < this._ints; ++i) this._partialBlock[i] = t.getInt32(), this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
                            if (s > 0) t.read -= this.blockSize;
                            else
                                for (i = 0; i < this._ints; ++i) this._inBlock[i] = this._partialBlock[i];
                            if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !r) return e.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), this._partialBytes = s, !0;
                            e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), this._partialBytes = 0
                        }
                    }, i.ofb = function(t) {
                        t = t || {}, this.name = "OFB", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = n.util.createBuffer(), this._partialBytes = 0
                    }, i.ofb.prototype.start = function(t) {
                        if (!("iv" in t)) throw new Error("Invalid IV parameter.");
                        this._iv = s(t.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0
                    }, i.ofb.prototype.encrypt = function(t, e, r) {
                        var n = t.length();
                        if (0 === t.length()) return !0;
                        if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && n >= this.blockSize)
                            for (var i = 0; i < this._ints; ++i) e.putInt32(t.getInt32() ^ this._outBlock[i]), this._inBlock[i] = this._outBlock[i];
                        else {
                            var s = (this.blockSize - n) % this.blockSize;
                            for (s > 0 && (s = this.blockSize - s), this._partialOutput.clear(), i = 0; i < this._ints; ++i) this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[i]);
                            if (s > 0) t.read -= this.blockSize;
                            else
                                for (i = 0; i < this._ints; ++i) this._inBlock[i] = this._outBlock[i];
                            if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !r) return e.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), this._partialBytes = s, !0;
                            e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), this._partialBytes = 0
                        }
                    }, i.ofb.prototype.decrypt = i.ofb.prototype.encrypt, i.ctr = function(t) {
                        t = t || {}, this.name = "CTR", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = n.util.createBuffer(), this._partialBytes = 0
                    }, i.ctr.prototype.start = function(t) {
                        if (!("iv" in t)) throw new Error("Invalid IV parameter.");
                        this._iv = s(t.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0
                    }, i.ctr.prototype.encrypt = function(t, e, r) {
                        var n = t.length();
                        if (0 === n) return !0;
                        if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && n >= this.blockSize)
                            for (var i = 0; i < this._ints; ++i) e.putInt32(t.getInt32() ^ this._outBlock[i]);
                        else {
                            var s = (this.blockSize - n) % this.blockSize;
                            for (s > 0 && (s = this.blockSize - s), this._partialOutput.clear(), i = 0; i < this._ints; ++i) this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[i]);
                            if (s > 0 && (t.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !r) return e.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), this._partialBytes = s, !0;
                            e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), this._partialBytes = 0
                        }
                        a(this._inBlock)
                    }, i.ctr.prototype.decrypt = i.ctr.prototype.encrypt, i.gcm = function(t) {
                        t = t || {}, this.name = "GCM", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = n.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600
                    }, i.gcm.prototype.start = function(t) {
                        if (!("iv" in t)) throw new Error("Invalid IV parameter.");
                        var e, r = n.util.createBuffer(t.iv);
                        if (this._cipherLength = 0, e = "additionalData" in t ? n.util.createBuffer(t.additionalData) : n.util.createBuffer(), this._tagLength = "tagLength" in t ? t.tagLength : 128, this._tag = null, t.decrypt && (this._tag = n.util.createBuffer(t.tag).getBytes(), this._tag.length !== this._tagLength / 8)) throw new Error("Authentication tag does not match tag length.");
                        this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
                        var i = r.length();
                        if (12 === i) this._j0 = [r.getInt32(), r.getInt32(), r.getInt32(), 1];
                        else {
                            for (this._j0 = [0, 0, 0, 0]; r.length() > 0;) this._j0 = this.ghash(this._hashSubkey, this._j0, [r.getInt32(), r.getInt32(), r.getInt32(), r.getInt32()]);
                            this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(o(8 * i)))
                        }
                        this._inBlock = this._j0.slice(0), a(this._inBlock), this._partialBytes = 0, e = n.util.createBuffer(e), this._aDataLength = o(8 * e.length());
                        var s = e.length() % this.blockSize;
                        for (s && e.fillWithByte(0, this.blockSize - s), this._s = [0, 0, 0, 0]; e.length() > 0;) this._s = this.ghash(this._hashSubkey, this._s, [e.getInt32(), e.getInt32(), e.getInt32(), e.getInt32()])
                    }, i.gcm.prototype.encrypt = function(t, e, r) {
                        var n = t.length();
                        if (0 === n) return !0;
                        if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && n >= this.blockSize) {
                            for (var i = 0; i < this._ints; ++i) e.putInt32(this._outBlock[i] ^= t.getInt32());
                            this._cipherLength += this.blockSize
                        } else {
                            var s = (this.blockSize - n) % this.blockSize;
                            for (s > 0 && (s = this.blockSize - s), this._partialOutput.clear(), i = 0; i < this._ints; ++i) this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[i]);
                            if (s <= 0 || r) {
                                if (r) {
                                    var o = n % this.blockSize;
                                    this._cipherLength += o, this._partialOutput.truncate(this.blockSize - o)
                                } else this._cipherLength += this.blockSize;
                                for (i = 0; i < this._ints; ++i) this._outBlock[i] = this._partialOutput.getInt32();
                                this._partialOutput.read -= this.blockSize
                            }
                            if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !r) return t.read -= this.blockSize, e.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), this._partialBytes = s, !0;
                            e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), this._partialBytes = 0
                        }
                        this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), a(this._inBlock)
                    }, i.gcm.prototype.decrypt = function(t, e, r) {
                        var n = t.length();
                        if (n < this.blockSize && !(r && n > 0)) return !0;
                        this.cipher.encrypt(this._inBlock, this._outBlock), a(this._inBlock), this._hashBlock[0] = t.getInt32(), this._hashBlock[1] = t.getInt32(), this._hashBlock[2] = t.getInt32(), this._hashBlock[3] = t.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
                        for (var i = 0; i < this._ints; ++i) e.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
                        n < this.blockSize ? this._cipherLength += n % this.blockSize : this._cipherLength += this.blockSize
                    }, i.gcm.prototype.afterFinish = function(t, e) {
                        var r = !0;
                        e.decrypt && e.overflow && t.truncate(this.blockSize - e.overflow), this.tag = n.util.createBuffer();
                        var i = this._aDataLength.concat(o(8 * this._cipherLength));
                        this._s = this.ghash(this._hashSubkey, this._s, i);
                        var s = [];
                        this.cipher.encrypt(this._j0, s);
                        for (var a = 0; a < this._ints; ++a) this.tag.putInt32(this._s[a] ^ s[a]);
                        return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), e.decrypt && this.tag.bytes() !== this._tag && (r = !1), r
                    }, i.gcm.prototype.multiply = function(t, e) {
                        for (var r = [0, 0, 0, 0], n = e.slice(0), i = 0; i < 128; ++i) t[i / 32 | 0] & 1 << 31 - i % 32 && (r[0] ^= n[0], r[1] ^= n[1], r[2] ^= n[2], r[3] ^= n[3]), this.pow(n, n);
                        return r
                    }, i.gcm.prototype.pow = function(t, e) {
                        for (var r = 1 & t[3], n = 3; n > 0; --n) e[n] = t[n] >>> 1 | (1 & t[n - 1]) << 31;
                        e[0] = t[0] >>> 1, r && (e[0] ^= this._R)
                    }, i.gcm.prototype.tableMultiply = function(t) {
                        for (var e = [0, 0, 0, 0], r = 0; r < 32; ++r) {
                            var n = t[r / 8 | 0] >>> 4 * (7 - r % 8) & 15,
                                i = this._m[r][n];
                            e[0] ^= i[0], e[1] ^= i[1], e[2] ^= i[2], e[3] ^= i[3]
                        }
                        return e
                    }, i.gcm.prototype.ghash = function(t, e, r) {
                        return e[0] ^= r[0], e[1] ^= r[1], e[2] ^= r[2], e[3] ^= r[3], this.tableMultiply(e)
                    }, i.gcm.prototype.generateHashTable = function(t, e) {
                        for (var r = 8 / e, n = 4 * r, i = 16 * r, s = new Array(i), a = 0; a < i; ++a) {
                            var o = [0, 0, 0, 0],
                                u = (n - 1 - a % n) * e;
                            o[a / n | 0] = 1 << e - 1 << u, s[a] = this.generateSubHashTable(this.multiply(o, t), e)
                        }
                        return s
                    }, i.gcm.prototype.generateSubHashTable = function(t, e) {
                        var r = 1 << e,
                            n = r >>> 1,
                            i = new Array(r);
                        i[n] = t.slice(0);
                        for (var s = n >>> 1; s > 0;) this.pow(i[2 * s], i[s] = []), s >>= 1;
                        for (s = 2; s < n;) {
                            for (var a = 1; a < s; ++a) {
                                var o = i[s],
                                    u = i[a];
                                i[s + a] = [o[0] ^ u[0], o[1] ^ u[1], o[2] ^ u[2], o[3] ^ u[3]]
                            }
                            s *= 2
                        }
                        for (i[0] = [0, 0, 0, 0], s = n + 1; s < r; ++s) {
                            var c = i[s ^ n];
                            i[s] = [t[0] ^ c[0], t[1] ^ c[1], t[2] ^ c[2], t[3] ^ c[3]]
                        }
                        return i
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(3), r(8), r(14), r(7), r(21), r(2), r(9), r(1);
                    var i = function(t, e, r, i) {
                            var s = n.util.createBuffer(),
                                a = t.length >> 1,
                                o = a + (1 & t.length),
                                u = t.substr(0, o),
                                c = t.substr(a, o),
                                h = n.util.createBuffer(),
                                l = n.hmac.create();
                            r = e + r;
                            var f = Math.ceil(i / 16),
                                p = Math.ceil(i / 20);
                            l.start("MD5", u);
                            var d = n.util.createBuffer();
                            h.putBytes(r);
                            for (var g = 0; g < f; ++g) l.start(null, null), l.update(h.getBytes()), h.putBuffer(l.digest()), l.start(null, null), l.update(h.bytes() + r), d.putBuffer(l.digest());
                            l.start("SHA1", c);
                            var y = n.util.createBuffer();
                            for (h.clear(), h.putBytes(r), g = 0; g < p; ++g) l.start(null, null), l.update(h.getBytes()), h.putBuffer(l.digest()), l.start(null, null), l.update(h.bytes() + r), y.putBuffer(l.digest());
                            return s.putBytes(n.util.xorBytes(d.getBytes(), y.getBytes(), i)), s
                        },
                        s = function(t, e, r) {
                            var i = !1;
                            try {
                                var s = t.deflate(e.fragment.getBytes());
                                e.fragment = n.util.createBuffer(s), e.length = s.length, i = !0
                            } catch (t) {}
                            return i
                        },
                        a = function(t, e, r) {
                            var i = !1;
                            try {
                                var s = t.inflate(e.fragment.getBytes());
                                e.fragment = n.util.createBuffer(s), e.length = s.length, i = !0
                            } catch (t) {}
                            return i
                        },
                        o = function(t, e) {
                            var r = 0;
                            switch (e) {
                                case 1:
                                    r = t.getByte();
                                    break;
                                case 2:
                                    r = t.getInt16();
                                    break;
                                case 3:
                                    r = t.getInt24();
                                    break;
                                case 4:
                                    r = t.getInt32()
                            }
                            return n.util.createBuffer(t.getBytes(r))
                        },
                        u = function(t, e, r) {
                            t.putInt(r.length(), e << 3), t.putBuffer(r)
                        },
                        c = {
                            Versions: {
                                TLS_1_0: {
                                    major: 3,
                                    minor: 1
                                },
                                TLS_1_1: {
                                    major: 3,
                                    minor: 2
                                },
                                TLS_1_2: {
                                    major: 3,
                                    minor: 3
                                }
                            }
                        };
                    c.SupportedVersions = [c.Versions.TLS_1_1, c.Versions.TLS_1_0], c.Version = c.SupportedVersions[0], c.MaxFragment = 15360, c.ConnectionEnd = {
                        server: 0,
                        client: 1
                    }, c.PRFAlgorithm = {
                        tls_prf_sha256: 0
                    }, c.BulkCipherAlgorithm = {
                        none: null,
                        rc4: 0,
                        des3: 1,
                        aes: 2
                    }, c.CipherType = {
                        stream: 0,
                        block: 1,
                        aead: 2
                    }, c.MACAlgorithm = {
                        none: null,
                        hmac_md5: 0,
                        hmac_sha1: 1,
                        hmac_sha256: 2,
                        hmac_sha384: 3,
                        hmac_sha512: 4
                    }, c.CompressionMethod = {
                        none: 0,
                        deflate: 1
                    }, c.ContentType = {
                        change_cipher_spec: 20,
                        alert: 21,
                        handshake: 22,
                        application_data: 23,
                        heartbeat: 24
                    }, c.HandshakeType = {
                        hello_request: 0,
                        client_hello: 1,
                        server_hello: 2,
                        certificate: 11,
                        server_key_exchange: 12,
                        certificate_request: 13,
                        server_hello_done: 14,
                        certificate_verify: 15,
                        client_key_exchange: 16,
                        finished: 20
                    }, c.Alert = {}, c.Alert.Level = {
                        warning: 1,
                        fatal: 2
                    }, c.Alert.Description = {
                        close_notify: 0,
                        unexpected_message: 10,
                        bad_record_mac: 20,
                        decryption_failed: 21,
                        record_overflow: 22,
                        decompression_failure: 30,
                        handshake_failure: 40,
                        bad_certificate: 42,
                        unsupported_certificate: 43,
                        certificate_revoked: 44,
                        certificate_expired: 45,
                        certificate_unknown: 46,
                        illegal_parameter: 47,
                        unknown_ca: 48,
                        access_denied: 49,
                        decode_error: 50,
                        decrypt_error: 51,
                        export_restriction: 60,
                        protocol_version: 70,
                        insufficient_security: 71,
                        internal_error: 80,
                        user_canceled: 90,
                        no_renegotiation: 100
                    }, c.HeartbeatMessageType = {
                        heartbeat_request: 1,
                        heartbeat_response: 2
                    }, c.CipherSuites = {}, c.getCipherSuite = function(t) {
                        var e = null;
                        for (var r in c.CipherSuites) {
                            var n = c.CipherSuites[r];
                            if (n.id[0] === t.charCodeAt(0) && n.id[1] === t.charCodeAt(1)) {
                                e = n;
                                break
                            }
                        }
                        return e
                    }, c.handleUnexpected = function(t, e) {
                        !t.open && t.entity === c.ConnectionEnd.client || t.error(t, {
                            message: "Unexpected message. Received TLS record out of order.",
                            send: !0,
                            alert: {
                                level: c.Alert.Level.fatal,
                                description: c.Alert.Description.unexpected_message
                            }
                        })
                    }, c.handleHelloRequest = function(t, e, r) {
                        !t.handshaking && t.handshakes > 0 && (c.queue(t, c.createAlert(t, {
                            level: c.Alert.Level.warning,
                            description: c.Alert.Description.no_renegotiation
                        })), c.flush(t)), t.process()
                    }, c.parseHelloMessage = function(t, e, r) {
                        var i = null,
                            s = t.entity === c.ConnectionEnd.client;
                        if (r < 38) t.error(t, {
                            message: s ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
                            send: !0,
                            alert: {
                                level: c.Alert.Level.fatal,
                                description: c.Alert.Description.illegal_parameter
                            }
                        });
                        else {
                            var a = e.fragment,
                                u = a.length();
                            if (i = {
                                    version: {
                                        major: a.getByte(),
                                        minor: a.getByte()
                                    },
                                    random: n.util.createBuffer(a.getBytes(32)),
                                    session_id: o(a, 1),
                                    extensions: []
                                }, s ? (i.cipher_suite = a.getBytes(2), i.compression_method = a.getByte()) : (i.cipher_suites = o(a, 2), i.compression_methods = o(a, 1)), (u = r - (u - a.length())) > 0) {
                                for (var h = o(a, 2); h.length() > 0;) i.extensions.push({
                                    type: [h.getByte(), h.getByte()],
                                    data: o(h, 2)
                                });
                                if (!s)
                                    for (var l = 0; l < i.extensions.length; ++l) {
                                        var f = i.extensions[l];
                                        if (0 === f.type[0] && 0 === f.type[1])
                                            for (var p = o(f.data, 2); p.length() > 0 && 0 === p.getByte();) t.session.extensions.server_name.serverNameList.push(o(p, 2).getBytes())
                                    }
                            }
                            if (t.session.version && (i.version.major !== t.session.version.major || i.version.minor !== t.session.version.minor)) return t.error(t, {
                                message: "TLS version change is disallowed during renegotiation.",
                                send: !0,
                                alert: {
                                    level: c.Alert.Level.fatal,
                                    description: c.Alert.Description.protocol_version
                                }
                            });
                            if (s) t.session.cipherSuite = c.getCipherSuite(i.cipher_suite);
                            else
                                for (var d = n.util.createBuffer(i.cipher_suites.bytes()); d.length() > 0 && (t.session.cipherSuite = c.getCipherSuite(d.getBytes(2)), null === t.session.cipherSuite););
                            if (null === t.session.cipherSuite) return t.error(t, {
                                message: "No cipher suites in common.",
                                send: !0,
                                alert: {
                                    level: c.Alert.Level.fatal,
                                    description: c.Alert.Description.handshake_failure
                                },
                                cipherSuite: n.util.bytesToHex(i.cipher_suite)
                            });
                            t.session.compressionMethod = s ? i.compression_method : c.CompressionMethod.none
                        }
                        return i
                    }, c.createSecurityParameters = function(t, e) {
                        var r = t.entity === c.ConnectionEnd.client,
                            n = e.random.bytes(),
                            i = r ? t.session.sp.client_random : n,
                            s = r ? n : c.createRandom().getBytes();
                        t.session.sp = {
                            entity: t.entity,
                            prf_algorithm: c.PRFAlgorithm.tls_prf_sha256,
                            bulk_cipher_algorithm: null,
                            cipher_type: null,
                            enc_key_length: null,
                            block_length: null,
                            fixed_iv_length: null,
                            record_iv_length: null,
                            mac_algorithm: null,
                            mac_length: null,
                            mac_key_length: null,
                            compression_algorithm: t.session.compressionMethod,
                            pre_master_secret: null,
                            master_secret: null,
                            client_random: i,
                            server_random: s
                        }
                    }, c.handleServerHello = function(t, e, r) {
                        var n = c.parseHelloMessage(t, e, r);
                        if (!t.fail) {
                            if (!(n.version.minor <= t.version.minor)) return t.error(t, {
                                message: "Incompatible TLS version.",
                                send: !0,
                                alert: {
                                    level: c.Alert.Level.fatal,
                                    description: c.Alert.Description.protocol_version
                                }
                            });
                            t.version.minor = n.version.minor, t.session.version = t.version;
                            var i = n.session_id.bytes();
                            i.length > 0 && i === t.session.id ? (t.expect = g, t.session.resuming = !0, t.session.sp.server_random = n.random.bytes()) : (t.expect = l, t.session.resuming = !1, c.createSecurityParameters(t, n)), t.session.id = i, t.process()
                        }
                    }, c.handleClientHello = function(t, e, r) {
                        var i = c.parseHelloMessage(t, e, r);
                        if (!t.fail) {
                            var s = i.session_id.bytes(),
                                a = null;
                            if (t.sessionCache && (null === (a = t.sessionCache.getSession(s)) ? s = "" : (a.version.major !== i.version.major || a.version.minor > i.version.minor) && (a = null, s = "")), 0 === s.length && (s = n.random.getBytes(32)), t.session.id = s, t.session.clientHelloVersion = i.version, t.session.sp = {}, a) t.version = t.session.version = a.version, t.session.sp = a.sp;
                            else {
                                for (var o, u = 1; u < c.SupportedVersions.length && !((o = c.SupportedVersions[u]).minor <= i.version.minor); ++u);
                                t.version = {
                                    major: o.major,
                                    minor: o.minor
                                }, t.session.version = t.version
                            }
                            null !== a ? (t.expect = C, t.session.resuming = !0, t.session.sp.client_random = i.random.bytes()) : (t.expect = !1 !== t.verifyClient ? E : S, t.session.resuming = !1, c.createSecurityParameters(t, i)), t.open = !0, c.queue(t, c.createRecord(t, {
                                type: c.ContentType.handshake,
                                data: c.createServerHello(t)
                            })), t.session.resuming ? (c.queue(t, c.createRecord(t, {
                                type: c.ContentType.change_cipher_spec,
                                data: c.createChangeCipherSpec()
                            })), t.state.pending = c.createConnectionState(t), t.state.current.write = t.state.pending.write, c.queue(t, c.createRecord(t, {
                                type: c.ContentType.handshake,
                                data: c.createFinished(t)
                            }))) : (c.queue(t, c.createRecord(t, {
                                type: c.ContentType.handshake,
                                data: c.createCertificate(t)
                            })), t.fail || (c.queue(t, c.createRecord(t, {
                                type: c.ContentType.handshake,
                                data: c.createServerKeyExchange(t)
                            })), !1 !== t.verifyClient && c.queue(t, c.createRecord(t, {
                                type: c.ContentType.handshake,
                                data: c.createCertificateRequest(t)
                            })), c.queue(t, c.createRecord(t, {
                                type: c.ContentType.handshake,
                                data: c.createServerHelloDone(t)
                            })))), c.flush(t), t.process()
                        }
                    }, c.handleCertificate = function(t, e, r) {
                        if (r < 3) return t.error(t, {
                            message: "Invalid Certificate message. Message too short.",
                            send: !0,
                            alert: {
                                level: c.Alert.Level.fatal,
                                description: c.Alert.Description.illegal_parameter
                            }
                        });
                        var i, s, a = e.fragment,
                            u = {
                                certificate_list: o(a, 3)
                            },
                            h = [];
                        try {
                            for (; u.certificate_list.length() > 0;) i = o(u.certificate_list, 3), s = n.asn1.fromDer(i), i = n.pki.certificateFromAsn1(s, !0), h.push(i)
                        } catch (e) {
                            return t.error(t, {
                                message: "Could not parse certificate list.",
                                cause: e,
                                send: !0,
                                alert: {
                                    level: c.Alert.Level.fatal,
                                    description: c.Alert.Description.bad_certificate
                                }
                            })
                        }
                        var l = t.entity === c.ConnectionEnd.client;
                        !l && !0 !== t.verifyClient || 0 !== h.length ? 0 === h.length ? t.expect = l ? f : S : (l ? t.session.serverCertificate = h[0] : t.session.clientCertificate = h[0], c.verifyCertificateChain(t, h) && (t.expect = l ? f : S)) : t.error(t, {
                            message: l ? "No server certificate provided." : "No client certificate provided.",
                            send: !0,
                            alert: {
                                level: c.Alert.Level.fatal,
                                description: c.Alert.Description.illegal_parameter
                            }
                        }), t.process()
                    }, c.handleServerKeyExchange = function(t, e, r) {
                        if (r > 0) return t.error(t, {
                            message: "Invalid key parameters. Only RSA is supported.",
                            send: !0,
                            alert: {
                                level: c.Alert.Level.fatal,
                                description: c.Alert.Description.unsupported_certificate
                            }
                        });
                        t.expect = p, t.process()
                    }, c.handleClientKeyExchange = function(t, e, r) {
                        if (r < 48) return t.error(t, {
                            message: "Invalid key parameters. Only RSA is supported.",
                            send: !0,
                            alert: {
                                level: c.Alert.Level.fatal,
                                description: c.Alert.Description.unsupported_certificate
                            }
                        });
                        var i = e.fragment,
                            s = {
                                enc_pre_master_secret: o(i, 2).getBytes()
                            },
                            a = null;
                        if (t.getPrivateKey) try {
                            a = t.getPrivateKey(t, t.session.serverCertificate), a = n.pki.privateKeyFromPem(a)
                        } catch (e) {
                            t.error(t, {
                                message: "Could not get private key.",
                                cause: e,
                                send: !0,
                                alert: {
                                    level: c.Alert.Level.fatal,
                                    description: c.Alert.Description.internal_error
                                }
                            })
                        }
                        if (null === a) return t.error(t, {
                            message: "No private key set.",
                            send: !0,
                            alert: {
                                level: c.Alert.Level.fatal,
                                description: c.Alert.Description.internal_error
                            }
                        });
                        try {
                            var u = t.session.sp;
                            u.pre_master_secret = a.decrypt(s.enc_pre_master_secret);
                            var h = t.session.clientHelloVersion;
                            if (h.major !== u.pre_master_secret.charCodeAt(0) || h.minor !== u.pre_master_secret.charCodeAt(1)) throw new Error("TLS version rollback attack detected.")
                        } catch (t) {
                            u.pre_master_secret = n.random.getBytes(48)
                        }
                        t.expect = C, null !== t.session.clientCertificate && (t.expect = b), t.process()
                    }, c.handleCertificateRequest = function(t, e, r) {
                        if (r < 3) return t.error(t, {
                            message: "Invalid CertificateRequest. Message too short.",
                            send: !0,
                            alert: {
                                level: c.Alert.Level.fatal,
                                description: c.Alert.Description.illegal_parameter
                            }
                        });
                        var n = e.fragment,
                            i = {
                                certificate_types: o(n, 1),
                                certificate_authorities: o(n, 2)
                            };
                        t.session.certificateRequest = i, t.expect = d, t.process()
                    }, c.handleCertificateVerify = function(t, e, r) {
                        if (r < 2) return t.error(t, {
                            message: "Invalid CertificateVerify. Message too short.",
                            send: !0,
                            alert: {
                                level: c.Alert.Level.fatal,
                                description: c.Alert.Description.illegal_parameter
                            }
                        });
                        var i = e.fragment;
                        i.read -= 4;
                        var s = i.bytes();
                        i.read += 4;
                        var a = {
                                signature: o(i, 2).getBytes()
                            },
                            u = n.util.createBuffer();
                        u.putBuffer(t.session.md5.digest()), u.putBuffer(t.session.sha1.digest()), u = u.getBytes();
                        try {
                            if (!t.session.clientCertificate.publicKey.verify(u, a.signature, "NONE")) throw new Error("CertificateVerify signature does not match.");
                            t.session.md5.update(s), t.session.sha1.update(s)
                        } catch (e) {
                            return t.error(t, {
                                message: "Bad signature in CertificateVerify.",
                                send: !0,
                                alert: {
                                    level: c.Alert.Level.fatal,
                                    description: c.Alert.Description.handshake_failure
                                }
                            })
                        }
                        t.expect = C, t.process()
                    }, c.handleServerHelloDone = function(t, e, r) {
                        if (r > 0) return t.error(t, {
                            message: "Invalid ServerHelloDone message. Invalid length.",
                            send: !0,
                            alert: {
                                level: c.Alert.Level.fatal,
                                description: c.Alert.Description.record_overflow
                            }
                        });
                        if (null === t.serverCertificate) {
                            var i = {
                                    message: "No server certificate provided. Not enough security.",
                                    send: !0,
                                    alert: {
                                        level: c.Alert.Level.fatal,
                                        description: c.Alert.Description.insufficient_security
                                    }
                                },
                                s = t.verify(t, i.alert.description, 0, []);
                            if (!0 !== s) return (s || 0 === s) && ("object" !== h(s) || n.util.isArray(s) ? "number" == typeof s && (i.alert.description = s) : (s.message && (i.message = s.message), s.alert && (i.alert.description = s.alert))), t.error(t, i)
                        }
                        null !== t.session.certificateRequest && (e = c.createRecord(t, {
                            type: c.ContentType.handshake,
                            data: c.createCertificate(t)
                        }), c.queue(t, e)), e = c.createRecord(t, {
                            type: c.ContentType.handshake,
                            data: c.createClientKeyExchange(t)
                        }), c.queue(t, e), t.expect = m;
                        var a = function(t, e) {
                            null !== t.session.certificateRequest && null !== t.session.clientCertificate && c.queue(t, c.createRecord(t, {
                                type: c.ContentType.handshake,
                                data: c.createCertificateVerify(t, e)
                            })), c.queue(t, c.createRecord(t, {
                                type: c.ContentType.change_cipher_spec,
                                data: c.createChangeCipherSpec()
                            })), t.state.pending = c.createConnectionState(t), t.state.current.write = t.state.pending.write, c.queue(t, c.createRecord(t, {
                                type: c.ContentType.handshake,
                                data: c.createFinished(t)
                            })), t.expect = g, c.flush(t), t.process()
                        };
                        if (null === t.session.certificateRequest || null === t.session.clientCertificate) return a(t, null);
                        c.getClientSignature(t, a)
                    }, c.handleChangeCipherSpec = function(t, e) {
                        if (1 !== e.fragment.getByte()) return t.error(t, {
                            message: "Invalid ChangeCipherSpec message received.",
                            send: !0,
                            alert: {
                                level: c.Alert.Level.fatal,
                                description: c.Alert.Description.illegal_parameter
                            }
                        });
                        var r = t.entity === c.ConnectionEnd.client;
                        (t.session.resuming && r || !t.session.resuming && !r) && (t.state.pending = c.createConnectionState(t)), t.state.current.read = t.state.pending.read, (!t.session.resuming && r || t.session.resuming && !r) && (t.state.pending = null), t.expect = r ? y : A, t.process()
                    }, c.handleFinished = function(t, e, r) {
                        var s = e.fragment;
                        s.read -= 4;
                        var a = s.bytes();
                        s.read += 4;
                        var o = e.fragment.getBytes();
                        (s = n.util.createBuffer()).putBuffer(t.session.md5.digest()), s.putBuffer(t.session.sha1.digest());
                        var u = t.entity === c.ConnectionEnd.client,
                            h = u ? "server finished" : "client finished",
                            l = t.session.sp;
                        if ((s = i(l.master_secret, h, s.getBytes(), 12)).getBytes() !== o) return t.error(t, {
                            message: "Invalid verify_data in Finished message.",
                            send: !0,
                            alert: {
                                level: c.Alert.Level.fatal,
                                description: c.Alert.Description.decrypt_error
                            }
                        });
                        t.session.md5.update(a), t.session.sha1.update(a), (t.session.resuming && u || !t.session.resuming && !u) && (c.queue(t, c.createRecord(t, {
                            type: c.ContentType.change_cipher_spec,
                            data: c.createChangeCipherSpec()
                        })), t.state.current.write = t.state.pending.write, t.state.pending = null, c.queue(t, c.createRecord(t, {
                            type: c.ContentType.handshake,
                            data: c.createFinished(t)
                        }))), t.expect = u ? v : w, t.handshaking = !1, ++t.handshakes, t.peerCertificate = u ? t.session.serverCertificate : t.session.clientCertificate, c.flush(t), t.isConnected = !0, t.connected(t), t.process()
                    }, c.handleAlert = function(t, e) {
                        var r, n = e.fragment,
                            i = {
                                level: n.getByte(),
                                description: n.getByte()
                            };
                        switch (i.description) {
                            case c.Alert.Description.close_notify:
                                r = "Connection closed.";
                                break;
                            case c.Alert.Description.unexpected_message:
                                r = "Unexpected message.";
                                break;
                            case c.Alert.Description.bad_record_mac:
                                r = "Bad record MAC.";
                                break;
                            case c.Alert.Description.decryption_failed:
                                r = "Decryption failed.";
                                break;
                            case c.Alert.Description.record_overflow:
                                r = "Record overflow.";
                                break;
                            case c.Alert.Description.decompression_failure:
                                r = "Decompression failed.";
                                break;
                            case c.Alert.Description.handshake_failure:
                                r = "Handshake failure.";
                                break;
                            case c.Alert.Description.bad_certificate:
                                r = "Bad certificate.";
                                break;
                            case c.Alert.Description.unsupported_certificate:
                                r = "Unsupported certificate.";
                                break;
                            case c.Alert.Description.certificate_revoked:
                                r = "Certificate revoked.";
                                break;
                            case c.Alert.Description.certificate_expired:
                                r = "Certificate expired.";
                                break;
                            case c.Alert.Description.certificate_unknown:
                                r = "Certificate unknown.";
                                break;
                            case c.Alert.Description.illegal_parameter:
                                r = "Illegal parameter.";
                                break;
                            case c.Alert.Description.unknown_ca:
                                r = "Unknown certificate authority.";
                                break;
                            case c.Alert.Description.access_denied:
                                r = "Access denied.";
                                break;
                            case c.Alert.Description.decode_error:
                                r = "Decode error.";
                                break;
                            case c.Alert.Description.decrypt_error:
                                r = "Decrypt error.";
                                break;
                            case c.Alert.Description.export_restriction:
                                r = "Export restriction.";
                                break;
                            case c.Alert.Description.protocol_version:
                                r = "Unsupported protocol version.";
                                break;
                            case c.Alert.Description.insufficient_security:
                                r = "Insufficient security.";
                                break;
                            case c.Alert.Description.internal_error:
                                r = "Internal error.";
                                break;
                            case c.Alert.Description.user_canceled:
                                r = "User canceled.";
                                break;
                            case c.Alert.Description.no_renegotiation:
                                r = "Renegotiation not supported.";
                                break;
                            default:
                                r = "Unknown error."
                        }
                        if (i.description === c.Alert.Description.close_notify) return t.close();
                        t.error(t, {
                            message: r,
                            send: !1,
                            origin: t.entity === c.ConnectionEnd.client ? "server" : "client",
                            alert: i
                        }), t.process()
                    }, c.handleHandshake = function(t, e) {
                        var r = e.fragment,
                            i = r.getByte(),
                            s = r.getInt24();
                        if (s > r.length()) return t.fragmented = e, e.fragment = n.util.createBuffer(), r.read -= 4, t.process();
                        t.fragmented = null, r.read -= 4;
                        var a = r.bytes(s + 4);
                        r.read += 4, i in V[t.entity][t.expect] ? (t.entity !== c.ConnectionEnd.server || t.open || t.fail || (t.handshaking = !0, t.session = {
                            version: null,
                            extensions: {
                                server_name: {
                                    serverNameList: []
                                }
                            },
                            cipherSuite: null,
                            compressionMethod: null,
                            serverCertificate: null,
                            clientCertificate: null,
                            md5: n.md.md5.create(),
                            sha1: n.md.sha1.create()
                        }), i !== c.HandshakeType.hello_request && i !== c.HandshakeType.certificate_verify && i !== c.HandshakeType.finished && (t.session.md5.update(a), t.session.sha1.update(a)), V[t.entity][t.expect][i](t, e, s)) : c.handleUnexpected(t, e)
                    }, c.handleApplicationData = function(t, e) {
                        t.data.putBuffer(e.fragment), t.dataReady(t), t.process()
                    }, c.handleHeartbeat = function(t, e) {
                        var r = e.fragment,
                            i = r.getByte(),
                            s = r.getInt16(),
                            a = r.getBytes(s);
                        if (i === c.HeartbeatMessageType.heartbeat_request) {
                            if (t.handshaking || s > a.length) return t.process();
                            c.queue(t, c.createRecord(t, {
                                type: c.ContentType.heartbeat,
                                data: c.createHeartbeat(c.HeartbeatMessageType.heartbeat_response, a)
                            })), c.flush(t)
                        } else if (i === c.HeartbeatMessageType.heartbeat_response) {
                            if (a !== t.expectedHeartbeatPayload) return t.process();
                            t.heartbeatReceived && t.heartbeatReceived(t, n.util.createBuffer(a))
                        }
                        t.process()
                    };
                    var l = 1,
                        f = 2,
                        p = 3,
                        d = 4,
                        g = 5,
                        y = 6,
                        v = 7,
                        m = 8,
                        E = 1,
                        S = 2,
                        b = 3,
                        C = 4,
                        A = 5,
                        w = 6,
                        T = c.handleUnexpected,
                        x = c.handleChangeCipherSpec,
                        I = c.handleAlert,
                        B = c.handleHandshake,
                        F = c.handleApplicationData,
                        R = c.handleHeartbeat,
                        D = [];
                    D[c.ConnectionEnd.client] = [
                        [T, I, B, T, R],
                        [T, I, B, T, R],
                        [T, I, B, T, R],
                        [T, I, B, T, R],
                        [T, I, B, T, R],
                        [x, I, T, T, R],
                        [T, I, B, T, R],
                        [T, I, B, F, R],
                        [T, I, B, T, R]
                    ], D[c.ConnectionEnd.server] = [
                        [T, I, B, T, R],
                        [T, I, B, T, R],
                        [T, I, B, T, R],
                        [T, I, B, T, R],
                        [x, I, T, T, R],
                        [T, I, B, T, R],
                        [T, I, B, F, R],
                        [T, I, B, T, R]
                    ];
                    var N = c.handleHelloRequest,
                        _ = c.handleServerHello,
                        P = c.handleCertificate,
                        k = c.handleServerKeyExchange,
                        L = c.handleCertificateRequest,
                        O = c.handleServerHelloDone,
                        U = c.handleFinished,
                        V = [];
                    V[c.ConnectionEnd.client] = [
                        [T, T, _, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
                        [N, T, T, T, T, T, T, T, T, T, T, P, k, L, O, T, T, T, T, T, T],
                        [N, T, T, T, T, T, T, T, T, T, T, T, k, L, O, T, T, T, T, T, T],
                        [N, T, T, T, T, T, T, T, T, T, T, T, T, L, O, T, T, T, T, T, T],
                        [N, T, T, T, T, T, T, T, T, T, T, T, T, T, O, T, T, T, T, T, T],
                        [N, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
                        [N, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, U],
                        [N, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
                        [N, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T]
                    ];
                    var H = c.handleClientHello,
                        j = c.handleClientKeyExchange,
                        M = c.handleCertificateVerify;
                    V[c.ConnectionEnd.server] = [
                        [T, H, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
                        [T, T, T, T, T, T, T, T, T, T, T, P, T, T, T, T, T, T, T, T, T],
                        [T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, j, T, T, T, T],
                        [T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, M, T, T, T, T, T],
                        [T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
                        [T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, U],
                        [T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T],
                        [T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T]
                    ], c.generateKeys = function(t, e) {
                        var r = i,
                            n = e.client_random + e.server_random;
                        t.session.resuming || (e.master_secret = r(e.pre_master_secret, "master secret", n, 48).bytes(), e.pre_master_secret = null), n = e.server_random + e.client_random;
                        var s = 2 * e.mac_key_length + 2 * e.enc_key_length,
                            a = t.version.major === c.Versions.TLS_1_0.major && t.version.minor === c.Versions.TLS_1_0.minor;
                        a && (s += 2 * e.fixed_iv_length);
                        var o = r(e.master_secret, "key expansion", n, s),
                            u = {
                                client_write_MAC_key: o.getBytes(e.mac_key_length),
                                server_write_MAC_key: o.getBytes(e.mac_key_length),
                                client_write_key: o.getBytes(e.enc_key_length),
                                server_write_key: o.getBytes(e.enc_key_length)
                            };
                        return a && (u.client_write_IV = o.getBytes(e.fixed_iv_length), u.server_write_IV = o.getBytes(e.fixed_iv_length)), u
                    }, c.createConnectionState = function(t) {
                        var e = t.entity === c.ConnectionEnd.client,
                            r = function() {
                                var t = {
                                    sequenceNumber: [0, 0],
                                    macKey: null,
                                    macLength: 0,
                                    macFunction: null,
                                    cipherState: null,
                                    cipherFunction: function(t) {
                                        return !0
                                    },
                                    compressionState: null,
                                    compressFunction: function(t) {
                                        return !0
                                    },
                                    updateSequenceNumber: function() {
                                        4294967295 === t.sequenceNumber[1] ? (t.sequenceNumber[1] = 0, ++t.sequenceNumber[0]) : ++t.sequenceNumber[1]
                                    }
                                };
                                return t
                            },
                            n = {
                                read: r(),
                                write: r()
                            };
                        if (n.read.update = function(t, e) {
                                return n.read.cipherFunction(e, n.read) ? n.read.compressFunction(t, e, n.read) || t.error(t, {
                                    message: "Could not decompress record.",
                                    send: !0,
                                    alert: {
                                        level: c.Alert.Level.fatal,
                                        description: c.Alert.Description.decompression_failure
                                    }
                                }) : t.error(t, {
                                    message: "Could not decrypt record or bad MAC.",
                                    send: !0,
                                    alert: {
                                        level: c.Alert.Level.fatal,
                                        description: c.Alert.Description.bad_record_mac
                                    }
                                }), !t.fail
                            }, n.write.update = function(t, e) {
                                return n.write.compressFunction(t, e, n.write) ? n.write.cipherFunction(e, n.write) || t.error(t, {
                                    message: "Could not encrypt record.",
                                    send: !1,
                                    alert: {
                                        level: c.Alert.Level.fatal,
                                        description: c.Alert.Description.internal_error
                                    }
                                }) : t.error(t, {
                                    message: "Could not compress record.",
                                    send: !1,
                                    alert: {
                                        level: c.Alert.Level.fatal,
                                        description: c.Alert.Description.internal_error
                                    }
                                }), !t.fail
                            }, t.session) {
                            var i = t.session.sp;
                            switch (t.session.cipherSuite.initSecurityParameters(i), i.keys = c.generateKeys(t, i), n.read.macKey = e ? i.keys.server_write_MAC_key : i.keys.client_write_MAC_key, n.write.macKey = e ? i.keys.client_write_MAC_key : i.keys.server_write_MAC_key, t.session.cipherSuite.initConnectionState(n, t, i), i.compression_algorithm) {
                                case c.CompressionMethod.none:
                                    break;
                                case c.CompressionMethod.deflate:
                                    n.read.compressFunction = a, n.write.compressFunction = s;
                                    break;
                                default:
                                    throw new Error("Unsupported compression algorithm.")
                            }
                        }
                        return n
                    }, c.createRandom = function() {
                        var t = new Date,
                            e = +t + 6e4 * t.getTimezoneOffset(),
                            r = n.util.createBuffer();
                        return r.putInt32(e), r.putBytes(n.random.getBytes(28)), r
                    }, c.createRecord = function(t, e) {
                        return e.data ? {
                            type: e.type,
                            version: {
                                major: t.version.major,
                                minor: t.version.minor
                            },
                            length: e.data.length(),
                            fragment: e.data
                        } : null
                    }, c.createAlert = function(t, e) {
                        var r = n.util.createBuffer();
                        return r.putByte(e.level), r.putByte(e.description), c.createRecord(t, {
                            type: c.ContentType.alert,
                            data: r
                        })
                    }, c.createClientHello = function(t) {
                        t.session.clientHelloVersion = {
                            major: t.version.major,
                            minor: t.version.minor
                        };
                        for (var e = n.util.createBuffer(), r = 0; r < t.cipherSuites.length; ++r) {
                            var i = t.cipherSuites[r];
                            e.putByte(i.id[0]), e.putByte(i.id[1])
                        }
                        var s = e.length(),
                            a = n.util.createBuffer();
                        a.putByte(c.CompressionMethod.none);
                        var o = a.length(),
                            h = n.util.createBuffer();
                        if (t.virtualHost) {
                            var l = n.util.createBuffer();
                            l.putByte(0), l.putByte(0);
                            var f = n.util.createBuffer();
                            f.putByte(0), u(f, 2, n.util.createBuffer(t.virtualHost));
                            var p = n.util.createBuffer();
                            u(p, 2, f), u(l, 2, p), h.putBuffer(l)
                        }
                        var d = h.length();
                        d > 0 && (d += 2);
                        var g = t.session.id,
                            y = g.length + 1 + 2 + 4 + 28 + 2 + s + 1 + o + d,
                            v = n.util.createBuffer();
                        return v.putByte(c.HandshakeType.client_hello), v.putInt24(y), v.putByte(t.version.major), v.putByte(t.version.minor), v.putBytes(t.session.sp.client_random), u(v, 1, n.util.createBuffer(g)), u(v, 2, e), u(v, 1, a), d > 0 && u(v, 2, h), v
                    }, c.createServerHello = function(t) {
                        var e = t.session.id,
                            r = e.length + 1 + 2 + 4 + 28 + 2 + 1,
                            i = n.util.createBuffer();
                        return i.putByte(c.HandshakeType.server_hello), i.putInt24(r), i.putByte(t.version.major), i.putByte(t.version.minor), i.putBytes(t.session.sp.server_random), u(i, 1, n.util.createBuffer(e)), i.putByte(t.session.cipherSuite.id[0]), i.putByte(t.session.cipherSuite.id[1]), i.putByte(t.session.compressionMethod), i
                    }, c.createCertificate = function(t) {
                        var e, r = t.entity === c.ConnectionEnd.client,
                            i = null;
                        t.getCertificate && (e = r ? t.session.certificateRequest : t.session.extensions.server_name.serverNameList, i = t.getCertificate(t, e));
                        var s = n.util.createBuffer();
                        if (null !== i) try {
                            n.util.isArray(i) || (i = [i]);
                            for (var a = null, o = 0; o < i.length; ++o) {
                                var h = n.pem.decode(i[o])[0];
                                if ("CERTIFICATE" !== h.type && "X509 CERTIFICATE" !== h.type && "TRUSTED CERTIFICATE" !== h.type) {
                                    var l = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
                                    throw l.headerType = h.type, l
                                }
                                if (h.procType && "ENCRYPTED" === h.procType.type) throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
                                var f = n.util.createBuffer(h.body);
                                null === a && (a = n.asn1.fromDer(f.bytes(), !1));
                                var p = n.util.createBuffer();
                                u(p, 3, f), s.putBuffer(p)
                            }
                            i = n.pki.certificateFromAsn1(a), r ? t.session.clientCertificate = i : t.session.serverCertificate = i
                        } catch (e) {
                            return t.error(t, {
                                message: "Could not send certificate list.",
                                cause: e,
                                send: !0,
                                alert: {
                                    level: c.Alert.Level.fatal,
                                    description: c.Alert.Description.bad_certificate
                                }
                            })
                        }
                        var d = 3 + s.length(),
                            g = n.util.createBuffer();
                        return g.putByte(c.HandshakeType.certificate), g.putInt24(d), u(g, 3, s), g
                    }, c.createClientKeyExchange = function(t) {
                        var e = n.util.createBuffer();
                        e.putByte(t.session.clientHelloVersion.major), e.putByte(t.session.clientHelloVersion.minor), e.putBytes(n.random.getBytes(46));
                        var r = t.session.sp;
                        r.pre_master_secret = e.getBytes();
                        var i = (e = t.session.serverCertificate.publicKey.encrypt(r.pre_master_secret)).length + 2,
                            s = n.util.createBuffer();
                        return s.putByte(c.HandshakeType.client_key_exchange), s.putInt24(i), s.putInt16(e.length), s.putBytes(e), s
                    }, c.createServerKeyExchange = function(t) {
                        var e = n.util.createBuffer();
                        return e
                    }, c.getClientSignature = function(t, e) {
                        var r = n.util.createBuffer();
                        r.putBuffer(t.session.md5.digest()), r.putBuffer(t.session.sha1.digest()), r = r.getBytes(), t.getSignature = t.getSignature || function(t, e, r) {
                            var i = null;
                            if (t.getPrivateKey) try {
                                i = t.getPrivateKey(t, t.session.clientCertificate), i = n.pki.privateKeyFromPem(i)
                            } catch (e) {
                                t.error(t, {
                                    message: "Could not get private key.",
                                    cause: e,
                                    send: !0,
                                    alert: {
                                        level: c.Alert.Level.fatal,
                                        description: c.Alert.Description.internal_error
                                    }
                                })
                            }
                            null === i ? t.error(t, {
                                message: "No private key set.",
                                send: !0,
                                alert: {
                                    level: c.Alert.Level.fatal,
                                    description: c.Alert.Description.internal_error
                                }
                            }) : e = i.sign(e, null), r(t, e)
                        }, t.getSignature(t, r, e)
                    }, c.createCertificateVerify = function(t, e) {
                        var r = e.length + 2,
                            i = n.util.createBuffer();
                        return i.putByte(c.HandshakeType.certificate_verify), i.putInt24(r), i.putInt16(e.length), i.putBytes(e), i
                    }, c.createCertificateRequest = function(t) {
                        var e = n.util.createBuffer();
                        e.putByte(1);
                        var r = n.util.createBuffer();
                        for (var i in t.caStore.certs) {
                            var s = t.caStore.certs[i],
                                a = n.pki.distinguishedNameToAsn1(s.subject),
                                o = n.asn1.toDer(a);
                            r.putInt16(o.length()), r.putBuffer(o)
                        }
                        var h = 1 + e.length() + 2 + r.length(),
                            l = n.util.createBuffer();
                        return l.putByte(c.HandshakeType.certificate_request), l.putInt24(h), u(l, 1, e), u(l, 2, r), l
                    }, c.createServerHelloDone = function(t) {
                        var e = n.util.createBuffer();
                        return e.putByte(c.HandshakeType.server_hello_done), e.putInt24(0), e
                    }, c.createChangeCipherSpec = function() {
                        var t = n.util.createBuffer();
                        return t.putByte(1), t
                    }, c.createFinished = function(t) {
                        var e = n.util.createBuffer();
                        e.putBuffer(t.session.md5.digest()), e.putBuffer(t.session.sha1.digest());
                        var r = t.entity === c.ConnectionEnd.client,
                            s = t.session.sp,
                            a = r ? "client finished" : "server finished";
                        e = i(s.master_secret, a, e.getBytes(), 12);
                        var o = n.util.createBuffer();
                        return o.putByte(c.HandshakeType.finished), o.putInt24(e.length()), o.putBuffer(e), o
                    }, c.createHeartbeat = function(t, e, r) {
                        void 0 === r && (r = e.length);
                        var i = n.util.createBuffer();
                        i.putByte(t), i.putInt16(r), i.putBytes(e);
                        var s = i.length(),
                            a = Math.max(16, s - r - 3);
                        return i.putBytes(n.random.getBytes(a)), i
                    }, c.queue = function(t, e) {
                        if (e && (0 !== e.fragment.length() || e.type !== c.ContentType.handshake && e.type !== c.ContentType.alert && e.type !== c.ContentType.change_cipher_spec)) {
                            if (e.type === c.ContentType.handshake) {
                                var r = e.fragment.bytes();
                                t.session.md5.update(r), t.session.sha1.update(r), r = null
                            }
                            var i;
                            if (e.fragment.length() <= c.MaxFragment) i = [e];
                            else {
                                i = [];
                                for (var s = e.fragment.bytes(); s.length > c.MaxFragment;) i.push(c.createRecord(t, {
                                    type: e.type,
                                    data: n.util.createBuffer(s.slice(0, c.MaxFragment))
                                })), s = s.slice(c.MaxFragment);
                                s.length > 0 && i.push(c.createRecord(t, {
                                    type: e.type,
                                    data: n.util.createBuffer(s)
                                }))
                            }
                            for (var a = 0; a < i.length && !t.fail; ++a) {
                                var o = i[a];
                                t.state.current.write.update(t, o) && t.records.push(o)
                            }
                        }
                    }, c.flush = function(t) {
                        for (var e = 0; e < t.records.length; ++e) {
                            var r = t.records[e];
                            t.tlsData.putByte(r.type), t.tlsData.putByte(r.version.major), t.tlsData.putByte(r.version.minor), t.tlsData.putInt16(r.fragment.length()), t.tlsData.putBuffer(t.records[e].fragment)
                        }
                        return t.records = [], t.tlsDataReady(t)
                    };
                    var K = function(t) {
                        switch (t) {
                            case !0:
                                return !0;
                            case n.pki.certificateError.bad_certificate:
                                return c.Alert.Description.bad_certificate;
                            case n.pki.certificateError.unsupported_certificate:
                                return c.Alert.Description.unsupported_certificate;
                            case n.pki.certificateError.certificate_revoked:
                                return c.Alert.Description.certificate_revoked;
                            case n.pki.certificateError.certificate_expired:
                                return c.Alert.Description.certificate_expired;
                            case n.pki.certificateError.certificate_unknown:
                                return c.Alert.Description.certificate_unknown;
                            case n.pki.certificateError.unknown_ca:
                                return c.Alert.Description.unknown_ca;
                            default:
                                return c.Alert.Description.bad_certificate
                        }
                    };
                    for (var q in c.verifyCertificateChain = function(t, e) {
                            try {
                                var r = {};
                                for (var i in t.verifyOptions) r[i] = t.verifyOptions[i];
                                r.verify = function(e, r, i) {
                                    K(e);
                                    var s = t.verify(t, e, r, i);
                                    if (!0 !== s) {
                                        if ("object" === h(s) && !n.util.isArray(s)) {
                                            var a = new Error("The application rejected the certificate.");
                                            throw a.send = !0, a.alert = {
                                                level: c.Alert.Level.fatal,
                                                description: c.Alert.Description.bad_certificate
                                            }, s.message && (a.message = s.message), s.alert && (a.alert.description = s.alert), a
                                        }
                                        s !== e && (s = function(t) {
                                            switch (t) {
                                                case !0:
                                                    return !0;
                                                case c.Alert.Description.bad_certificate:
                                                    return n.pki.certificateError.bad_certificate;
                                                case c.Alert.Description.unsupported_certificate:
                                                    return n.pki.certificateError.unsupported_certificate;
                                                case c.Alert.Description.certificate_revoked:
                                                    return n.pki.certificateError.certificate_revoked;
                                                case c.Alert.Description.certificate_expired:
                                                    return n.pki.certificateError.certificate_expired;
                                                case c.Alert.Description.certificate_unknown:
                                                    return n.pki.certificateError.certificate_unknown;
                                                case c.Alert.Description.unknown_ca:
                                                    return n.pki.certificateError.unknown_ca;
                                                default:
                                                    return n.pki.certificateError.bad_certificate
                                            }
                                        }(s))
                                    }
                                    return s
                                }, n.pki.verifyCertificateChain(t.caStore, e, r)
                            } catch (e) {
                                var s = e;
                                ("object" !== h(s) || n.util.isArray(s)) && (s = {
                                    send: !0,
                                    alert: {
                                        level: c.Alert.Level.fatal,
                                        description: K(e)
                                    }
                                }), "send" in s || (s.send = !0), "alert" in s || (s.alert = {
                                    level: c.Alert.Level.fatal,
                                    description: K(s.error)
                                }), t.error(t, s)
                            }
                            return !t.fail
                        }, c.createSessionCache = function(t, e) {
                            var r = null;
                            if (t && t.getSession && t.setSession && t.order) r = t;
                            else {
                                for (var i in (r = {}).cache = t || {}, r.capacity = Math.max(e || 100, 1), r.order = [], t) r.order.length <= e ? r.order.push(i) : delete t[i];
                                r.getSession = function(t) {
                                    var e = null,
                                        i = null;
                                    if (t ? i = n.util.bytesToHex(t) : r.order.length > 0 && (i = r.order[0]), null !== i && i in r.cache)
                                        for (var s in e = r.cache[i], delete r.cache[i], r.order)
                                            if (r.order[s] === i) {
                                                r.order.splice(s, 1);
                                                break
                                            }
                                    return e
                                }, r.setSession = function(t, e) {
                                    if (r.order.length === r.capacity) {
                                        var i = r.order.shift();
                                        delete r.cache[i]
                                    }
                                    i = n.util.bytesToHex(t), r.order.push(i), r.cache[i] = e
                                }
                            }
                            return r
                        }, c.createConnection = function(t) {
                            var e = null;
                            e = t.caStore ? n.util.isArray(t.caStore) ? n.pki.createCaStore(t.caStore) : t.caStore : n.pki.createCaStore();
                            var r = t.cipherSuites || null;
                            if (null === r)
                                for (var i in r = [], c.CipherSuites) r.push(c.CipherSuites[i]);
                            var s = t.server ? c.ConnectionEnd.server : c.ConnectionEnd.client,
                                a = t.sessionCache ? c.createSessionCache(t.sessionCache) : null,
                                o = {
                                    version: {
                                        major: c.Version.major,
                                        minor: c.Version.minor
                                    },
                                    entity: s,
                                    sessionId: t.sessionId,
                                    caStore: e,
                                    sessionCache: a,
                                    cipherSuites: r,
                                    connected: t.connected,
                                    virtualHost: t.virtualHost || null,
                                    verifyClient: t.verifyClient || !1,
                                    verify: t.verify || function(t, e, r, n) {
                                        return e
                                    },
                                    verifyOptions: t.verifyOptions || {},
                                    getCertificate: t.getCertificate || null,
                                    getPrivateKey: t.getPrivateKey || null,
                                    getSignature: t.getSignature || null,
                                    input: n.util.createBuffer(),
                                    tlsData: n.util.createBuffer(),
                                    data: n.util.createBuffer(),
                                    tlsDataReady: t.tlsDataReady,
                                    dataReady: t.dataReady,
                                    heartbeatReceived: t.heartbeatReceived,
                                    closed: t.closed,
                                    error: function(e, r) {
                                        r.origin = r.origin || (e.entity === c.ConnectionEnd.client ? "client" : "server"), r.send && (c.queue(e, c.createAlert(e, r.alert)), c.flush(e));
                                        var n = !1 !== r.fatal;
                                        n && (e.fail = !0), t.error(e, r), n && e.close(!1)
                                    },
                                    deflate: t.deflate || null,
                                    inflate: t.inflate || null,
                                    reset: function(t) {
                                        o.version = {
                                            major: c.Version.major,
                                            minor: c.Version.minor
                                        }, o.record = null, o.session = null, o.peerCertificate = null, o.state = {
                                            pending: null,
                                            current: null
                                        }, o.expect = (o.entity, c.ConnectionEnd.client, 0), o.fragmented = null, o.records = [], o.open = !1, o.handshakes = 0, o.handshaking = !1, o.isConnected = !1, o.fail = !(t || void 0 === t), o.input.clear(), o.tlsData.clear(), o.data.clear(), o.state.current = c.createConnectionState(o)
                                    }
                                };
                            return o.reset(), o.handshake = function(t) {
                                if (o.entity !== c.ConnectionEnd.client) o.error(o, {
                                    message: "Cannot initiate handshake as a server.",
                                    fatal: !1
                                });
                                else if (o.handshaking) o.error(o, {
                                    message: "Handshake already in progress.",
                                    fatal: !1
                                });
                                else {
                                    o.fail && !o.open && 0 === o.handshakes && (o.fail = !1), o.handshaking = !0;
                                    var e = null;
                                    (t = t || "").length > 0 && (o.sessionCache && (e = o.sessionCache.getSession(t)), null === e && (t = "")), 0 === t.length && o.sessionCache && null !== (e = o.sessionCache.getSession()) && (t = e.id), o.session = {
                                        id: t,
                                        version: null,
                                        cipherSuite: null,
                                        compressionMethod: null,
                                        serverCertificate: null,
                                        certificateRequest: null,
                                        clientCertificate: null,
                                        sp: {},
                                        md5: n.md.md5.create(),
                                        sha1: n.md.sha1.create()
                                    }, e && (o.version = e.version, o.session.sp = e.sp), o.session.sp.client_random = c.createRandom().getBytes(), o.open = !0, c.queue(o, c.createRecord(o, {
                                        type: c.ContentType.handshake,
                                        data: c.createClientHello(o)
                                    })), c.flush(o)
                                }
                            }, o.process = function(t) {
                                var e = 0;
                                return t && o.input.putBytes(t), o.fail || (null !== o.record && o.record.ready && o.record.fragment.isEmpty() && (o.record = null), null === o.record && (e = function(t) {
                                    var e = 0,
                                        r = t.input,
                                        i = r.length();
                                    if (i < 5) e = 5 - i;
                                    else {
                                        t.record = {
                                            type: r.getByte(),
                                            version: {
                                                major: r.getByte(),
                                                minor: r.getByte()
                                            },
                                            length: r.getInt16(),
                                            fragment: n.util.createBuffer(),
                                            ready: !1
                                        };
                                        var s = t.record.version.major === t.version.major;
                                        s && t.session && t.session.version && (s = t.record.version.minor === t.version.minor), s || t.error(t, {
                                            message: "Incompatible TLS version.",
                                            send: !0,
                                            alert: {
                                                level: c.Alert.Level.fatal,
                                                description: c.Alert.Description.protocol_version
                                            }
                                        })
                                    }
                                    return e
                                }(o)), o.fail || null === o.record || o.record.ready || (e = function(t) {
                                    var e = 0,
                                        r = t.input,
                                        n = r.length();
                                    return n < t.record.length ? e = t.record.length - n : (t.record.fragment.putBytes(r.getBytes(t.record.length)), r.compact(), t.state.current.read.update(t, t.record) && (null !== t.fragmented && (t.fragmented.type === t.record.type ? (t.fragmented.fragment.putBuffer(t.record.fragment), t.record = t.fragmented) : t.error(t, {
                                        message: "Invalid fragmented record.",
                                        send: !0,
                                        alert: {
                                            level: c.Alert.Level.fatal,
                                            description: c.Alert.Description.unexpected_message
                                        }
                                    })), t.record.ready = !0)), e
                                }(o)), !o.fail && null !== o.record && o.record.ready && function(t, e) {
                                    var r = e.type - c.ContentType.change_cipher_spec,
                                        n = D[t.entity][t.expect];
                                    r in n ? n[r](t, e) : c.handleUnexpected(t, e)
                                }(o, o.record)), e
                            }, o.prepare = function(t) {
                                return c.queue(o, c.createRecord(o, {
                                    type: c.ContentType.application_data,
                                    data: n.util.createBuffer(t)
                                })), c.flush(o)
                            }, o.prepareHeartbeatRequest = function(t, e) {
                                return t instanceof n.util.ByteBuffer && (t = t.bytes()), void 0 === e && (e = t.length), o.expectedHeartbeatPayload = t, c.queue(o, c.createRecord(o, {
                                    type: c.ContentType.heartbeat,
                                    data: c.createHeartbeat(c.HeartbeatMessageType.heartbeat_request, t, e)
                                })), c.flush(o)
                            }, o.close = function(t) {
                                if (!o.fail && o.sessionCache && o.session) {
                                    var e = {
                                        id: o.session.id,
                                        version: o.session.version,
                                        sp: o.session.sp
                                    };
                                    e.sp.keys = null, o.sessionCache.setSession(e.id, e)
                                }
                                o.open && (o.open = !1, o.input.clear(), (o.isConnected || o.handshaking) && (o.isConnected = o.handshaking = !1, c.queue(o, c.createAlert(o, {
                                    level: c.Alert.Level.warning,
                                    description: c.Alert.Description.close_notify
                                })), c.flush(o)), o.closed(o)), o.reset(t)
                            }, o
                        }, t.exports = n.tls = n.tls || {}, c) "function" != typeof c[q] && (n.tls[q] = c[q]);
                    n.tls.prf_tls1 = i, n.tls.hmac_sha1 = function(t, e, r) {
                        var i = n.hmac.create();
                        i.start("SHA1", t);
                        var s = n.util.createBuffer();
                        return s.putInt32(e[0]), s.putInt32(e[1]), s.putByte(r.type), s.putByte(r.version.major), s.putByte(r.version.minor), s.putInt16(r.length), s.putBytes(r.fragment.bytes()), i.update(s.getBytes()), i.digest().getBytes()
                    }, n.tls.createSessionCache = c.createSessionCache, n.tls.createConnection = c.createConnection
                }, function(t, e, r) {
                    var n = r(0);
                    r(3), r(6), r(22), r(7), r(15), r(28), r(18), r(11), r(1), r(17);
                    var i = n.asn1,
                        s = t.exports = n.pki = n.pki || {};
                    s.pemToDer = function(t) {
                        var e = n.pem.decode(t)[0];
                        if (e.procType && "ENCRYPTED" === e.procType.type) throw new Error("Could not convert PEM to DER; PEM is encrypted.");
                        return n.util.createBuffer(e.body)
                    }, s.privateKeyFromPem = function(t) {
                        var e = n.pem.decode(t)[0];
                        if ("PRIVATE KEY" !== e.type && "RSA PRIVATE KEY" !== e.type) {
                            var r = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
                            throw r.headerType = e.type, r
                        }
                        if (e.procType && "ENCRYPTED" === e.procType.type) throw new Error("Could not convert private key from PEM; PEM is encrypted.");
                        var a = i.fromDer(e.body);
                        return s.privateKeyFromAsn1(a)
                    }, s.privateKeyToPem = function(t, e) {
                        var r = {
                            type: "RSA PRIVATE KEY",
                            body: i.toDer(s.privateKeyToAsn1(t)).getBytes()
                        };
                        return n.pem.encode(r, {
                            maxline: e
                        })
                    }, s.privateKeyInfoToPem = function(t, e) {
                        var r = {
                            type: "PRIVATE KEY",
                            body: i.toDer(t).getBytes()
                        };
                        return n.pem.encode(r, {
                            maxline: e
                        })
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    if (r(5), r(3), r(10), r(4), r(6), r(15), r(7), r(2), r(25), r(11), r(1), void 0 === i) var i = n.jsbn.BigInteger;
                    var s = n.asn1,
                        a = n.pki = n.pki || {};
                    t.exports = a.pbe = n.pbe = n.pbe || {};
                    var o = a.oids,
                        u = {
                            name: "EncryptedPrivateKeyInfo",
                            tagClass: s.Class.UNIVERSAL,
                            type: s.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
                                tagClass: s.Class.UNIVERSAL,
                                type: s.Type.SEQUENCE,
                                constructed: !0,
                                value: [{
                                    name: "AlgorithmIdentifier.algorithm",
                                    tagClass: s.Class.UNIVERSAL,
                                    type: s.Type.OID,
                                    constructed: !1,
                                    capture: "encryptionOid"
                                }, {
                                    name: "AlgorithmIdentifier.parameters",
                                    tagClass: s.Class.UNIVERSAL,
                                    type: s.Type.SEQUENCE,
                                    constructed: !0,
                                    captureAsn1: "encryptionParams"
                                }]
                            }, {
                                name: "EncryptedPrivateKeyInfo.encryptedData",
                                tagClass: s.Class.UNIVERSAL,
                                type: s.Type.OCTETSTRING,
                                constructed: !1,
                                capture: "encryptedData"
                            }]
                        },
                        c = {
                            name: "PBES2Algorithms",
                            tagClass: s.Class.UNIVERSAL,
                            type: s.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "PBES2Algorithms.keyDerivationFunc",
                                tagClass: s.Class.UNIVERSAL,
                                type: s.Type.SEQUENCE,
                                constructed: !0,
                                value: [{
                                    name: "PBES2Algorithms.keyDerivationFunc.oid",
                                    tagClass: s.Class.UNIVERSAL,
                                    type: s.Type.OID,
                                    constructed: !1,
                                    capture: "kdfOid"
                                }, {
                                    name: "PBES2Algorithms.params",
                                    tagClass: s.Class.UNIVERSAL,
                                    type: s.Type.SEQUENCE,
                                    constructed: !0,
                                    value: [{
                                        name: "PBES2Algorithms.params.salt",
                                        tagClass: s.Class.UNIVERSAL,
                                        type: s.Type.OCTETSTRING,
                                        constructed: !1,
                                        capture: "kdfSalt"
                                    }, {
                                        name: "PBES2Algorithms.params.iterationCount",
                                        tagClass: s.Class.UNIVERSAL,
                                        type: s.Type.INTEGER,
                                        constructed: !1,
                                        capture: "kdfIterationCount"
                                    }, {
                                        name: "PBES2Algorithms.params.keyLength",
                                        tagClass: s.Class.UNIVERSAL,
                                        type: s.Type.INTEGER,
                                        constructed: !1,
                                        optional: !0,
                                        capture: "keyLength"
                                    }, {
                                        name: "PBES2Algorithms.params.prf",
                                        tagClass: s.Class.UNIVERSAL,
                                        type: s.Type.SEQUENCE,
                                        constructed: !0,
                                        optional: !0,
                                        value: [{
                                            name: "PBES2Algorithms.params.prf.algorithm",
                                            tagClass: s.Class.UNIVERSAL,
                                            type: s.Type.OID,
                                            constructed: !1,
                                            capture: "prfOid"
                                        }]
                                    }]
                                }]
                            }, {
                                name: "PBES2Algorithms.encryptionScheme",
                                tagClass: s.Class.UNIVERSAL,
                                type: s.Type.SEQUENCE,
                                constructed: !0,
                                value: [{
                                    name: "PBES2Algorithms.encryptionScheme.oid",
                                    tagClass: s.Class.UNIVERSAL,
                                    type: s.Type.OID,
                                    constructed: !1,
                                    capture: "encOid"
                                }, {
                                    name: "PBES2Algorithms.encryptionScheme.iv",
                                    tagClass: s.Class.UNIVERSAL,
                                    type: s.Type.OCTETSTRING,
                                    constructed: !1,
                                    capture: "encIv"
                                }]
                            }]
                        },
                        h = {
                            name: "pkcs-12PbeParams",
                            tagClass: s.Class.UNIVERSAL,
                            type: s.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "pkcs-12PbeParams.salt",
                                tagClass: s.Class.UNIVERSAL,
                                type: s.Type.OCTETSTRING,
                                constructed: !1,
                                capture: "salt"
                            }, {
                                name: "pkcs-12PbeParams.iterations",
                                tagClass: s.Class.UNIVERSAL,
                                type: s.Type.INTEGER,
                                constructed: !1,
                                capture: "iterations"
                            }]
                        };

                    function l(t, e) {
                        return t.start().update(e).digest().getBytes()
                    }

                    function f(t) {
                        var e;
                        if (t) {
                            if (!(e = a.oids[s.derToOid(t)])) {
                                var r = new Error("Unsupported PRF OID.");
                                throw r.oid = t, r.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], r
                            }
                        } else e = "hmacWithSHA1";
                        return p(e)
                    }

                    function p(t) {
                        var e = n.md;
                        switch (t) {
                            case "hmacWithSHA224":
                                e = n.md.sha512;
                            case "hmacWithSHA1":
                            case "hmacWithSHA256":
                            case "hmacWithSHA384":
                            case "hmacWithSHA512":
                                t = t.substr(8).toLowerCase();
                                break;
                            default:
                                var r = new Error("Unsupported PRF algorithm.");
                                throw r.algorithm = t, r.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], r
                        }
                        if (!e || !(t in e)) throw new Error("Unknown hash algorithm: " + t);
                        return e[t].create()
                    }
                    a.encryptPrivateKeyInfo = function(t, e, r) {
                        (r = r || {}).saltSize = r.saltSize || 8, r.count = r.count || 2048, r.algorithm = r.algorithm || "aes128", r.prfAlgorithm = r.prfAlgorithm || "sha1";
                        var i, u, c, h = n.random.getBytesSync(r.saltSize),
                            l = r.count,
                            f = s.integerToDer(l);
                        if (0 === r.algorithm.indexOf("aes") || "des" === r.algorithm) {
                            var d, g, y;
                            switch (r.algorithm) {
                                case "aes128":
                                    i = 16, d = 16, g = o["aes128-CBC"], y = n.aes.createEncryptionCipher;
                                    break;
                                case "aes192":
                                    i = 24, d = 16, g = o["aes192-CBC"], y = n.aes.createEncryptionCipher;
                                    break;
                                case "aes256":
                                    i = 32, d = 16, g = o["aes256-CBC"], y = n.aes.createEncryptionCipher;
                                    break;
                                case "des":
                                    i = 8, d = 8, g = o.desCBC, y = n.des.createEncryptionCipher;
                                    break;
                                default:
                                    throw (C = new Error("Cannot encrypt private key. Unknown encryption algorithm.")).algorithm = r.algorithm, C
                            }
                            var v = "hmacWith" + r.prfAlgorithm.toUpperCase(),
                                m = p(v),
                                E = n.pkcs5.pbkdf2(e, h, l, i, m),
                                S = n.random.getBytesSync(d);
                            (A = y(E)).start(S), A.update(s.toDer(t)), A.finish(), c = A.output.getBytes();
                            var b = function(t, e, r, i) {
                                var o = s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [s.create(s.Class.UNIVERSAL, s.Type.OCTETSTRING, !1, t), s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, e.getBytes())]);
                                return "hmacWithSHA1" !== i && o.value.push(s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, n.util.hexToBytes(r.toString(16))), s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [s.create(s.Class.UNIVERSAL, s.Type.OID, !1, s.oidToDer(a.oids[i]).getBytes()), s.create(s.Class.UNIVERSAL, s.Type.NULL, !1, "")])), o
                            }(h, f, i, v);
                            u = s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [s.create(s.Class.UNIVERSAL, s.Type.OID, !1, s.oidToDer(o.pkcs5PBES2).getBytes()), s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [s.create(s.Class.UNIVERSAL, s.Type.OID, !1, s.oidToDer(o.pkcs5PBKDF2).getBytes()), b]), s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [s.create(s.Class.UNIVERSAL, s.Type.OID, !1, s.oidToDer(g).getBytes()), s.create(s.Class.UNIVERSAL, s.Type.OCTETSTRING, !1, S)])])])
                        } else {
                            var C;
                            if ("3des" !== r.algorithm) throw (C = new Error("Cannot encrypt private key. Unknown encryption algorithm.")).algorithm = r.algorithm, C;
                            i = 24;
                            var A, w = new n.util.ByteBuffer(h);
                            E = a.pbe.generatePkcs12Key(e, w, 1, l, i), S = a.pbe.generatePkcs12Key(e, w, 2, l, i), (A = n.des.createEncryptionCipher(E)).start(S), A.update(s.toDer(t)), A.finish(), c = A.output.getBytes(), u = s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [s.create(s.Class.UNIVERSAL, s.Type.OID, !1, s.oidToDer(o["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [s.create(s.Class.UNIVERSAL, s.Type.OCTETSTRING, !1, h), s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, f.getBytes())])])
                        }
                        return s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [u, s.create(s.Class.UNIVERSAL, s.Type.OCTETSTRING, !1, c)])
                    }, a.decryptPrivateKeyInfo = function(t, e) {
                        var r = null,
                            i = {},
                            o = [];
                        if (!s.validate(t, u, i, o)) {
                            var c = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
                            throw c.errors = o, c
                        }
                        var h = s.derToOid(i.encryptionOid),
                            l = a.pbe.getCipher(h, i.encryptionParams, e),
                            f = n.util.createBuffer(i.encryptedData);
                        return l.update(f), l.finish() && (r = s.fromDer(l.output)), r
                    }, a.encryptedPrivateKeyToPem = function(t, e) {
                        var r = {
                            type: "ENCRYPTED PRIVATE KEY",
                            body: s.toDer(t).getBytes()
                        };
                        return n.pem.encode(r, {
                            maxline: e
                        })
                    }, a.encryptedPrivateKeyFromPem = function(t) {
                        var e = n.pem.decode(t)[0];
                        if ("ENCRYPTED PRIVATE KEY" !== e.type) {
                            var r = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
                            throw r.headerType = e.type, r
                        }
                        if (e.procType && "ENCRYPTED" === e.procType.type) throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
                        return s.fromDer(e.body)
                    }, a.encryptRsaPrivateKey = function(t, e, r) {
                        if (!(r = r || {}).legacy) {
                            var i = a.wrapRsaPrivateKey(a.privateKeyToAsn1(t));
                            return i = a.encryptPrivateKeyInfo(i, e, r), a.encryptedPrivateKeyToPem(i)
                        }
                        var o, u, c, h;
                        switch (r.algorithm) {
                            case "aes128":
                                o = "AES-128-CBC", c = 16, u = n.random.getBytesSync(16), h = n.aes.createEncryptionCipher;
                                break;
                            case "aes192":
                                o = "AES-192-CBC", c = 24, u = n.random.getBytesSync(16), h = n.aes.createEncryptionCipher;
                                break;
                            case "aes256":
                                o = "AES-256-CBC", c = 32, u = n.random.getBytesSync(16), h = n.aes.createEncryptionCipher;
                                break;
                            case "3des":
                                o = "DES-EDE3-CBC", c = 24, u = n.random.getBytesSync(8), h = n.des.createEncryptionCipher;
                                break;
                            case "des":
                                o = "DES-CBC", c = 8, u = n.random.getBytesSync(8), h = n.des.createEncryptionCipher;
                                break;
                            default:
                                var l = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + r.algorithm + '".');
                                throw l.algorithm = r.algorithm, l
                        }
                        var f = h(n.pbe.opensslDeriveBytes(e, u.substr(0, 8), c));
                        f.start(u), f.update(s.toDer(a.privateKeyToAsn1(t))), f.finish();
                        var p = {
                            type: "RSA PRIVATE KEY",
                            procType: {
                                version: "4",
                                type: "ENCRYPTED"
                            },
                            dekInfo: {
                                algorithm: o,
                                parameters: n.util.bytesToHex(u).toUpperCase()
                            },
                            body: f.output.getBytes()
                        };
                        return n.pem.encode(p)
                    }, a.decryptRsaPrivateKey = function(t, e) {
                        var r = null,
                            i = n.pem.decode(t)[0];
                        if ("ENCRYPTED PRIVATE KEY" !== i.type && "PRIVATE KEY" !== i.type && "RSA PRIVATE KEY" !== i.type) throw (c = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".')).headerType = c, c;
                        if (i.procType && "ENCRYPTED" === i.procType.type) {
                            var o, u;
                            switch (i.dekInfo.algorithm) {
                                case "DES-CBC":
                                    o = 8, u = n.des.createDecryptionCipher;
                                    break;
                                case "DES-EDE3-CBC":
                                    o = 24, u = n.des.createDecryptionCipher;
                                    break;
                                case "AES-128-CBC":
                                    o = 16, u = n.aes.createDecryptionCipher;
                                    break;
                                case "AES-192-CBC":
                                    o = 24, u = n.aes.createDecryptionCipher;
                                    break;
                                case "AES-256-CBC":
                                    o = 32, u = n.aes.createDecryptionCipher;
                                    break;
                                case "RC2-40-CBC":
                                    o = 5, u = function(t) {
                                        return n.rc2.createDecryptionCipher(t, 40)
                                    };
                                    break;
                                case "RC2-64-CBC":
                                    o = 8, u = function(t) {
                                        return n.rc2.createDecryptionCipher(t, 64)
                                    };
                                    break;
                                case "RC2-128-CBC":
                                    o = 16, u = function(t) {
                                        return n.rc2.createDecryptionCipher(t, 128)
                                    };
                                    break;
                                default:
                                    var c;
                                    throw (c = new Error('Could not decrypt private key; unsupported encryption algorithm "' + i.dekInfo.algorithm + '".')).algorithm = i.dekInfo.algorithm, c
                            }
                            var h = n.util.hexToBytes(i.dekInfo.parameters),
                                l = u(n.pbe.opensslDeriveBytes(e, h.substr(0, 8), o));
                            if (l.start(h), l.update(n.util.createBuffer(i.body)), !l.finish()) return r;
                            r = l.output.getBytes()
                        } else r = i.body;
                        return null !== (r = "ENCRYPTED PRIVATE KEY" === i.type ? a.decryptPrivateKeyInfo(s.fromDer(r), e) : s.fromDer(r)) && (r = a.privateKeyFromAsn1(r)), r
                    }, a.pbe.generatePkcs12Key = function(t, e, r, i, s, a) {
                        var o, u;
                        if (null == a) {
                            if (!("sha1" in n.md)) throw new Error('"sha1" hash algorithm unavailable.');
                            a = n.md.sha1.create()
                        }
                        var c = a.digestLength,
                            h = a.blockLength,
                            l = new n.util.ByteBuffer,
                            f = new n.util.ByteBuffer;
                        if (null != t) {
                            for (u = 0; u < t.length; u++) f.putInt16(t.charCodeAt(u));
                            f.putInt16(0)
                        }
                        var p = f.length(),
                            d = e.length(),
                            g = new n.util.ByteBuffer;
                        g.fillWithByte(r, h);
                        var y = h * Math.ceil(d / h),
                            v = new n.util.ByteBuffer;
                        for (u = 0; u < y; u++) v.putByte(e.at(u % d));
                        var m = h * Math.ceil(p / h),
                            E = new n.util.ByteBuffer;
                        for (u = 0; u < m; u++) E.putByte(f.at(u % p));
                        var S = v;
                        S.putBuffer(E);
                        for (var b = Math.ceil(s / c), C = 1; C <= b; C++) {
                            var A = new n.util.ByteBuffer;
                            A.putBytes(g.bytes()), A.putBytes(S.bytes());
                            for (var w = 0; w < i; w++) a.start(), a.update(A.getBytes()), A = a.digest();
                            var T = new n.util.ByteBuffer;
                            for (u = 0; u < h; u++) T.putByte(A.at(u % c));
                            var x = Math.ceil(d / h) + Math.ceil(p / h),
                                I = new n.util.ByteBuffer;
                            for (o = 0; o < x; o++) {
                                var B = new n.util.ByteBuffer(S.getBytes(h)),
                                    F = 511;
                                for (u = T.length() - 1; u >= 0; u--) F >>= 8, F += T.at(u) + B.at(u), B.setAt(u, 255 & F);
                                I.putBuffer(B)
                            }
                            S = I, l.putBuffer(A)
                        }
                        return l.truncate(l.length() - s), l
                    }, a.pbe.getCipher = function(t, e, r) {
                        switch (t) {
                            case a.oids.pkcs5PBES2:
                                return a.pbe.getCipherForPBES2(t, e, r);
                            case a.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
                            case a.oids["pbewithSHAAnd40BitRC2-CBC"]:
                                return a.pbe.getCipherForPKCS12PBE(t, e, r);
                            default:
                                var n = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
                                throw n.oid = t, n.supportedOids = ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"], n
                        }
                    }, a.pbe.getCipherForPBES2 = function(t, e, r) {
                        var i, o = {},
                            u = [];
                        if (!s.validate(e, c, o, u)) throw (i = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.")).errors = u, i;
                        if ((t = s.derToOid(o.kdfOid)) !== a.oids.pkcs5PBKDF2) throw (i = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.")).oid = t, i.supportedOids = ["pkcs5PBKDF2"], i;
                        if ((t = s.derToOid(o.encOid)) !== a.oids["aes128-CBC"] && t !== a.oids["aes192-CBC"] && t !== a.oids["aes256-CBC"] && t !== a.oids["des-EDE3-CBC"] && t !== a.oids.desCBC) throw (i = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.")).oid = t, i.supportedOids = ["aes128-CBC", "aes192-CBC", "aes256-CBC", "des-EDE3-CBC", "desCBC"], i;
                        var h, l, p = o.kdfSalt,
                            d = n.util.createBuffer(o.kdfIterationCount);
                        switch (d = d.getInt(d.length() << 3), a.oids[t]) {
                            case "aes128-CBC":
                                h = 16, l = n.aes.createDecryptionCipher;
                                break;
                            case "aes192-CBC":
                                h = 24, l = n.aes.createDecryptionCipher;
                                break;
                            case "aes256-CBC":
                                h = 32, l = n.aes.createDecryptionCipher;
                                break;
                            case "des-EDE3-CBC":
                                h = 24, l = n.des.createDecryptionCipher;
                                break;
                            case "desCBC":
                                h = 8, l = n.des.createDecryptionCipher
                        }
                        var g = f(o.prfOid),
                            y = n.pkcs5.pbkdf2(r, p, d, h, g),
                            v = o.encIv,
                            m = l(y);
                        return m.start(v), m
                    }, a.pbe.getCipherForPKCS12PBE = function(t, e, r) {
                        var i = {},
                            o = [];
                        if (!s.validate(e, h, i, o)) throw (g = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.")).errors = o, g;
                        var u, c, l, p = n.util.createBuffer(i.salt),
                            d = n.util.createBuffer(i.iterations);
                        switch (d = d.getInt(d.length() << 3), t) {
                            case a.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
                                u = 24, c = 8, l = n.des.startDecrypting;
                                break;
                            case a.oids["pbewithSHAAnd40BitRC2-CBC"]:
                                u = 5, c = 8, l = function(t, e) {
                                    var r = n.rc2.createDecryptionCipher(t, 40);
                                    return r.start(e, null), r
                                };
                                break;
                            default:
                                var g;
                                throw (g = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.")).oid = t, g
                        }
                        var y = f(i.prfOid),
                            v = a.pbe.generatePkcs12Key(r, p, 1, d, u, y);
                        return y.start(), l(v, a.pbe.generatePkcs12Key(r, p, 2, d, c, y))
                    }, a.pbe.opensslDeriveBytes = function(t, e, r, i) {
                        if (null == i) {
                            if (!("md5" in n.md)) throw new Error('"md5" hash algorithm unavailable.');
                            i = n.md.md5.create()
                        }
                        null === e && (e = "");
                        for (var s = [l(i, t + e)], a = 16, o = 1; a < r; ++o, a += 16) s.push(l(i, s[o - 1] + t + e));
                        return s.join("").substr(0, r)
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(4), r(1);
                    var i = t.exports = n.sha256 = n.sha256 || {};
                    n.md.sha256 = n.md.algorithms.sha256 = i, i.create = function() {
                        a || (s = String.fromCharCode(128), s += n.util.fillString(String.fromCharCode(0), 64), o = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], a = !0);
                        var t = null,
                            e = n.util.createBuffer(),
                            r = new Array(64),
                            i = {
                                algorithm: "sha256",
                                blockLength: 64,
                                digestLength: 32,
                                messageLength: 0,
                                fullMessageLength: null,
                                messageLengthSize: 8,
                                start: function() {
                                    i.messageLength = 0, i.fullMessageLength = i.messageLength64 = [];
                                    for (var r = i.messageLengthSize / 4, s = 0; s < r; ++s) i.fullMessageLength.push(0);
                                    return e = n.util.createBuffer(), t = {
                                        h0: 1779033703,
                                        h1: 3144134277,
                                        h2: 1013904242,
                                        h3: 2773480762,
                                        h4: 1359893119,
                                        h5: 2600822924,
                                        h6: 528734635,
                                        h7: 1541459225
                                    }, i
                                }
                            };
                        return i.start(), i.update = function(s, a) {
                            "utf8" === a && (s = n.util.encodeUtf8(s));
                            var o = s.length;
                            i.messageLength += o, o = [o / 4294967296 >>> 0, o >>> 0];
                            for (var c = i.fullMessageLength.length - 1; c >= 0; --c) i.fullMessageLength[c] += o[1], o[1] = o[0] + (i.fullMessageLength[c] / 4294967296 >>> 0), i.fullMessageLength[c] = i.fullMessageLength[c] >>> 0, o[0] = o[1] / 4294967296 >>> 0;
                            return e.putBytes(s), u(t, r, e), (e.read > 2048 || 0 === e.length()) && e.compact(), i
                        }, i.digest = function() {
                            var a = n.util.createBuffer();
                            a.putBytes(e.bytes());
                            var o, c = i.fullMessageLength[i.fullMessageLength.length - 1] + i.messageLengthSize & i.blockLength - 1;
                            a.putBytes(s.substr(0, i.blockLength - c));
                            for (var h = 8 * i.fullMessageLength[0], l = 0; l < i.fullMessageLength.length - 1; ++l) h += (o = 8 * i.fullMessageLength[l + 1]) / 4294967296 >>> 0, a.putInt32(h >>> 0), h = o >>> 0;
                            a.putInt32(h);
                            var f = {
                                h0: t.h0,
                                h1: t.h1,
                                h2: t.h2,
                                h3: t.h3,
                                h4: t.h4,
                                h5: t.h5,
                                h6: t.h6,
                                h7: t.h7
                            };
                            u(f, r, a);
                            var p = n.util.createBuffer();
                            return p.putInt32(f.h0), p.putInt32(f.h1), p.putInt32(f.h2), p.putInt32(f.h3), p.putInt32(f.h4), p.putInt32(f.h5), p.putInt32(f.h6), p.putInt32(f.h7), p
                        }, i
                    };
                    var s = null,
                        a = !1,
                        o = null;

                    function u(t, e, r) {
                        for (var n, i, s, a, u, c, h, l, f, p, d, g, y, v = r.length(); v >= 64;) {
                            for (u = 0; u < 16; ++u) e[u] = r.getInt32();
                            for (; u < 64; ++u) n = ((n = e[u - 2]) >>> 17 | n << 15) ^ (n >>> 19 | n << 13) ^ n >>> 10, i = ((i = e[u - 15]) >>> 7 | i << 25) ^ (i >>> 18 | i << 14) ^ i >>> 3, e[u] = n + e[u - 7] + i + e[u - 16] | 0;
                            for (c = t.h0, h = t.h1, l = t.h2, f = t.h3, p = t.h4, d = t.h5, g = t.h6, y = t.h7, u = 0; u < 64; ++u) s = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10), a = c & h | l & (c ^ h), n = y + ((p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7)) + (g ^ p & (d ^ g)) + o[u] + e[u], y = g, g = d, d = p, p = f + n >>> 0, f = l, l = h, h = c, c = n + (i = s + a) >>> 0;
                            t.h0 = t.h0 + c | 0, t.h1 = t.h1 + h | 0, t.h2 = t.h2 + l | 0, t.h3 = t.h3 + f | 0, t.h4 = t.h4 + p | 0, t.h5 = t.h5 + d | 0, t.h6 = t.h6 + g | 0, t.h7 = t.h7 + y | 0, v -= 64
                        }
                    }
                }, function(e, r, n) {
                    var i = n(0);
                    n(1);
                    var s = null;
                    !i.util.isNodejs || i.options.usePureJavaScript || t.versions["node-webkit"] || (s = n(16)), (e.exports = i.prng = i.prng || {}).create = function(t) {
                        for (var e = {
                                plugin: t,
                                key: null,
                                seed: null,
                                time: null,
                                reseeds: 0,
                                generated: 0,
                                keyBytes: ""
                            }, r = t.md, n = new Array(32), a = 0; a < 32; ++a) n[a] = r.create();

                        function o() {
                            if (e.pools[0].messageLength >= 32) return u();
                            var t = 32 - e.pools[0].messageLength << 5;
                            e.collect(e.seedFileSync(t)), u()
                        }

                        function u() {
                            e.reseeds = 4294967295 === e.reseeds ? 0 : e.reseeds + 1;
                            var t = e.plugin.md.create();
                            t.update(e.keyBytes);
                            for (var r = 1, n = 0; n < 32; ++n) e.reseeds % r == 0 && (t.update(e.pools[n].digest().getBytes()), e.pools[n].start()), r <<= 1;
                            e.keyBytes = t.digest().getBytes(), t.start(), t.update(e.keyBytes);
                            var i = t.digest().getBytes();
                            e.key = e.plugin.formatKey(e.keyBytes), e.seed = e.plugin.formatSeed(i), e.generated = 0
                        }

                        function c(t, e) {
                            return Math.floor(Math.random() * (e - t + 1) + t)
                        }

                        function h(t) {
                            var e = null,
                                r = i.util.globalScope;
                            if (r) {
                                var n = r.crypto || r.msCrypto;
                                n && n.getRandomValues && (e = function(t) {
                                    return n.getRandomValues(t)
                                })
                            } else e = function(t) {
                                return function(t) {
                                    var e = 255;
                                    if (t.length > 65536) {
                                        var r = new Error;
                                        throw r.code = 22, r.message = "Failed to execute 'getRandomValues' : The ArrayBufferView's byte length (" + t.length + ") exceeds the number of bytes of entropy available via this API (65536).", r.name = "QuotaExceededError", r
                                    }
                                    for (var n in t instanceof Uint16Array ? e = 65535 : t instanceof Uint32Array && (e = 4294967295), t) t[n] = c(0, e);
                                    return t
                                }(t)
                            };
                            var s = i.util.createBuffer();
                            if (e)
                                for (; s.length() < t;) {
                                    var a = Math.max(1, Math.min(t - s.length(), 65536) / 4),
                                        o = new Uint32Array(Math.floor(a));
                                    try {
                                        e(o);
                                        for (var u = 0; u < o.length; ++u) s.putInt32(o[u])
                                    } catch (t) {
                                        if (!("undefined" != typeof QuotaExceededError && t instanceof QuotaExceededError)) throw t
                                    }
                                }
                            if (s.length() < t)
                                for (var h, l, f, p = Math.floor(65536 * Math.random()); s.length() < t;)
                                    for (l = 16807 * (65535 & p), l += (32767 & (h = 16807 * (p >> 16))) << 16, p = 4294967295 & (l = (2147483647 & (l += h >> 15)) + (l >> 31)), u = 0; u < 3; ++u) f = p >>> (u << 3), f ^= Math.floor(256 * Math.random()), s.putByte(String.fromCharCode(255 & f));
                            return s.getBytes(t)
                        }
                        return e.pools = n, e.pool = 0, e.generate = function(t, r) {
                            if (!r) return e.generateSync(t);
                            var n = e.plugin.cipher,
                                s = e.plugin.increment,
                                a = e.plugin.formatKey,
                                o = e.plugin.formatSeed,
                                c = i.util.createBuffer();
                            e.key = null,
                                function h(l) {
                                    if (l) return r(l);
                                    if (c.length() >= t) return r(null, c.getBytes(t));
                                    if (e.generated > 1048575 && (e.key = null), null === e.key) return i.util.nextTick((function() {
                                        ! function(t) {
                                            if (e.pools[0].messageLength >= 32) return u(), t();
                                            var r = 32 - e.pools[0].messageLength << 5;
                                            e.seedFile(r, (function(r, n) {
                                                if (r) return t(r);
                                                e.collect(n), u(), t()
                                            }))
                                        }(h)
                                    }));
                                    var f = n(e.key, e.seed);
                                    e.generated += f.length, c.putBytes(f), e.key = a(n(e.key, s(e.seed))), e.seed = o(n(e.key, e.seed)), i.util.setImmediate(h)
                                }()
                        }, e.generateSync = function(t) {
                            var r = e.plugin.cipher,
                                n = e.plugin.increment,
                                s = e.plugin.formatKey,
                                a = e.plugin.formatSeed;
                            e.key = null;
                            for (var u = i.util.createBuffer(); u.length() < t;) {
                                e.generated > 1048575 && (e.key = null), null === e.key && o();
                                var c = r(e.key, e.seed);
                                e.generated += c.length, u.putBytes(c), e.key = s(r(e.key, n(e.seed))), e.seed = a(r(e.key, e.seed))
                            }
                            return u.getBytes(t)
                        }, s ? (e.seedFile = function(t, e) {
                            s.randomBytes(t, (function(t, r) {
                                if (t) return e(t);
                                e(null, r.toString())
                            }))
                        }, e.seedFileSync = function(t) {
                            return s.randomBytes(t).toString()
                        }) : (e.seedFile = function(t, e) {
                            try {
                                e(null, h(t))
                            } catch (t) {
                                e(t)
                            }
                        }, e.seedFileSync = h), e.collect = function(t) {
                            for (var r = t.length, n = 0; n < r; ++n) e.pools[e.pool].update(t.substr(n, 1)), e.pool = 31 === e.pool ? 0 : e.pool + 1
                        }, e.collectInt = function(t, r) {
                            for (var n = "", i = 0; i < r; i += 8) n += String.fromCharCode(t >> i & 255);
                            e.collect(n)
                        }, e.registerWorker = function(t) {
                            t === self ? e.seedFile = function(t, e) {
                                self.addEventListener("message", (function t(r) {
                                    var n = r.data;
                                    n.forge && n.forge.prng && (self.removeEventListener("message", t), e(n.forge.prng.err, n.forge.prng.bytes))
                                })), self.postMessage({
                                    forge: {
                                        prng: {
                                            needed: t
                                        }
                                    }
                                })
                            } : t.addEventListener("message", (function(r) {
                                var n = r.data;
                                n.forge && n.forge.prng && e.seedFile(n.forge.prng.needed, (function(e, r) {
                                    t.postMessage({
                                        forge: {
                                            prng: {
                                                err: e,
                                                bytes: r
                                            }
                                        }
                                    })
                                }))
                            }))
                        }, e
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(1);
                    var i = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173],
                        s = [1, 2, 3, 5],
                        a = function(t, e) {
                            return t << e & 65535 | (65535 & t) >> 16 - e
                        },
                        o = function(t, e) {
                            return (65535 & t) >> e | t << 16 - e & 65535
                        };
                    t.exports = n.rc2 = n.rc2 || {}, n.rc2.expandKey = function(t, e) {
                        "string" == typeof t && (t = n.util.createBuffer(t)), e = e || 128;
                        var r, s = t,
                            a = t.length(),
                            o = e,
                            u = Math.ceil(o / 8),
                            c = 255 >> (7 & o);
                        for (r = a; r < 128; r++) s.putByte(i[s.at(r - 1) + s.at(r - a) & 255]);
                        for (s.setAt(128 - u, i[s.at(128 - u) & c]), r = 127 - u; r >= 0; r--) s.setAt(r, i[s.at(r + 1) ^ s.at(r + u)]);
                        return s
                    };
                    var u = function(t, e, r) {
                        var i, u, c, h, l = !1,
                            f = null,
                            p = null,
                            d = null,
                            g = [];
                        for (t = n.rc2.expandKey(t, e), c = 0; c < 64; c++) g.push(t.getInt16Le());
                        r ? (i = function(t) {
                            for (c = 0; c < 4; c++) t[c] += g[h] + (t[(c + 3) % 4] & t[(c + 2) % 4]) + (~t[(c + 3) % 4] & t[(c + 1) % 4]), t[c] = a(t[c], s[c]), h++
                        }, u = function(t) {
                            for (c = 0; c < 4; c++) t[c] += g[63 & t[(c + 3) % 4]]
                        }) : (i = function(t) {
                            for (c = 3; c >= 0; c--) t[c] = o(t[c], s[c]), t[c] -= g[h] + (t[(c + 3) % 4] & t[(c + 2) % 4]) + (~t[(c + 3) % 4] & t[(c + 1) % 4]), h--
                        }, u = function(t) {
                            for (c = 3; c >= 0; c--) t[c] -= g[63 & t[(c + 3) % 4]]
                        });
                        var y = function(t) {
                                var e = [];
                                for (c = 0; c < 4; c++) {
                                    var n = f.getInt16Le();
                                    null !== d && (r ? n ^= d.getInt16Le() : d.putInt16Le(n)), e.push(65535 & n)
                                }
                                h = r ? 0 : 63;
                                for (var i = 0; i < t.length; i++)
                                    for (var s = 0; s < t[i][0]; s++) t[i][1](e);
                                for (c = 0; c < 4; c++) null !== d && (r ? d.putInt16Le(e[c]) : e[c] ^= d.getInt16Le()), p.putInt16Le(e[c])
                            },
                            v = null;
                        return v = {
                            start: function(t, e) {
                                t && "string" == typeof t && (t = n.util.createBuffer(t)), l = !1, f = n.util.createBuffer(), p = e || new n.util.createBuffer, d = t, v.output = p
                            },
                            update: function(t) {
                                for (l || f.putBuffer(t); f.length() >= 8;) y([
                                    [5, i],
                                    [1, u],
                                    [6, i],
                                    [1, u],
                                    [5, i]
                                ])
                            },
                            finish: function(t) {
                                var e = !0;
                                if (r)
                                    if (t) e = t(8, f, !r);
                                    else {
                                        var n = 8 === f.length() ? 8 : 8 - f.length();
                                        f.fillWithByte(n, n)
                                    }
                                if (e && (l = !0, v.update()), !r && (e = 0 === f.length()))
                                    if (t) e = t(8, p, !r);
                                    else {
                                        var i = p.length(),
                                            s = p.at(i - 1);
                                        s > i ? e = !1 : p.truncate(s)
                                    }
                                return e
                            }
                        }
                    };
                    n.rc2.startEncrypting = function(t, e, r) {
                        var i = n.rc2.createEncryptionCipher(t, 128);
                        return i.start(e, r), i
                    }, n.rc2.createEncryptionCipher = function(t, e) {
                        return u(t, e, !0)
                    }, n.rc2.startDecrypting = function(t, e, r) {
                        var i = n.rc2.createDecryptionCipher(t, 128);
                        return i.start(e, r), i
                    }, n.rc2.createDecryptionCipher = function(t, e) {
                        return u(t, e, !1)
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(1), r(2), r(9);
                    var i = t.exports = n.pkcs1 = n.pkcs1 || {};

                    function s(t, e, r) {
                        r || (r = n.md.sha1.create());
                        for (var i = "", s = Math.ceil(e / r.digestLength), a = 0; a < s; ++a) {
                            var o = String.fromCharCode(a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, 255 & a);
                            r.start(), r.update(t + o), i += r.digest().getBytes()
                        }
                        return i.substring(0, e)
                    }
                    i.encode_rsa_oaep = function(t, e, r) {
                        var i, a, o, u;
                        "string" == typeof r ? (i = r, a = arguments[3] || void 0, o = arguments[4] || void 0) : r && (i = r.label || void 0, a = r.seed || void 0, o = r.md || void 0, r.mgf1 && r.mgf1.md && (u = r.mgf1.md)), o ? o.start() : o = n.md.sha1.create(), u || (u = o);
                        var c = Math.ceil(t.n.bitLength() / 8),
                            h = c - 2 * o.digestLength - 2;
                        if (e.length > h) throw (y = new Error("RSAES-OAEP input message length is too long.")).length = e.length, y.maxLength = h, y;
                        i || (i = ""), o.update(i, "raw");
                        for (var l = o.digest(), f = "", p = h - e.length, d = 0; d < p; d++) f += "\0";
                        var g = l.getBytes() + f + "" + e;
                        if (a) {
                            if (a.length !== o.digestLength) {
                                var y;
                                throw (y = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.")).seedLength = a.length, y.digestLength = o.digestLength, y
                            }
                        } else a = n.random.getBytes(o.digestLength);
                        var v = s(a, c - o.digestLength - 1, u),
                            m = n.util.xorBytes(g, v, g.length),
                            E = s(m, o.digestLength, u),
                            S = n.util.xorBytes(a, E, a.length);
                        return "\0" + S + m
                    }, i.decode_rsa_oaep = function(t, e, r) {
                        var i, a, o;
                        "string" == typeof r ? (i = r, a = arguments[3] || void 0) : r && (i = r.label || void 0, a = r.md || void 0, r.mgf1 && r.mgf1.md && (o = r.mgf1.md));
                        var u = Math.ceil(t.n.bitLength() / 8);
                        if (e.length !== u) throw (m = new Error("RSAES-OAEP encoded message length is invalid.")).length = e.length, m.expectedLength = u, m;
                        if (void 0 === a ? a = n.md.sha1.create() : a.start(), o || (o = a), u < 2 * a.digestLength + 2) throw new Error("RSAES-OAEP key is too short for the hash function.");
                        i || (i = ""), a.update(i, "raw");
                        for (var c = a.digest().getBytes(), h = e.charAt(0), l = e.substring(1, a.digestLength + 1), f = e.substring(1 + a.digestLength), p = s(f, a.digestLength, o), d = n.util.xorBytes(l, p, l.length), g = s(d, u - a.digestLength - 1, o), y = n.util.xorBytes(f, g, f.length), v = y.substring(0, a.digestLength), m = "\0" !== h, E = 0; E < a.digestLength; ++E) m |= c.charAt(E) !== v.charAt(E);
                        for (var S = 1, b = a.digestLength, C = a.digestLength; C < y.length; C++) {
                            var A = y.charCodeAt(C),
                                w = 1 & A ^ 1,
                                T = S ? 65534 : 0;
                            m |= A & T, b += S &= w
                        }
                        if (m || 1 !== y.charCodeAt(b)) throw new Error("Invalid RSAES-OAEP padding.");
                        return y.substring(b + 1)
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(1), r(12), r(2),
                        function() {
                            if (n.prime) t.exports = n.prime;
                            else {
                                var e = t.exports = n.prime = n.prime || {},
                                    r = n.jsbn.BigInteger,
                                    i = [6, 4, 2, 4, 2, 4, 6, 2],
                                    s = new r(null);
                                s.fromInt(30);
                                var a = function(t, e) {
                                    return t | e
                                };
                                e.generateProbablePrime = function(t, e, i) {
                                    "function" == typeof e && (i = e, e = {});
                                    var s = (e = e || {}).algorithm || "PRIMEINC";
                                    "string" == typeof s && (s = {
                                        name: s
                                    }), s.options = s.options || {};
                                    var a = e.prng || n.random,
                                        c = {
                                            nextBytes: function(t) {
                                                for (var e = a.getBytesSync(t.length), r = 0; r < t.length; ++r) t[r] = e.charCodeAt(r)
                                            }
                                        };
                                    if ("PRIMEINC" === s.name) return function(t, e, i, s) {
                                        return "workers" in i ? function(t, e, i, s) {
                                            if ("undefined" == typeof Worker) return o(t, e, i, s);
                                            var a = u(t, e),
                                                c = i.workers,
                                                h = i.workLoad || 100,
                                                l = 30 * h / 8,
                                                f = i.workerScript || "forge/prime.worker.js";
                                            if (-1 === c) return n.util.estimateCores((function(t, e) {
                                                t && (e = 2), c = e - 1, p()
                                            }));

                                            function p() {
                                                c = Math.max(1, c);
                                                for (var n = [], i = 0; i < c; ++i) n[i] = new Worker(f);
                                                for (i = 0; i < c; ++i) n[i].addEventListener("message", p);
                                                var o = !1;

                                                function p(i) {
                                                    if (!o) {
                                                        var c = i.data;
                                                        if (c.found) {
                                                            for (var f = 0; f < n.length; ++f) n[f].terminate();
                                                            return o = !0, s(null, new r(c.prime, 16))
                                                        }
                                                        a.bitLength() > t && (a = u(t, e));
                                                        var p = a.toString(16);
                                                        i.target.postMessage({
                                                            hex: p,
                                                            workLoad: h
                                                        }), a.dAddOffset(l, 0)
                                                    }
                                                }
                                            }
                                            p()
                                        }(t, e, i, s) : o(t, e, i, s)
                                    }(t, c, s.options, i);
                                    throw new Error("Invalid prime generation algorithm: " + s.name)
                                }
                            }

                            function o(t, e, r, s) {
                                var a = u(t, e),
                                    o = function(t) {
                                        return t <= 100 ? 27 : t <= 150 ? 18 : t <= 200 ? 15 : t <= 250 ? 12 : t <= 300 ? 9 : t <= 350 ? 8 : t <= 400 ? 7 : t <= 500 ? 6 : t <= 600 ? 5 : t <= 800 ? 4 : t <= 1250 ? 3 : 2
                                    }(a.bitLength());
                                "millerRabinTests" in r && (o = r.millerRabinTests);
                                var c = 10;
                                "maxBlockTime" in r && (c = r.maxBlockTime),
                                    function t(e, r, s, a, o, c, h) {
                                        var l = +new Date;
                                        do {
                                            if (e.bitLength() > r && (e = u(r, s)), e.isProbablePrime(o)) return h(null, e);
                                            e.dAddOffset(i[a++ % 8], 0)
                                        } while (c < 0 || +new Date - l < c);
                                        n.util.setImmediate((function() {
                                            t(e, r, s, a, o, c, h)
                                        }))
                                    }(a, t, e, 0, o, c, s)
                            }

                            function u(t, e) {
                                var n = new r(t, e),
                                    i = t - 1;
                                return n.testBit(i) || n.bitwiseTo(r.ONE.shiftLeft(i), a, n), n.dAddOffset(31 - n.mod(s).byteValue(), 0), n
                            }
                        }()
                }, function(t, e, r) {
                    var n = r(0);
                    r(3), r(8), r(6), r(29), r(22), r(2), r(11), r(9), r(1), r(17);
                    var i = n.asn1,
                        s = n.pki,
                        a = t.exports = n.pkcs12 = n.pkcs12 || {},
                        o = {
                            name: "ContentInfo",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "ContentInfo.contentType",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.OID,
                                constructed: !1,
                                capture: "contentType"
                            }, {
                                name: "ContentInfo.content",
                                tagClass: i.Class.CONTEXT_SPECIFIC,
                                constructed: !0,
                                captureAsn1: "content"
                            }]
                        },
                        u = {
                            name: "PFX",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "PFX.version",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.INTEGER,
                                constructed: !1,
                                capture: "version"
                            }, o, {
                                name: "PFX.macData",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.SEQUENCE,
                                constructed: !0,
                                optional: !0,
                                captureAsn1: "mac",
                                value: [{
                                    name: "PFX.macData.mac",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Type.SEQUENCE,
                                    constructed: !0,
                                    value: [{
                                        name: "PFX.macData.mac.digestAlgorithm",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.SEQUENCE,
                                        constructed: !0,
                                        value: [{
                                            name: "PFX.macData.mac.digestAlgorithm.algorithm",
                                            tagClass: i.Class.UNIVERSAL,
                                            type: i.Type.OID,
                                            constructed: !1,
                                            capture: "macAlgorithm"
                                        }, {
                                            name: "PFX.macData.mac.digestAlgorithm.parameters",
                                            tagClass: i.Class.UNIVERSAL,
                                            captureAsn1: "macAlgorithmParameters"
                                        }]
                                    }, {
                                        name: "PFX.macData.mac.digest",
                                        tagClass: i.Class.UNIVERSAL,
                                        type: i.Type.OCTETSTRING,
                                        constructed: !1,
                                        capture: "macDigest"
                                    }]
                                }, {
                                    name: "PFX.macData.macSalt",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Type.OCTETSTRING,
                                    constructed: !1,
                                    capture: "macSalt"
                                }, {
                                    name: "PFX.macData.iterations",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Type.INTEGER,
                                    constructed: !1,
                                    optional: !0,
                                    capture: "macIterations"
                                }]
                            }]
                        },
                        c = {
                            name: "SafeBag",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "SafeBag.bagId",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.OID,
                                constructed: !1,
                                capture: "bagId"
                            }, {
                                name: "SafeBag.bagValue",
                                tagClass: i.Class.CONTEXT_SPECIFIC,
                                constructed: !0,
                                captureAsn1: "bagValue"
                            }, {
                                name: "SafeBag.bagAttributes",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.SET,
                                constructed: !0,
                                optional: !0,
                                capture: "bagAttributes"
                            }]
                        },
                        h = {
                            name: "Attribute",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "Attribute.attrId",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.OID,
                                constructed: !1,
                                capture: "oid"
                            }, {
                                name: "Attribute.attrValues",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.SET,
                                constructed: !0,
                                capture: "values"
                            }]
                        },
                        l = {
                            name: "CertBag",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "CertBag.certId",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.OID,
                                constructed: !1,
                                capture: "certId"
                            }, {
                                name: "CertBag.certValue",
                                tagClass: i.Class.CONTEXT_SPECIFIC,
                                constructed: !0,
                                value: [{
                                    name: "CertBag.certValue[0]",
                                    tagClass: i.Class.UNIVERSAL,
                                    type: i.Class.OCTETSTRING,
                                    constructed: !1,
                                    capture: "cert"
                                }]
                            }]
                        };

                    function f(t, e, r, n) {
                        for (var i = [], s = 0; s < t.length; s++)
                            for (var a = 0; a < t[s].safeBags.length; a++) {
                                var o = t[s].safeBags[a];
                                void 0 !== n && o.type !== n || (null !== e ? void 0 !== o.attributes[e] && o.attributes[e].indexOf(r) >= 0 && i.push(o) : i.push(o))
                            }
                        return i
                    }

                    function p(t) {
                        if (t.composed || t.constructed) {
                            for (var e = n.util.createBuffer(), r = 0; r < t.value.length; ++r) e.putBytes(t.value[r].value);
                            t.composed = t.constructed = !1, t.value = e.getBytes()
                        }
                        return t
                    }

                    function d(t, e) {
                        var r = {},
                            a = [];
                        if (!i.validate(t, n.pkcs7.asn1.encryptedDataValidator, r, a)) throw (o = new Error("Cannot read EncryptedContentInfo.")).errors = a, o;
                        var o, u = i.derToOid(r.contentType);
                        if (u !== s.oids.data) throw (o = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.")).oid = u, o;
                        u = i.derToOid(r.encAlgorithm);
                        var c = s.pbe.getCipher(u, r.encParameter, e),
                            h = p(r.encryptedContentAsn1),
                            l = n.util.createBuffer(h.value);
                        if (c.update(l), !c.finish()) throw new Error("Failed to decrypt PKCS#12 SafeContents.");
                        return c.output.getBytes()
                    }

                    function g(t, e, r) {
                        if (!e && 0 === t.length) return [];
                        if ((t = i.fromDer(t, e)).tagClass !== i.Class.UNIVERSAL || t.type !== i.Type.SEQUENCE || !0 !== t.constructed) throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
                        for (var n = [], a = 0; a < t.value.length; a++) {
                            var o = t.value[a],
                                u = {},
                                h = [];
                            if (!i.validate(o, c, u, h)) throw (v = new Error("Cannot read SafeBag.")).errors = h, v;
                            var f, p, d = {
                                type: i.derToOid(u.bagId),
                                attributes: y(u.bagAttributes)
                            };
                            n.push(d);
                            var g = u.bagValue.value[0];
                            switch (d.type) {
                                case s.oids.pkcs8ShroudedKeyBag:
                                    if (null === (g = s.decryptPrivateKeyInfo(g, r))) throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
                                case s.oids.keyBag:
                                    try {
                                        d.key = s.privateKeyFromAsn1(g)
                                    } catch (t) {
                                        d.key = null, d.asn1 = g
                                    }
                                    continue;
                                case s.oids.certBag:
                                    f = l, p = function() {
                                        if (i.derToOid(u.certId) !== s.oids.x509Certificate) {
                                            var t = new Error("Unsupported certificate type, only X.509 supported.");
                                            throw t.oid = i.derToOid(u.certId), t
                                        }
                                        var r = i.fromDer(u.cert, e);
                                        try {
                                            d.cert = s.certificateFromAsn1(r, !0)
                                        } catch (t) {
                                            d.cert = null, d.asn1 = r
                                        }
                                    };
                                    break;
                                default:
                                    var v;
                                    throw (v = new Error("Unsupported PKCS#12 SafeBag type.")).oid = d.type, v
                            }
                            if (void 0 !== f && !i.validate(g, f, u, h)) throw (v = new Error("Cannot read PKCS#12 " + f.name)).errors = h, v;
                            p()
                        }
                        return n
                    }

                    function y(t) {
                        var e = {};
                        if (void 0 !== t)
                            for (var r = 0; r < t.length; ++r) {
                                var n = {},
                                    a = [];
                                if (!i.validate(t[r], h, n, a)) {
                                    var o = new Error("Cannot read PKCS#12 BagAttribute.");
                                    throw o.errors = a, o
                                }
                                var u = i.derToOid(n.oid);
                                if (void 0 !== s.oids[u]) {
                                    e[s.oids[u]] = [];
                                    for (var c = 0; c < n.values.length; ++c) e[s.oids[u]].push(n.values[c].value)
                                }
                            }
                        return e
                    }
                    a.pkcs12FromAsn1 = function(t, e, r) {
                        "string" == typeof e ? (r = e, e = !0) : void 0 === e && (e = !0);
                        var c = {};
                        if (!i.validate(t, u, c, [])) throw (h = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.")).errors = h, h;
                        var h, l = {
                            version: c.version.charCodeAt(0),
                            safeContents: [],
                            getBags: function(t) {
                                var e, r = {};
                                return "localKeyId" in t ? e = t.localKeyId : "localKeyIdHex" in t && (e = n.util.hexToBytes(t.localKeyIdHex)), void 0 === e && !("friendlyName" in t) && "bagType" in t && (r[t.bagType] = f(l.safeContents, null, null, t.bagType)), void 0 !== e && (r.localKeyId = f(l.safeContents, "localKeyId", e, t.bagType)), "friendlyName" in t && (r.friendlyName = f(l.safeContents, "friendlyName", t.friendlyName, t.bagType)), r
                            },
                            getBagsByFriendlyName: function(t, e) {
                                return f(l.safeContents, "friendlyName", t, e)
                            },
                            getBagsByLocalKeyId: function(t, e) {
                                return f(l.safeContents, "localKeyId", t, e)
                            }
                        };
                        if (3 !== c.version.charCodeAt(0)) throw (h = new Error("PKCS#12 PFX of version other than 3 not supported.")).version = c.version.charCodeAt(0), h;
                        if (i.derToOid(c.contentType) !== s.oids.data) throw (h = new Error("Only PKCS#12 PFX in password integrity mode supported.")).oid = i.derToOid(c.contentType), h;
                        var y = c.content.value[0];
                        if (y.tagClass !== i.Class.UNIVERSAL || y.type !== i.Type.OCTETSTRING) throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
                        if (y = p(y), c.mac) {
                            var v = null,
                                m = 0,
                                E = i.derToOid(c.macAlgorithm);
                            switch (E) {
                                case s.oids.sha1:
                                    v = n.md.sha1.create(), m = 20;
                                    break;
                                case s.oids.sha256:
                                    v = n.md.sha256.create(), m = 32;
                                    break;
                                case s.oids.sha384:
                                    v = n.md.sha384.create(), m = 48;
                                    break;
                                case s.oids.sha512:
                                    v = n.md.sha512.create(), m = 64;
                                    break;
                                case s.oids.md5:
                                    v = n.md.md5.create(), m = 16
                            }
                            if (null === v) throw new Error("PKCS#12 uses unsupported MAC algorithm: " + E);
                            var S = new n.util.ByteBuffer(c.macSalt),
                                b = "macIterations" in c ? parseInt(n.util.bytesToHex(c.macIterations), 16) : 1,
                                C = a.generateKey(r, S, 3, b, m, v),
                                A = n.hmac.create();
                            if (A.start(v, C), A.update(y.value), A.getMac().getBytes() !== c.macDigest) throw new Error("PKCS#12 MAC could not be verified. Invalid password?")
                        }
                        return function(t, e, r, n) {
                            if ((e = i.fromDer(e, r)).tagClass !== i.Class.UNIVERSAL || e.type !== i.Type.SEQUENCE || !0 !== e.constructed) throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
                            for (var a = 0; a < e.value.length; a++) {
                                var u = e.value[a],
                                    c = {},
                                    h = [];
                                if (!i.validate(u, o, c, h)) throw (v = new Error("Cannot read ContentInfo.")).errors = h, v;
                                var l = {
                                        encrypted: !1
                                    },
                                    f = null,
                                    y = c.content.value[0];
                                switch (i.derToOid(c.contentType)) {
                                    case s.oids.data:
                                        if (y.tagClass !== i.Class.UNIVERSAL || y.type !== i.Type.OCTETSTRING) throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
                                        f = p(y).value;
                                        break;
                                    case s.oids.encryptedData:
                                        f = d(y, n), l.encrypted = !0;
                                        break;
                                    default:
                                        var v;
                                        throw (v = new Error("Unsupported PKCS#12 contentType.")).contentType = i.derToOid(c.contentType), v
                                }
                                l.safeBags = g(f, r, n), t.safeContents.push(l)
                            }
                        }(l, y.value, e, r), l
                    }, a.toPkcs12Asn1 = function(t, e, r, o) {
                        (o = o || {}).saltSize = o.saltSize || 8, o.count = o.count || 2048, o.algorithm = o.algorithm || o.encAlgorithm || "aes128", "useMac" in o || (o.useMac = !0), "localKeyId" in o || (o.localKeyId = null), "generateLocalKeyId" in o || (o.generateLocalKeyId = !0);
                        var u, c = o.localKeyId;
                        if (null !== c) c = n.util.hexToBytes(c);
                        else if (o.generateLocalKeyId)
                            if (e) {
                                var h = n.util.isArray(e) ? e[0] : e;
                                "string" == typeof h && (h = s.certificateFromPem(h)), (I = n.md.sha1.create()).update(i.toDer(s.certificateToAsn1(h)).getBytes()), c = I.digest().getBytes()
                            } else c = n.random.getBytes(20);
                        var l = [];
                        null !== c && l.push(i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(s.oids.localKeyId).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.SET, !0, [i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, c)])])), "friendlyName" in o && l.push(i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(s.oids.friendlyName).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.SET, !0, [i.create(i.Class.UNIVERSAL, i.Type.BMPSTRING, !1, o.friendlyName)])])), l.length > 0 && (u = i.create(i.Class.UNIVERSAL, i.Type.SET, !0, l));
                        var f = [],
                            p = [];
                        null !== e && (p = n.util.isArray(e) ? e : [e]);
                        for (var d = [], g = 0; g < p.length; ++g) {
                            "string" == typeof(e = p[g]) && (e = s.certificateFromPem(e));
                            var y = 0 === g ? u : void 0,
                                v = s.certificateToAsn1(e),
                                m = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(s.oids.certBag).getBytes()), i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(s.oids.x509Certificate).getBytes()), i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, i.toDer(v).getBytes())])])]), y]);
                            d.push(m)
                        }
                        if (d.length > 0) {
                            var E = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, d),
                                S = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(s.oids.data).getBytes()), i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, i.toDer(E).getBytes())])]);
                            f.push(S)
                        }
                        var b = null;
                        if (null !== t) {
                            var C = s.wrapRsaPrivateKey(s.privateKeyToAsn1(t));
                            b = null === r ? i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(s.oids.keyBag).getBytes()), i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [C]), u]) : i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(s.oids.pkcs8ShroudedKeyBag).getBytes()), i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [s.encryptPrivateKeyInfo(C, r, o)]), u]);
                            var A = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [b]),
                                w = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(s.oids.data).getBytes()), i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, i.toDer(A).getBytes())])]);
                            f.push(w)
                        }
                        var T, x = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, f);
                        if (o.useMac) {
                            var I = n.md.sha1.create(),
                                B = new n.util.ByteBuffer(n.random.getBytes(o.saltSize)),
                                F = o.count,
                                R = (t = a.generateKey(r, B, 3, F, 20), n.hmac.create());
                            R.start(I, t), R.update(i.toDer(x).getBytes());
                            var D = R.getMac();
                            T = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(s.oids.sha1).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.NULL, !1, "")]), i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, D.getBytes())]), i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, B.getBytes()), i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, i.integerToDer(F).getBytes())])
                        }
                        return i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, i.integerToDer(3).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(s.oids.data).getBytes()), i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, i.toDer(x).getBytes())])]), T])
                    }, a.generateKey = n.pbe.generatePkcs12Key
                }, function(t, e, r) {
                    var n = r(0);
                    r(3), r(1);
                    var i = n.asn1,
                        s = t.exports = n.pkcs7asn1 = n.pkcs7asn1 || {};
                    n.pkcs7 = n.pkcs7 || {}, n.pkcs7.asn1 = s;
                    var a = {
                        name: "ContentInfo",
                        tagClass: i.Class.UNIVERSAL,
                        type: i.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                            name: "ContentInfo.ContentType",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.OID,
                            constructed: !1,
                            capture: "contentType"
                        }, {
                            name: "ContentInfo.content",
                            tagClass: i.Class.CONTEXT_SPECIFIC,
                            type: 0,
                            constructed: !0,
                            optional: !0,
                            captureAsn1: "content"
                        }]
                    };
                    s.contentInfoValidator = a;
                    var o = {
                        name: "EncryptedContentInfo",
                        tagClass: i.Class.UNIVERSAL,
                        type: i.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                            name: "EncryptedContentInfo.contentType",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.OID,
                            constructed: !1,
                            capture: "contentType"
                        }, {
                            name: "EncryptedContentInfo.contentEncryptionAlgorithm",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.OID,
                                constructed: !1,
                                capture: "encAlgorithm"
                            }, {
                                name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
                                tagClass: i.Class.UNIVERSAL,
                                captureAsn1: "encParameter"
                            }]
                        }, {
                            name: "EncryptedContentInfo.encryptedContent",
                            tagClass: i.Class.CONTEXT_SPECIFIC,
                            type: 0,
                            capture: "encryptedContent",
                            captureAsn1: "encryptedContentAsn1"
                        }]
                    };
                    s.envelopedDataValidator = {
                        name: "EnvelopedData",
                        tagClass: i.Class.UNIVERSAL,
                        type: i.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                            name: "EnvelopedData.Version",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.INTEGER,
                            constructed: !1,
                            capture: "version"
                        }, {
                            name: "EnvelopedData.RecipientInfos",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SET,
                            constructed: !0,
                            captureAsn1: "recipientInfos"
                        }].concat(o)
                    }, s.encryptedDataValidator = {
                        name: "EncryptedData",
                        tagClass: i.Class.UNIVERSAL,
                        type: i.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                            name: "EncryptedData.Version",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.INTEGER,
                            constructed: !1,
                            capture: "version"
                        }].concat(o)
                    };
                    var u = {
                        name: "SignerInfo",
                        tagClass: i.Class.UNIVERSAL,
                        type: i.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                            name: "SignerInfo.version",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.INTEGER,
                            constructed: !1
                        }, {
                            name: "SignerInfo.issuerAndSerialNumber",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "SignerInfo.issuerAndSerialNumber.issuer",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.SEQUENCE,
                                constructed: !0,
                                captureAsn1: "issuer"
                            }, {
                                name: "SignerInfo.issuerAndSerialNumber.serialNumber",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.INTEGER,
                                constructed: !1,
                                capture: "serial"
                            }]
                        }, {
                            name: "SignerInfo.digestAlgorithm",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "SignerInfo.digestAlgorithm.algorithm",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.OID,
                                constructed: !1,
                                capture: "digestAlgorithm"
                            }, {
                                name: "SignerInfo.digestAlgorithm.parameter",
                                tagClass: i.Class.UNIVERSAL,
                                constructed: !1,
                                captureAsn1: "digestParameter",
                                optional: !0
                            }]
                        }, {
                            name: "SignerInfo.authenticatedAttributes",
                            tagClass: i.Class.CONTEXT_SPECIFIC,
                            type: 0,
                            constructed: !0,
                            optional: !0,
                            capture: "authenticatedAttributes"
                        }, {
                            name: "SignerInfo.digestEncryptionAlgorithm",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            capture: "signatureAlgorithm"
                        }, {
                            name: "SignerInfo.encryptedDigest",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.OCTETSTRING,
                            constructed: !1,
                            capture: "signature"
                        }, {
                            name: "SignerInfo.unauthenticatedAttributes",
                            tagClass: i.Class.CONTEXT_SPECIFIC,
                            type: 1,
                            constructed: !0,
                            optional: !0,
                            capture: "unauthenticatedAttributes"
                        }]
                    };
                    s.signedDataValidator = {
                        name: "SignedData",
                        tagClass: i.Class.UNIVERSAL,
                        type: i.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                            name: "SignedData.Version",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.INTEGER,
                            constructed: !1,
                            capture: "version"
                        }, {
                            name: "SignedData.DigestAlgorithms",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SET,
                            constructed: !0,
                            captureAsn1: "digestAlgorithms"
                        }, a, {
                            name: "SignedData.Certificates",
                            tagClass: i.Class.CONTEXT_SPECIFIC,
                            type: 0,
                            optional: !0,
                            captureAsn1: "certificates"
                        }, {
                            name: "SignedData.CertificateRevocationLists",
                            tagClass: i.Class.CONTEXT_SPECIFIC,
                            type: 1,
                            optional: !0,
                            captureAsn1: "crls"
                        }, {
                            name: "SignedData.SignerInfos",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SET,
                            capture: "signerInfos",
                            optional: !0,
                            value: [u]
                        }]
                    }, s.recipientInfoValidator = {
                        name: "RecipientInfo",
                        tagClass: i.Class.UNIVERSAL,
                        type: i.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                            name: "RecipientInfo.version",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.INTEGER,
                            constructed: !1,
                            capture: "version"
                        }, {
                            name: "RecipientInfo.issuerAndSerial",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "RecipientInfo.issuerAndSerial.issuer",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.SEQUENCE,
                                constructed: !0,
                                captureAsn1: "issuer"
                            }, {
                                name: "RecipientInfo.issuerAndSerial.serialNumber",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.INTEGER,
                                constructed: !1,
                                capture: "serial"
                            }]
                        }, {
                            name: "RecipientInfo.keyEncryptionAlgorithm",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.OID,
                                constructed: !1,
                                capture: "encAlgorithm"
                            }, {
                                name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
                                tagClass: i.Class.UNIVERSAL,
                                constructed: !1,
                                captureAsn1: "encParameter"
                            }]
                        }, {
                            name: "RecipientInfo.encryptedKey",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.OCTETSTRING,
                            constructed: !1,
                            capture: "encKey"
                        }]
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(1), n.mgf = n.mgf || {}, (t.exports = n.mgf.mgf1 = n.mgf1 = n.mgf1 || {}).create = function(t) {
                        return {
                            generate: function(e, r) {
                                for (var i = new n.util.ByteBuffer, s = Math.ceil(r / t.digestLength), a = 0; a < s; a++) {
                                    var o = new n.util.ByteBuffer;
                                    o.putInt32(a), t.start(), t.update(e + o.getBytes()), i.putBuffer(t.digest())
                                }
                                return i.truncate(i.length() - r), i.getBytes()
                            }
                        }
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    t.exports = n.debug = n.debug || {}, n.debug.storage = {}, n.debug.get = function(t, e) {
                        var r;
                        return void 0 === t ? r = n.debug.storage : t in n.debug.storage && (r = void 0 === e ? n.debug.storage[t] : n.debug.storage[t][e]), r
                    }, n.debug.set = function(t, e, r) {
                        t in n.debug.storage || (n.debug.storage[t] = {}), n.debug.storage[t][e] = r
                    }, n.debug.clear = function(t, e) {
                        void 0 === t ? n.debug.storage = {} : t in n.debug.storage && (void 0 === e ? delete n.debug.storage[t] : delete n.debug.storage[t][e])
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(4), r(1);
                    var i = t.exports = n.sha512 = n.sha512 || {};
                    n.md.sha512 = n.md.algorithms.sha512 = i;
                    var s = n.sha384 = n.sha512.sha384 = n.sha512.sha384 || {};
                    s.create = function() {
                        return i.create("SHA-384")
                    }, n.md.sha384 = n.md.algorithms.sha384 = s, n.sha512.sha256 = n.sha512.sha256 || {
                        create: function() {
                            return i.create("SHA-512/256")
                        }
                    }, n.md["sha512/256"] = n.md.algorithms["sha512/256"] = n.sha512.sha256, n.sha512.sha224 = n.sha512.sha224 || {
                        create: function() {
                            return i.create("SHA-512/224")
                        }
                    }, n.md["sha512/224"] = n.md.algorithms["sha512/224"] = n.sha512.sha224, i.create = function(t) {
                        if (o || (a = String.fromCharCode(128), a += n.util.fillString(String.fromCharCode(0), 128), u = [
                                [1116352408, 3609767458],
                                [1899447441, 602891725],
                                [3049323471, 3964484399],
                                [3921009573, 2173295548],
                                [961987163, 4081628472],
                                [1508970993, 3053834265],
                                [2453635748, 2937671579],
                                [2870763221, 3664609560],
                                [3624381080, 2734883394],
                                [310598401, 1164996542],
                                [607225278, 1323610764],
                                [1426881987, 3590304994],
                                [1925078388, 4068182383],
                                [2162078206, 991336113],
                                [2614888103, 633803317],
                                [3248222580, 3479774868],
                                [3835390401, 2666613458],
                                [4022224774, 944711139],
                                [264347078, 2341262773],
                                [604807628, 2007800933],
                                [770255983, 1495990901],
                                [1249150122, 1856431235],
                                [1555081692, 3175218132],
                                [1996064986, 2198950837],
                                [2554220882, 3999719339],
                                [2821834349, 766784016],
                                [2952996808, 2566594879],
                                [3210313671, 3203337956],
                                [3336571891, 1034457026],
                                [3584528711, 2466948901],
                                [113926993, 3758326383],
                                [338241895, 168717936],
                                [666307205, 1188179964],
                                [773529912, 1546045734],
                                [1294757372, 1522805485],
                                [1396182291, 2643833823],
                                [1695183700, 2343527390],
                                [1986661051, 1014477480],
                                [2177026350, 1206759142],
                                [2456956037, 344077627],
                                [2730485921, 1290863460],
                                [2820302411, 3158454273],
                                [3259730800, 3505952657],
                                [3345764771, 106217008],
                                [3516065817, 3606008344],
                                [3600352804, 1432725776],
                                [4094571909, 1467031594],
                                [275423344, 851169720],
                                [430227734, 3100823752],
                                [506948616, 1363258195],
                                [659060556, 3750685593],
                                [883997877, 3785050280],
                                [958139571, 3318307427],
                                [1322822218, 3812723403],
                                [1537002063, 2003034995],
                                [1747873779, 3602036899],
                                [1955562222, 1575990012],
                                [2024104815, 1125592928],
                                [2227730452, 2716904306],
                                [2361852424, 442776044],
                                [2428436474, 593698344],
                                [2756734187, 3733110249],
                                [3204031479, 2999351573],
                                [3329325298, 3815920427],
                                [3391569614, 3928383900],
                                [3515267271, 566280711],
                                [3940187606, 3454069534],
                                [4118630271, 4000239992],
                                [116418474, 1914138554],
                                [174292421, 2731055270],
                                [289380356, 3203993006],
                                [460393269, 320620315],
                                [685471733, 587496836],
                                [852142971, 1086792851],
                                [1017036298, 365543100],
                                [1126000580, 2618297676],
                                [1288033470, 3409855158],
                                [1501505948, 4234509866],
                                [1607167915, 987167468],
                                [1816402316, 1246189591]
                            ], (c = {})["SHA-512"] = [
                                [1779033703, 4089235720],
                                [3144134277, 2227873595],
                                [1013904242, 4271175723],
                                [2773480762, 1595750129],
                                [1359893119, 2917565137],
                                [2600822924, 725511199],
                                [528734635, 4215389547],
                                [1541459225, 327033209]
                            ], c["SHA-384"] = [
                                [3418070365, 3238371032],
                                [1654270250, 914150663],
                                [2438529370, 812702999],
                                [355462360, 4144912697],
                                [1731405415, 4290775857],
                                [2394180231, 1750603025],
                                [3675008525, 1694076839],
                                [1203062813, 3204075428]
                            ], c["SHA-512/256"] = [
                                [573645204, 4230739756],
                                [2673172387, 3360449730],
                                [596883563, 1867755857],
                                [2520282905, 1497426621],
                                [2519219938, 2827943907],
                                [3193839141, 1401305490],
                                [721525244, 746961066],
                                [246885852, 2177182882]
                            ], c["SHA-512/224"] = [
                                [2352822216, 424955298],
                                [1944164710, 2312950998],
                                [502970286, 855612546],
                                [1738396948, 1479516111],
                                [258812777, 2077511080],
                                [2011393907, 79989058],
                                [1067287976, 1780299464],
                                [286451373, 2446758561]
                            ], o = !0), void 0 === t && (t = "SHA-512"), !(t in c)) throw new Error("Invalid SHA-512 algorithm: " + t);
                        for (var e = c[t], r = null, i = n.util.createBuffer(), s = new Array(80), l = 0; l < 80; ++l) s[l] = new Array(2);
                        var f = 64;
                        switch (t) {
                            case "SHA-384":
                                f = 48;
                                break;
                            case "SHA-512/256":
                                f = 32;
                                break;
                            case "SHA-512/224":
                                f = 28
                        }
                        var p = {
                            algorithm: t.replace("-", "").toLowerCase(),
                            blockLength: 128,
                            digestLength: f,
                            messageLength: 0,
                            fullMessageLength: null,
                            messageLengthSize: 16,
                            start: function() {
                                p.messageLength = 0, p.fullMessageLength = p.messageLength128 = [];
                                for (var t = p.messageLengthSize / 4, s = 0; s < t; ++s) p.fullMessageLength.push(0);
                                for (i = n.util.createBuffer(), r = new Array(e.length), s = 0; s < e.length; ++s) r[s] = e[s].slice(0);
                                return p
                            }
                        };
                        return p.start(), p.update = function(t, e) {
                            "utf8" === e && (t = n.util.encodeUtf8(t));
                            var a = t.length;
                            p.messageLength += a, a = [a / 4294967296 >>> 0, a >>> 0];
                            for (var o = p.fullMessageLength.length - 1; o >= 0; --o) p.fullMessageLength[o] += a[1], a[1] = a[0] + (p.fullMessageLength[o] / 4294967296 >>> 0), p.fullMessageLength[o] = p.fullMessageLength[o] >>> 0, a[0] = a[1] / 4294967296 >>> 0;
                            return i.putBytes(t), h(r, s, i), (i.read > 2048 || 0 === i.length()) && i.compact(), p
                        }, p.digest = function() {
                            var e = n.util.createBuffer();
                            e.putBytes(i.bytes());
                            var o, u = p.fullMessageLength[p.fullMessageLength.length - 1] + p.messageLengthSize & p.blockLength - 1;
                            e.putBytes(a.substr(0, p.blockLength - u));
                            for (var c = 8 * p.fullMessageLength[0], l = 0; l < p.fullMessageLength.length - 1; ++l) c += (o = 8 * p.fullMessageLength[l + 1]) / 4294967296 >>> 0, e.putInt32(c >>> 0), c = o >>> 0;
                            e.putInt32(c);
                            var f = new Array(r.length);
                            for (l = 0; l < r.length; ++l) f[l] = r[l].slice(0);
                            h(f, s, e);
                            var d, g = n.util.createBuffer();
                            for (d = "SHA-512" === t ? f.length : "SHA-384" === t ? f.length - 2 : f.length - 4, l = 0; l < d; ++l) g.putInt32(f[l][0]), l === d - 1 && "SHA-512/224" === t || g.putInt32(f[l][1]);
                            return g
                        }, p
                    };
                    var a = null,
                        o = !1,
                        u = null,
                        c = null;

                    function h(t, e, r) {
                        for (var n, i, s, a, o, c, h, l, f, p, d, g, y, v, m, E, S, b, C, A, w, T, x, I, B, F, R, D, N, _, P, k, L, O = r.length(); O >= 128;) {
                            for (R = 0; R < 16; ++R) e[R][0] = r.getInt32() >>> 0, e[R][1] = r.getInt32() >>> 0;
                            for (; R < 80; ++R) n = (((D = (_ = e[R - 2])[0]) >>> 19 | (N = _[1]) << 13) ^ (N >>> 29 | D << 3) ^ D >>> 6) >>> 0, i = ((D << 13 | N >>> 19) ^ (N << 3 | D >>> 29) ^ (D << 26 | N >>> 6)) >>> 0, s = (((D = (k = e[R - 15])[0]) >>> 1 | (N = k[1]) << 31) ^ (D >>> 8 | N << 24) ^ D >>> 7) >>> 0, a = ((D << 31 | N >>> 1) ^ (D << 24 | N >>> 8) ^ (D << 25 | N >>> 7)) >>> 0, P = e[R - 7], L = e[R - 16], N = i + P[1] + a + L[1], e[R][0] = n + P[0] + s + L[0] + (N / 4294967296 >>> 0) >>> 0, e[R][1] = N >>> 0;
                            for (d = t[0][0], g = t[0][1], y = t[1][0], v = t[1][1], m = t[2][0], E = t[2][1], S = t[3][0], b = t[3][1], C = t[4][0], A = t[4][1], w = t[5][0], T = t[5][1], x = t[6][0], I = t[6][1], B = t[7][0], F = t[7][1], R = 0; R < 80; ++R) h = ((C >>> 14 | A << 18) ^ (C >>> 18 | A << 14) ^ (A >>> 9 | C << 23)) >>> 0, l = (x ^ C & (w ^ x)) >>> 0, o = ((d >>> 28 | g << 4) ^ (g >>> 2 | d << 30) ^ (g >>> 7 | d << 25)) >>> 0, c = ((d << 4 | g >>> 28) ^ (g << 30 | d >>> 2) ^ (g << 25 | d >>> 7)) >>> 0, f = (d & y | m & (d ^ y)) >>> 0, p = (g & v | E & (g ^ v)) >>> 0, N = F + (((C << 18 | A >>> 14) ^ (C << 14 | A >>> 18) ^ (A << 23 | C >>> 9)) >>> 0) + ((I ^ A & (T ^ I)) >>> 0) + u[R][1] + e[R][1], n = B + h + l + u[R][0] + e[R][0] + (N / 4294967296 >>> 0) >>> 0, i = N >>> 0, s = o + f + ((N = c + p) / 4294967296 >>> 0) >>> 0, a = N >>> 0, B = x, F = I, x = w, I = T, w = C, T = A, C = S + n + ((N = b + i) / 4294967296 >>> 0) >>> 0, A = N >>> 0, S = m, b = E, m = y, E = v, y = d, v = g, d = n + s + ((N = i + a) / 4294967296 >>> 0) >>> 0, g = N >>> 0;
                            N = t[0][1] + g, t[0][0] = t[0][0] + d + (N / 4294967296 >>> 0) >>> 0, t[0][1] = N >>> 0, N = t[1][1] + v, t[1][0] = t[1][0] + y + (N / 4294967296 >>> 0) >>> 0, t[1][1] = N >>> 0, N = t[2][1] + E, t[2][0] = t[2][0] + m + (N / 4294967296 >>> 0) >>> 0, t[2][1] = N >>> 0, N = t[3][1] + b, t[3][0] = t[3][0] + S + (N / 4294967296 >>> 0) >>> 0, t[3][1] = N >>> 0, N = t[4][1] + A, t[4][0] = t[4][0] + C + (N / 4294967296 >>> 0) >>> 0, t[4][1] = N >>> 0, N = t[5][1] + T, t[5][0] = t[5][0] + w + (N / 4294967296 >>> 0) >>> 0, t[5][1] = N >>> 0, N = t[6][1] + I, t[6][0] = t[6][0] + x + (N / 4294967296 >>> 0) >>> 0, t[6][1] = N >>> 0, N = t[7][1] + F, t[7][0] = t[7][0] + B + (N / 4294967296 >>> 0) >>> 0, t[7][1] = N >>> 0, O -= 128
                        }
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(1), t.exports = n.log = n.log || {}, n.log.levels = ["none", "error", "warning", "info", "debug", "verbose", "max"];
                    var i = {},
                        s = [],
                        a = null;
                    n.log.LEVEL_LOCKED = 2, n.log.NO_LEVEL_CHECK = 4, n.log.INTERPOLATE = 8;
                    for (var o = 0; o < n.log.levels.length; ++o) {
                        var u = n.log.levels[o];
                        i[u] = {
                            index: o,
                            name: u.toUpperCase()
                        }
                    }
                    n.log.logMessage = function(t) {
                        for (var e = i[t.level].index, r = 0; r < s.length; ++r) {
                            var a = s[r];
                            a.flags & n.log.NO_LEVEL_CHECK ? a.f(t) : e <= i[a.level].index && a.f(a, t)
                        }
                    }, n.log.prepareStandard = function(t) {
                        "standard" in t || (t.standard = i[t.level].name + " [" + t.category + "] " + t.message)
                    }, n.log.prepareFull = function(t) {
                        if (!("full" in t)) {
                            var e = [t.message];
                            e = e.concat([] || !1), t.full = n.util.format.apply(this, e)
                        }
                    }, n.log.prepareStandardFull = function(t) {
                        "standardFull" in t || (n.log.prepareStandard(t), t.standardFull = t.standard)
                    };
                    var c = ["error", "warning", "info", "debug", "verbose"];
                    for (o = 0; o < c.length; ++o) ! function(t) {
                        n.log[t] = function(e, r) {
                            var i = Array.prototype.slice.call(arguments).slice(2),
                                s = {
                                    timestamp: new Date,
                                    level: t,
                                    category: e,
                                    message: r,
                                    arguments: i
                                };
                            n.log.logMessage(s)
                        }
                    }(c[o]);
                    if (n.log.makeLogger = function(t) {
                            var e = {
                                flags: 0,
                                f: t
                            };
                            return n.log.setLevel(e, "none"), e
                        }, n.log.setLevel = function(t, e) {
                            var r = !1;
                            if (t && !(t.flags & n.log.LEVEL_LOCKED))
                                for (var i = 0; i < n.log.levels.length; ++i)
                                    if (e == n.log.levels[i]) {
                                        t.level = e, r = !0;
                                        break
                                    }
                            return r
                        }, n.log.lock = function(t, e) {
                            void 0 === e || e ? t.flags |= n.log.LEVEL_LOCKED : t.flags &= ~n.log.LEVEL_LOCKED
                        }, n.log.addLogger = function(t) {
                            s.push(t)
                        }, "undefined" != typeof console && "log" in console) {
                        var h;
                        if (console.error && console.warn && console.info && console.debug) {
                            var l = {
                                    error: console.error,
                                    warning: console.warn,
                                    info: console.info,
                                    debug: console.debug,
                                    verbose: console.debug
                                },
                                f = function(t, e) {
                                    n.log.prepareStandard(e);
                                    var r = l[e.level],
                                        i = [e.standard];
                                    i = i.concat(e.arguments.slice()), r.apply(console, i)
                                };
                            h = n.log.makeLogger(f)
                        } else f = function(t, e) {
                            n.log.prepareStandardFull(e), console.log(e.standardFull)
                        }, h = n.log.makeLogger(f);
                        n.log.setLevel(h, "debug"), n.log.addLogger(h), a = h
                    } else console = {
                        log: function() {}
                    };
                    if (null !== a) {
                        var p = n.util.getQueryVariables();
                        "console.level" in p && n.log.setLevel(a, p["console.level"].slice(-1)[0]), "console.lock" in p && "true" == p["console.lock"].slice(-1)[0] && n.log.lock(a)
                    }
                    n.log.consoleLogger = a
                }, function(t, e, r) {
                    t.exports = r(35)
                }, function(t, e, r) {
                    t.exports = r(0), r(5), r(38), r(3), r(13), r(31), r(10), r(40), r(8), r(42), r(33), r(43), r(30), r(15), r(7), r(26), r(28), r(44), r(21), r(27), r(24), r(18), r(2), r(25), r(45), r(46), r(20), r(1)
                }, function(t, e) {
                    var r;
                    r = function() {
                        return this
                    }();
                    try {
                        r = r || Function("return this")() || (0, eval)("this")
                    } catch (t) {
                        "object" === ("undefined" == typeof window ? "undefined" : h(window)) && (r = window)
                    }
                    t.exports = r
                }, function(t, e) {
                    var r = {};
                    t.exports = r;
                    var n = {};
                    r.encode = function(t, e, r) {
                        if ("string" != typeof e) throw new TypeError('"alphabet" must be a string.');
                        if (void 0 !== r && "number" != typeof r) throw new TypeError('"maxline" must be a number.');
                        var n = "";
                        if (t instanceof Uint8Array) {
                            var i = 0,
                                s = e.length,
                                a = e.charAt(0),
                                o = [0];
                            for (i = 0; i < t.length; ++i) {
                                for (var u = 0, c = t[i]; u < o.length; ++u) c += o[u] << 8, o[u] = c % s, c = c / s | 0;
                                for (; c > 0;) o.push(c % s), c = c / s | 0
                            }
                            for (i = 0; 0 === t[i] && i < t.length - 1; ++i) n += a;
                            for (i = o.length - 1; i >= 0; --i) n += e[o[i]]
                        } else n = function(t, e) {
                            var r = 0,
                                n = e.length,
                                i = e.charAt(0),
                                s = [0];
                            for (r = 0; r < t.length(); ++r) {
                                for (var a = 0, o = t.at(r); a < s.length; ++a) o += s[a] << 8, s[a] = o % n, o = o / n | 0;
                                for (; o > 0;) s.push(o % n), o = o / n | 0
                            }
                            var u = "";
                            for (r = 0; 0 === t.at(r) && r < t.length() - 1; ++r) u += i;
                            for (r = s.length - 1; r >= 0; --r) u += e[s[r]];
                            return u
                        }(t, e);
                        if (r) {
                            var h = new RegExp(".{1," + r + "}", "g");
                            n = n.match(h).join("\r\n")
                        }
                        return n
                    }, r.decode = function(t, e) {
                        if ("string" != typeof t) throw new TypeError('"input" must be a string.');
                        if ("string" != typeof e) throw new TypeError('"alphabet" must be a string.');
                        var r = n[e];
                        if (!r) {
                            r = n[e] = [];
                            for (var s = 0; s < e.length; ++s) r[e.charCodeAt(s)] = s
                        }
                        t = t.replace(/\s/g, "");
                        var a = e.length,
                            o = e.charAt(0),
                            u = [0];
                        for (s = 0; s < t.length; s++) {
                            var c = r[t.charCodeAt(s)];
                            if (void 0 === c) return;
                            for (var h = 0, l = c; h < u.length; ++h) l += u[h] * a, u[h] = 255 & l, l >>= 8;
                            for (; l > 0;) u.push(255 & l), l >>= 8
                        }
                        for (var f = 0; t[f] === o && f < t.length - 1; ++f) u.push(0);
                        return void 0 !== i ? i.from(u.reverse()) : new Uint8Array(u.reverse())
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(5), r(20);
                    var i = t.exports = n.tls;

                    function s(t, e, r) {
                        var s = e.entity === n.tls.ConnectionEnd.client;
                        t.read.cipherState = {
                            init: !1,
                            cipher: n.cipher.createDecipher("AES-CBC", s ? r.keys.server_write_key : r.keys.client_write_key),
                            iv: s ? r.keys.server_write_IV : r.keys.client_write_IV
                        }, t.write.cipherState = {
                            init: !1,
                            cipher: n.cipher.createCipher("AES-CBC", s ? r.keys.client_write_key : r.keys.server_write_key),
                            iv: s ? r.keys.client_write_IV : r.keys.server_write_IV
                        }, t.read.cipherFunction = c, t.write.cipherFunction = a, t.read.macLength = t.write.macLength = r.mac_length, t.read.macFunction = t.write.macFunction = i.hmac_sha1
                    }

                    function a(t, e) {
                        var r, s = !1,
                            a = e.macFunction(e.macKey, e.sequenceNumber, t);
                        t.fragment.putBytes(a), e.updateSequenceNumber(), r = t.version.minor === i.Versions.TLS_1_0.minor ? e.cipherState.init ? null : e.cipherState.iv : n.random.getBytesSync(16), e.cipherState.init = !0;
                        var u = e.cipherState.cipher;
                        return u.start({
                            iv: r
                        }), t.version.minor >= i.Versions.TLS_1_1.minor && u.output.putBytes(r), u.update(t.fragment), u.finish(o) && (t.fragment = u.output, t.length = t.fragment.length(), s = !0), s
                    }

                    function o(t, e, r) {
                        if (!r) {
                            var n = t - e.length() % t;
                            e.fillWithByte(n - 1, n)
                        }
                        return !0
                    }

                    function u(t, e, r) {
                        var n = !0;
                        if (r) {
                            for (var i = e.length(), s = e.last(), a = i - 1 - s; a < i - 1; ++a) n = n && e.at(a) == s;
                            n && e.truncate(s + 1)
                        }
                        return n
                    }

                    function c(t, e) {
                        var r, s = !1;
                        r = t.version.minor === i.Versions.TLS_1_0.minor ? e.cipherState.init ? null : e.cipherState.iv : t.fragment.getBytes(16), e.cipherState.init = !0;
                        var a = e.cipherState.cipher;
                        a.start({
                            iv: r
                        }), a.update(t.fragment), s = a.finish(u);
                        var o = e.macLength,
                            c = n.random.getBytesSync(o),
                            h = a.output.length();
                        h >= o ? (t.fragment = a.output.getBytes(h - o), c = a.output.getBytes(o)) : t.fragment = a.output.getBytes(), t.fragment = n.util.createBuffer(t.fragment), t.length = t.fragment.length();
                        var l = e.macFunction(e.macKey, e.sequenceNumber, t);
                        return e.updateSequenceNumber(), s = function(t, e, r) {
                            var i = n.hmac.create();
                            return i.start("SHA1", t), i.update(e), e = i.digest().getBytes(), i.start(null, null), i.update(r), r = i.digest().getBytes(), e === r
                        }(e.macKey, c, l) && s
                    }
                    i.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
                        id: [0, 47],
                        name: "TLS_RSA_WITH_AES_128_CBC_SHA",
                        initSecurityParameters: function(t) {
                            t.bulk_cipher_algorithm = i.BulkCipherAlgorithm.aes, t.cipher_type = i.CipherType.block, t.enc_key_length = 16, t.block_length = 16, t.fixed_iv_length = 16, t.record_iv_length = 16, t.mac_algorithm = i.MACAlgorithm.hmac_sha1, t.mac_length = 20, t.mac_key_length = 20
                        },
                        initConnectionState: s
                    }, i.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
                        id: [0, 53],
                        name: "TLS_RSA_WITH_AES_256_CBC_SHA",
                        initSecurityParameters: function(t) {
                            t.bulk_cipher_algorithm = i.BulkCipherAlgorithm.aes, t.cipher_type = i.CipherType.block, t.enc_key_length = 32, t.block_length = 16, t.fixed_iv_length = 16, t.record_iv_length = 16, t.mac_algorithm = i.MACAlgorithm.hmac_sha1, t.mac_length = 20, t.mac_key_length = 20
                        },
                        initConnectionState: s
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(30), t.exports = n.mgf = n.mgf || {}, n.mgf.mgf1 = n.mgf1
                }, function(t, e, r) {
                    var n = r(0);
                    r(12), r(2), r(32), r(1);
                    var s = r(41),
                        a = s.publicKeyValidator,
                        o = s.privateKeyValidator;
                    if (void 0 === u) var u = n.jsbn.BigInteger;
                    var c = n.util.ByteBuffer,
                        h = void 0 === i ? Uint8Array : i;
                    n.pki = n.pki || {}, t.exports = n.pki.ed25519 = n.ed25519 = n.ed25519 || {};
                    var l = n.ed25519;

                    function f(t) {
                        var e = t.message;
                        if (e instanceof Uint8Array || e instanceof h) return e;
                        var r = t.encoding;
                        if (void 0 === e) {
                            if (!t.md) throw new TypeError('"options.message" or "options.md" not specified.');
                            e = t.md.digest().getBytes(), r = "binary"
                        }
                        if ("string" == typeof e && !r) throw new TypeError('"options.encoding" must be "binary" or "utf8".');
                        if ("string" == typeof e) {
                            if (void 0 !== i) return i.from(e, r);
                            e = new c(e, r)
                        } else if (!(e instanceof c)) throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
                        for (var n = new h(e.length()), s = 0; s < n.length; ++s) n[s] = e.at(s);
                        return n
                    }
                    l.constants = {}, l.constants.PUBLIC_KEY_BYTE_LENGTH = 32, l.constants.PRIVATE_KEY_BYTE_LENGTH = 64, l.constants.SEED_BYTE_LENGTH = 32, l.constants.SIGN_BYTE_LENGTH = 64, l.constants.HASH_BYTE_LENGTH = 64, l.generateKeyPair = function(t) {
                        var e = (t = t || {}).seed;
                        if (void 0 === e) e = n.random.getBytesSync(l.constants.SEED_BYTE_LENGTH);
                        else if ("string" == typeof e) {
                            if (e.length !== l.constants.SEED_BYTE_LENGTH) throw new TypeError('"seed" must be ' + l.constants.SEED_BYTE_LENGTH + " bytes in length.")
                        } else if (!(e instanceof Uint8Array)) throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
                        e = f({
                            message: e,
                            encoding: "binary"
                        });
                        for (var r = new h(l.constants.PUBLIC_KEY_BYTE_LENGTH), i = new h(l.constants.PRIVATE_KEY_BYTE_LENGTH), s = 0; s < 32; ++s) i[s] = e[s];
                        return function(t, e) {
                            var r, n = [L(), L(), L(), L()],
                                i = b(e, 32);
                            for (i[0] &= 248, i[31] &= 127, i[31] |= 64, N(n, i), x(t, n), r = 0; r < 32; ++r) e[r + 32] = t[r]
                        }(r, i), {
                            publicKey: r,
                            privateKey: i
                        }
                    }, l.privateKeyFromAsn1 = function(t) {
                        var e = {},
                            r = [];
                        if (!n.asn1.validate(t, o, e, r)) {
                            var i = new Error("Invalid Key.");
                            throw i.errors = r, i
                        }
                        var s = n.asn1.derToOid(e.privateKeyOid),
                            a = n.oids.EdDSA25519;
                        if (s !== a) throw new Error('Invalid OID "' + s + '"; OID must be "' + a + '".');
                        var u = e.privateKey;
                        return {
                            privateKeyBytes: f({
                                message: n.asn1.fromDer(u).value,
                                encoding: "binary"
                            })
                        }
                    }, l.publicKeyFromAsn1 = function(t) {
                        var e = {},
                            r = [];
                        if (!n.asn1.validate(t, a, e, r)) {
                            var i = new Error("Invalid Key.");
                            throw i.errors = r, i
                        }
                        var s = n.asn1.derToOid(e.publicKeyOid),
                            o = n.oids.EdDSA25519;
                        if (s !== o) throw new Error('Invalid OID "' + s + '"; OID must be "' + o + '".');
                        var u = e.ed25519PublicKey;
                        if (u.length !== l.constants.PUBLIC_KEY_BYTE_LENGTH) throw new Error("Key length is invalid.");
                        return f({
                            message: u,
                            encoding: "binary"
                        })
                    }, l.publicKeyFromPrivateKey = function(t) {
                        var e = f({
                            message: (t = t || {}).privateKey,
                            encoding: "binary"
                        });
                        if (e.length !== l.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError('"options.privateKey" must have a byte length of ' + l.constants.PRIVATE_KEY_BYTE_LENGTH);
                        for (var r = new h(l.constants.PUBLIC_KEY_BYTE_LENGTH), n = 0; n < r.length; ++n) r[n] = e[32 + n];
                        return r
                    }, l.sign = function(t) {
                        var e = f(t = t || {}),
                            r = f({
                                message: t.privateKey,
                                encoding: "binary"
                            });
                        if (r.length === l.constants.SEED_BYTE_LENGTH) r = l.generateKeyPair({
                            seed: r
                        }).privateKey;
                        else if (r.length !== l.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError('"options.privateKey" must have a byte length of ' + l.constants.SEED_BYTE_LENGTH + " or " + l.constants.PRIVATE_KEY_BYTE_LENGTH);
                        var n = new h(l.constants.SIGN_BYTE_LENGTH + e.length);
                        ! function(t, e, r, n) {
                            var i, s, a = new Float64Array(64),
                                o = [L(), L(), L(), L()],
                                u = b(n, 32);
                            u[0] &= 248, u[31] &= 127, u[31] |= 64;
                            for (i = 0; i < r; ++i) t[64 + i] = e[i];
                            for (i = 0; i < 32; ++i) t[32 + i] = u[32 + i];
                            var c = b(t.subarray(32), r + 32);
                            for (A(c), N(o, c), x(t, o), i = 32; i < 64; ++i) t[i] = n[i];
                            var h = b(t, r + 64);
                            for (A(h), i = 32; i < 64; ++i) a[i] = 0;
                            for (i = 0; i < 32; ++i) a[i] = c[i];
                            for (i = 0; i < 32; ++i)
                                for (s = 0; s < 32; s++) a[i + s] += h[i] * u[s];
                            C(t.subarray(32), a)
                        }(n, e, e.length, r);
                        for (var i = new h(l.constants.SIGN_BYTE_LENGTH), s = 0; s < i.length; ++s) i[s] = n[s];
                        return i
                    }, l.verify = function(t) {
                        var e = f(t = t || {});
                        if (void 0 === t.signature) throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
                        var r = f({
                            message: t.signature,
                            encoding: "binary"
                        });
                        if (r.length !== l.constants.SIGN_BYTE_LENGTH) throw new TypeError('"options.signature" must have a byte length of ' + l.constants.SIGN_BYTE_LENGTH);
                        var n = f({
                            message: t.publicKey,
                            encoding: "binary"
                        });
                        if (n.length !== l.constants.PUBLIC_KEY_BYTE_LENGTH) throw new TypeError('"options.publicKey" must have a byte length of ' + l.constants.PUBLIC_KEY_BYTE_LENGTH);
                        var i, s = new h(l.constants.SIGN_BYTE_LENGTH + e.length),
                            a = new h(l.constants.SIGN_BYTE_LENGTH + e.length);
                        for (i = 0; i < l.constants.SIGN_BYTE_LENGTH; ++i) s[i] = r[i];
                        for (i = 0; i < e.length; ++i) s[i + l.constants.SIGN_BYTE_LENGTH] = e[i];
                        return function(t, e, r, n) {
                            var i, s = new h(32),
                                a = [L(), L(), L(), L()],
                                o = [L(), L(), L(), L()];
                            if (r < 64) return -1;
                            if (function(t, e) {
                                    var r = L(),
                                        n = L(),
                                        i = L(),
                                        s = L(),
                                        a = L(),
                                        o = L(),
                                        u = L();
                                    return _(t[2], d),
                                        function(t, e) {
                                            var r;
                                            for (r = 0; r < 16; ++r) t[r] = e[2 * r] + (e[2 * r + 1] << 8);
                                            t[15] &= 32767
                                        }(t[1], e), V(i, t[1]), H(s, i, g), U(i, i, t[2]), O(s, t[2], s), V(a, s), V(o, a), H(u, o, a), H(r, u, i), H(r, r, s),
                                        function(t, e) {
                                            var r, n = L();
                                            for (r = 0; r < 16; ++r) n[r] = e[r];
                                            for (r = 250; r >= 0; --r) V(n, n), 1 !== r && H(n, n, e);
                                            for (r = 0; r < 16; ++r) t[r] = n[r]
                                        }(r, r), H(r, r, i), H(r, r, s), H(r, r, s), H(t[0], r, s), V(n, t[0]), H(n, n, s), B(n, i) && H(t[0], t[0], S), V(n, t[0]), H(n, n, s), B(n, i) ? -1 : (R(t[0]) === e[31] >> 7 && U(t[0], p, t[0]), H(t[3], t[0], t[1]), 0)
                                }(o, n)) return -1;
                            for (i = 0; i < r; ++i) t[i] = e[i];
                            for (i = 0; i < 32; ++i) t[i + 32] = n[i];
                            var u = b(t, r);
                            if (A(u), D(a, o, u), N(o, e.subarray(32)), w(a, o), x(s, a), r -= 64, F(e, 0, s, 0)) {
                                for (i = 0; i < r; ++i) t[i] = 0;
                                return -1
                            }
                            for (i = 0; i < r; ++i) t[i] = e[i + 64];
                            return r
                        }(a, s, s.length, n) >= 0
                    };
                    var p = L(),
                        d = L([1]),
                        g = L([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
                        y = L([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
                        v = L([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
                        m = L([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
                        E = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]),
                        S = L([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

                    function b(t, e) {
                        var r = n.md.sha512.create(),
                            s = new c(t);
                        r.update(s.getBytes(e), "binary");
                        var a = r.digest().getBytes();
                        if (void 0 !== i) return i.from(a, "binary");
                        for (var o = new h(l.constants.HASH_BYTE_LENGTH), u = 0; u < 64; ++u) o[u] = a.charCodeAt(u);
                        return o
                    }

                    function C(t, e) {
                        var r, n, i, s;
                        for (n = 63; n >= 32; --n) {
                            for (r = 0, i = n - 32, s = n - 12; i < s; ++i) e[i] += r - 16 * e[n] * E[i - (n - 32)], r = e[i] + 128 >> 8, e[i] -= 256 * r;
                            e[i] += r, e[n] = 0
                        }
                        for (r = 0, i = 0; i < 32; ++i) e[i] += r - (e[31] >> 4) * E[i], r = e[i] >> 8, e[i] &= 255;
                        for (i = 0; i < 32; ++i) e[i] -= r * E[i];
                        for (n = 0; n < 32; ++n) e[n + 1] += e[n] >> 8, t[n] = 255 & e[n]
                    }

                    function A(t) {
                        for (var e = new Float64Array(64), r = 0; r < 64; ++r) e[r] = t[r], t[r] = 0;
                        C(t, e)
                    }

                    function w(t, e) {
                        var r = L(),
                            n = L(),
                            i = L(),
                            s = L(),
                            a = L(),
                            o = L(),
                            u = L(),
                            c = L(),
                            h = L();
                        U(r, t[1], t[0]), U(h, e[1], e[0]), H(r, r, h), O(n, t[0], t[1]), O(h, e[0], e[1]), H(n, n, h), H(i, t[3], e[3]), H(i, i, y), H(s, t[2], e[2]), O(s, s, s), U(a, n, r), U(o, s, i), O(u, s, i), O(c, n, r), H(t[0], a, o), H(t[1], c, u), H(t[2], u, o), H(t[3], a, c)
                    }

                    function T(t, e, r) {
                        for (var n = 0; n < 4; ++n) k(t[n], e[n], r)
                    }

                    function x(t, e) {
                        var r = L(),
                            n = L(),
                            i = L();
                        ! function(t, e) {
                            var r, n = L();
                            for (r = 0; r < 16; ++r) n[r] = e[r];
                            for (r = 253; r >= 0; --r) V(n, n), 2 !== r && 4 !== r && H(n, n, e);
                            for (r = 0; r < 16; ++r) t[r] = n[r]
                        }(i, e[2]), H(r, e[0], i), H(n, e[1], i), I(t, n), t[31] ^= R(r) << 7
                    }

                    function I(t, e) {
                        var r, n, i, s = L(),
                            a = L();
                        for (r = 0; r < 16; ++r) a[r] = e[r];
                        for (P(a), P(a), P(a), n = 0; n < 2; ++n) {
                            for (s[0] = a[0] - 65517, r = 1; r < 15; ++r) s[r] = a[r] - 65535 - (s[r - 1] >> 16 & 1), s[r - 1] &= 65535;
                            s[15] = a[15] - 32767 - (s[14] >> 16 & 1), i = s[15] >> 16 & 1, s[14] &= 65535, k(a, s, 1 - i)
                        }
                        for (r = 0; r < 16; r++) t[2 * r] = 255 & a[r], t[2 * r + 1] = a[r] >> 8
                    }

                    function B(t, e) {
                        var r = new h(32),
                            n = new h(32);
                        return I(r, t), I(n, e), F(r, 0, n, 0)
                    }

                    function F(t, e, r, n) {
                        return function(t, e, r, n, i) {
                            var s, a = 0;
                            for (s = 0; s < i; ++s) a |= t[e + s] ^ r[n + s];
                            return (1 & a - 1 >>> 8) - 1
                        }(t, e, r, n, 32)
                    }

                    function R(t) {
                        var e = new h(32);
                        return I(e, t), 1 & e[0]
                    }

                    function D(t, e, r) {
                        var n, i;
                        for (_(t[0], p), _(t[1], d), _(t[2], d), _(t[3], p), i = 255; i >= 0; --i) T(t, e, n = r[i / 8 | 0] >> (7 & i) & 1), w(e, t), w(t, t), T(t, e, n)
                    }

                    function N(t, e) {
                        var r = [L(), L(), L(), L()];
                        _(r[0], v), _(r[1], m), _(r[2], d), H(r[3], v, m), D(t, r, e)
                    }

                    function _(t, e) {
                        var r;
                        for (r = 0; r < 16; r++) t[r] = 0 | e[r]
                    }

                    function P(t) {
                        var e, r, n = 1;
                        for (e = 0; e < 16; ++e) r = t[e] + n + 65535, n = Math.floor(r / 65536), t[e] = r - 65536 * n;
                        t[0] += n - 1 + 37 * (n - 1)
                    }

                    function k(t, e, r) {
                        for (var n, i = ~(r - 1), s = 0; s < 16; ++s) n = i & (t[s] ^ e[s]), t[s] ^= n, e[s] ^= n
                    }

                    function L(t) {
                        var e, r = new Float64Array(16);
                        if (t)
                            for (e = 0; e < t.length; ++e) r[e] = t[e];
                        return r
                    }

                    function O(t, e, r) {
                        for (var n = 0; n < 16; ++n) t[n] = e[n] + r[n]
                    }

                    function U(t, e, r) {
                        for (var n = 0; n < 16; ++n) t[n] = e[n] - r[n]
                    }

                    function V(t, e) {
                        H(t, e, e)
                    }

                    function H(t, e, r) {
                        var n, i, s = 0,
                            a = 0,
                            o = 0,
                            u = 0,
                            c = 0,
                            h = 0,
                            l = 0,
                            f = 0,
                            p = 0,
                            d = 0,
                            g = 0,
                            y = 0,
                            v = 0,
                            m = 0,
                            E = 0,
                            S = 0,
                            b = 0,
                            C = 0,
                            A = 0,
                            w = 0,
                            T = 0,
                            x = 0,
                            I = 0,
                            B = 0,
                            F = 0,
                            R = 0,
                            D = 0,
                            N = 0,
                            _ = 0,
                            P = 0,
                            k = 0,
                            L = r[0],
                            O = r[1],
                            U = r[2],
                            V = r[3],
                            H = r[4],
                            j = r[5],
                            M = r[6],
                            K = r[7],
                            q = r[8],
                            z = r[9],
                            G = r[10],
                            Y = r[11],
                            W = r[12],
                            X = r[13],
                            Q = r[14],
                            Z = r[15];
                        s += (n = e[0]) * L, a += n * O, o += n * U, u += n * V, c += n * H, h += n * j, l += n * M, f += n * K, p += n * q, d += n * z, g += n * G, y += n * Y, v += n * W, m += n * X, E += n * Q, S += n * Z, a += (n = e[1]) * L, o += n * O, u += n * U, c += n * V, h += n * H, l += n * j, f += n * M, p += n * K, d += n * q, g += n * z, y += n * G, v += n * Y, m += n * W, E += n * X, S += n * Q, b += n * Z, o += (n = e[2]) * L, u += n * O, c += n * U, h += n * V, l += n * H, f += n * j, p += n * M, d += n * K, g += n * q, y += n * z, v += n * G, m += n * Y, E += n * W, S += n * X, b += n * Q, C += n * Z, u += (n = e[3]) * L, c += n * O, h += n * U, l += n * V, f += n * H, p += n * j, d += n * M, g += n * K, y += n * q, v += n * z, m += n * G, E += n * Y, S += n * W, b += n * X, C += n * Q, A += n * Z, c += (n = e[4]) * L, h += n * O, l += n * U, f += n * V, p += n * H, d += n * j, g += n * M, y += n * K, v += n * q, m += n * z, E += n * G, S += n * Y, b += n * W, C += n * X, A += n * Q, w += n * Z, h += (n = e[5]) * L, l += n * O, f += n * U, p += n * V, d += n * H, g += n * j, y += n * M, v += n * K, m += n * q, E += n * z, S += n * G, b += n * Y, C += n * W, A += n * X, w += n * Q, T += n * Z, l += (n = e[6]) * L, f += n * O, p += n * U, d += n * V, g += n * H, y += n * j, v += n * M, m += n * K, E += n * q, S += n * z, b += n * G, C += n * Y, A += n * W, w += n * X, T += n * Q, x += n * Z, f += (n = e[7]) * L, p += n * O, d += n * U, g += n * V, y += n * H, v += n * j, m += n * M, E += n * K, S += n * q, b += n * z, C += n * G, A += n * Y, w += n * W, T += n * X, x += n * Q, I += n * Z, p += (n = e[8]) * L, d += n * O, g += n * U, y += n * V, v += n * H, m += n * j, E += n * M, S += n * K, b += n * q, C += n * z, A += n * G, w += n * Y, T += n * W, x += n * X, I += n * Q, B += n * Z, d += (n = e[9]) * L, g += n * O, y += n * U, v += n * V, m += n * H, E += n * j, S += n * M, b += n * K, C += n * q, A += n * z, w += n * G, T += n * Y, x += n * W, I += n * X, B += n * Q, F += n * Z, g += (n = e[10]) * L, y += n * O, v += n * U, m += n * V, E += n * H, S += n * j, b += n * M, C += n * K, A += n * q, w += n * z, T += n * G, x += n * Y, I += n * W, B += n * X, F += n * Q, R += n * Z, y += (n = e[11]) * L, v += n * O, m += n * U, E += n * V, S += n * H, b += n * j, C += n * M, A += n * K, w += n * q, T += n * z, x += n * G, I += n * Y, B += n * W, F += n * X, R += n * Q, D += n * Z, v += (n = e[12]) * L, m += n * O, E += n * U, S += n * V, b += n * H, C += n * j, A += n * M, w += n * K, T += n * q, x += n * z, I += n * G, B += n * Y, F += n * W, R += n * X, D += n * Q, N += n * Z, m += (n = e[13]) * L, E += n * O, S += n * U, b += n * V, C += n * H, A += n * j, w += n * M, T += n * K, x += n * q, I += n * z, B += n * G, F += n * Y, R += n * W, D += n * X, N += n * Q, _ += n * Z, E += (n = e[14]) * L, S += n * O, b += n * U, C += n * V, A += n * H, w += n * j, T += n * M, x += n * K, I += n * q, B += n * z, F += n * G, R += n * Y, D += n * W, N += n * X, _ += n * Q, P += n * Z, S += (n = e[15]) * L, a += 38 * (C += n * U), o += 38 * (A += n * V), u += 38 * (w += n * H), c += 38 * (T += n * j), h += 38 * (x += n * M), l += 38 * (I += n * K), f += 38 * (B += n * q), p += 38 * (F += n * z), d += 38 * (R += n * G), g += 38 * (D += n * Y), y += 38 * (N += n * W), v += 38 * (_ += n * X), m += 38 * (P += n * Q), E += 38 * (k += n * Z), s = (n = (s += 38 * (b += n * O)) + (i = 1) + 65535) - 65536 * (i = Math.floor(n / 65536)), a = (n = a + i + 65535) - 65536 * (i = Math.floor(n / 65536)), o = (n = o + i + 65535) - 65536 * (i = Math.floor(n / 65536)), u = (n = u + i + 65535) - 65536 * (i = Math.floor(n / 65536)), c = (n = c + i + 65535) - 65536 * (i = Math.floor(n / 65536)), h = (n = h + i + 65535) - 65536 * (i = Math.floor(n / 65536)), l = (n = l + i + 65535) - 65536 * (i = Math.floor(n / 65536)), f = (n = f + i + 65535) - 65536 * (i = Math.floor(n / 65536)), p = (n = p + i + 65535) - 65536 * (i = Math.floor(n / 65536)), d = (n = d + i + 65535) - 65536 * (i = Math.floor(n / 65536)), g = (n = g + i + 65535) - 65536 * (i = Math.floor(n / 65536)), y = (n = y + i + 65535) - 65536 * (i = Math.floor(n / 65536)), v = (n = v + i + 65535) - 65536 * (i = Math.floor(n / 65536)), m = (n = m + i + 65535) - 65536 * (i = Math.floor(n / 65536)), E = (n = E + i + 65535) - 65536 * (i = Math.floor(n / 65536)), S = (n = S + i + 65535) - 65536 * (i = Math.floor(n / 65536)), s = (n = (s += i - 1 + 37 * (i - 1)) + (i = 1) + 65535) - 65536 * (i = Math.floor(n / 65536)), a = (n = a + i + 65535) - 65536 * (i = Math.floor(n / 65536)), o = (n = o + i + 65535) - 65536 * (i = Math.floor(n / 65536)), u = (n = u + i + 65535) - 65536 * (i = Math.floor(n / 65536)), c = (n = c + i + 65535) - 65536 * (i = Math.floor(n / 65536)), h = (n = h + i + 65535) - 65536 * (i = Math.floor(n / 65536)), l = (n = l + i + 65535) - 65536 * (i = Math.floor(n / 65536)), f = (n = f + i + 65535) - 65536 * (i = Math.floor(n / 65536)), p = (n = p + i + 65535) - 65536 * (i = Math.floor(n / 65536)), d = (n = d + i + 65535) - 65536 * (i = Math.floor(n / 65536)), g = (n = g + i + 65535) - 65536 * (i = Math.floor(n / 65536)), y = (n = y + i + 65535) - 65536 * (i = Math.floor(n / 65536)), v = (n = v + i + 65535) - 65536 * (i = Math.floor(n / 65536)), m = (n = m + i + 65535) - 65536 * (i = Math.floor(n / 65536)), E = (n = E + i + 65535) - 65536 * (i = Math.floor(n / 65536)), S = (n = S + i + 65535) - 65536 * (i = Math.floor(n / 65536)), s += i - 1 + 37 * (i - 1), t[0] = s, t[1] = a, t[2] = o, t[3] = u, t[4] = c, t[5] = h, t[6] = l, t[7] = f, t[8] = p, t[9] = d, t[10] = g, t[11] = y, t[12] = v, t[13] = m, t[14] = E, t[15] = S
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(3);
                    var i = n.asn1;
                    e.privateKeyValidator = {
                        name: "PrivateKeyInfo",
                        tagClass: i.Class.UNIVERSAL,
                        type: i.Type.SEQUENCE,
                        constructed: !0,
                        value: [{
                            name: "PrivateKeyInfo.version",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.INTEGER,
                            constructed: !1,
                            capture: "privateKeyVersion"
                        }, {
                            name: "PrivateKeyInfo.privateKeyAlgorithm",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "AlgorithmIdentifier.algorithm",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.OID,
                                constructed: !1,
                                capture: "privateKeyOid"
                            }]
                        }, {
                            name: "PrivateKeyInfo",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.OCTETSTRING,
                            constructed: !1,
                            capture: "privateKey"
                        }]
                    }, e.publicKeyValidator = {
                        name: "SubjectPublicKeyInfo",
                        tagClass: i.Class.UNIVERSAL,
                        type: i.Type.SEQUENCE,
                        constructed: !0,
                        captureAsn1: "subjectPublicKeyInfo",
                        value: [{
                            name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.SEQUENCE,
                            constructed: !0,
                            value: [{
                                name: "AlgorithmIdentifier.algorithm",
                                tagClass: i.Class.UNIVERSAL,
                                type: i.Type.OID,
                                constructed: !1,
                                capture: "publicKeyOid"
                            }]
                        }, {
                            tagClass: i.Class.UNIVERSAL,
                            type: i.Type.BITSTRING,
                            constructed: !1,
                            composed: !0,
                            captureBitStringValue: "ed25519PublicKey"
                        }]
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(1), r(2), r(12), t.exports = n.kem = n.kem || {};
                    var i = n.jsbn.BigInteger;

                    function s(t, e, r, i) {
                        t.generate = function(t, s) {
                            for (var a = new n.util.ByteBuffer, o = Math.ceil(s / i) + r, u = new n.util.ByteBuffer, c = r; c < o; ++c) {
                                u.putInt32(c), e.start(), e.update(t + u.getBytes());
                                var h = e.digest();
                                a.putBytes(h.getBytes(i))
                            }
                            return a.truncate(a.length() - s), a.getBytes()
                        }
                    }
                    n.kem.rsa = {}, n.kem.rsa.create = function(t, e) {
                        var r = (e = e || {}).prng || n.random,
                            s = {
                                encrypt: function(e, s) {
                                    var a, o = Math.ceil(e.n.bitLength() / 8);
                                    do {
                                        a = new i(n.util.bytesToHex(r.getBytesSync(o)), 16).mod(e.n)
                                    } while (a.compareTo(i.ONE) <= 0);
                                    var u = o - (a = n.util.hexToBytes(a.toString(16))).length;
                                    return u > 0 && (a = n.util.fillString(String.fromCharCode(0), u) + a), {
                                        encapsulation: e.encrypt(a, "NONE"),
                                        key: t.generate(a, s)
                                    }
                                },
                                decrypt: function(e, r, n) {
                                    var i = e.decrypt(r, "NONE");
                                    return t.generate(i, n)
                                }
                            };
                        return s
                    }, n.kem.kdf1 = function(t, e) {
                        s(this, t, 0, e || t.digestLength)
                    }, n.kem.kdf2 = function(t, e) {
                        s(this, t, 1, e || t.digestLength)
                    }
                }, function(t, e, r) {
                    t.exports = r(4), r(14), r(9), r(23), r(32)
                }, function(t, e, r) {
                    var n = r(0);
                    r(5), r(3), r(10), r(6), r(7), r(29), r(2), r(1), r(17);
                    var i = n.asn1,
                        s = t.exports = n.pkcs7 = n.pkcs7 || {};

                    function a(t) {
                        var e = {},
                            r = [];
                        if (!i.validate(t, s.asn1.recipientInfoValidator, e, r)) {
                            var a = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
                            throw a.errors = r, a
                        }
                        return {
                            version: e.version.charCodeAt(0),
                            issuer: n.pki.RDNAttributesAsArray(e.issuer),
                            serialNumber: n.util.createBuffer(e.serial).toHex(),
                            encryptedContent: {
                                algorithm: i.derToOid(e.encAlgorithm),
                                parameter: e.encParameter.value,
                                content: e.encKey
                            }
                        }
                    }

                    function o(t) {
                        for (var e, r = [], s = 0; s < t.length; ++s) r.push((e = t[s], i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, i.integerToDer(e.version).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [n.pki.distinguishedNameToAsn1({
                            attributes: e.issuer
                        }), i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, n.util.hexToBytes(e.serialNumber))]), i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(e.encryptedContent.algorithm).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.NULL, !1, "")]), i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, e.encryptedContent.content)])));
                        return r
                    }

                    function u(t) {
                        var e = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, i.integerToDer(t.version).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [n.pki.distinguishedNameToAsn1({
                            attributes: t.issuer
                        }), i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, n.util.hexToBytes(t.serialNumber))]), i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(t.digestAlgorithm).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.NULL, !1, "")])]);
                        if (t.authenticatedAttributesAsn1 && e.value.push(t.authenticatedAttributesAsn1), e.value.push(i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(t.signatureAlgorithm).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.NULL, !1, "")])), e.value.push(i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, t.signature)), t.unauthenticatedAttributes.length > 0) {
                            for (var r = i.create(i.Class.CONTEXT_SPECIFIC, 1, !0, []), s = 0; s < t.unauthenticatedAttributes.length; ++s) {
                                var a = t.unauthenticatedAttributes[s];
                                r.values.push(c(a))
                            }
                            e.value.push(r)
                        }
                        return e
                    }

                    function c(t) {
                        var e;
                        if (t.type === n.pki.oids.contentType) e = i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(t.value).getBytes());
                        else if (t.type === n.pki.oids.messageDigest) e = i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, t.value.bytes());
                        else if (t.type === n.pki.oids.signingTime) {
                            var r = new Date("1950-01-01T00:00:00Z"),
                                s = new Date("2050-01-01T00:00:00Z"),
                                a = t.value;
                            if ("string" == typeof a) {
                                var o = Date.parse(a);
                                a = isNaN(o) ? 13 === a.length ? i.utcTimeToDate(a) : i.generalizedTimeToDate(a) : new Date(o)
                            }
                            e = a >= r && a < s ? i.create(i.Class.UNIVERSAL, i.Type.UTCTIME, !1, i.dateToUtcTime(a)) : i.create(i.Class.UNIVERSAL, i.Type.GENERALIZEDTIME, !1, i.dateToGeneralizedTime(a))
                        }
                        return i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(t.type).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.SET, !0, [e])])
                    }

                    function l(t, e, r) {
                        var s = {};
                        if (!i.validate(e, r, s, [])) {
                            var a = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
                            throw a.errors = a, a
                        }
                        if (i.derToOid(s.contentType) !== n.pki.oids.data) throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
                        if (s.encryptedContent) {
                            var o = "";
                            if (n.util.isArray(s.encryptedContent))
                                for (var u = 0; u < s.encryptedContent.length; ++u) {
                                    if (s.encryptedContent[u].type !== i.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
                                    o += s.encryptedContent[u].value
                                } else o = s.encryptedContent;
                            t.encryptedContent = {
                                algorithm: i.derToOid(s.encAlgorithm),
                                parameter: n.util.createBuffer(s.encParameter.value),
                                content: n.util.createBuffer(o)
                            }
                        }
                        if (s.content) {
                            if (o = "", n.util.isArray(s.content))
                                for (u = 0; u < s.content.length; ++u) {
                                    if (s.content[u].type !== i.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
                                    o += s.content[u].value
                                } else o = s.content;
                            t.content = n.util.createBuffer(o)
                        }
                        return t.version = s.version.charCodeAt(0), t.rawCapture = s, s
                    }

                    function f(t) {
                        if (void 0 === t.encryptedContent.key) throw new Error("Symmetric key not available.");
                        if (void 0 === t.content) {
                            var e;
                            switch (t.encryptedContent.algorithm) {
                                case n.pki.oids["aes128-CBC"]:
                                case n.pki.oids["aes192-CBC"]:
                                case n.pki.oids["aes256-CBC"]:
                                    e = n.aes.createDecryptionCipher(t.encryptedContent.key);
                                    break;
                                case n.pki.oids.desCBC:
                                case n.pki.oids["des-EDE3-CBC"]:
                                    e = n.des.createDecryptionCipher(t.encryptedContent.key);
                                    break;
                                default:
                                    throw new Error("Unsupported symmetric cipher, OID " + t.encryptedContent.algorithm)
                            }
                            if (e.start(t.encryptedContent.parameter), e.update(t.encryptedContent.content), !e.finish()) throw new Error("Symmetric decryption failed.");
                            t.content = e.output
                        }
                    }
                    s.messageFromPem = function(t) {
                        var e = n.pem.decode(t)[0];
                        if ("PKCS7" !== e.type) {
                            var r = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
                            throw r.headerType = e.type, r
                        }
                        if (e.procType && "ENCRYPTED" === e.procType.type) throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
                        var a = i.fromDer(e.body);
                        return s.messageFromAsn1(a)
                    }, s.messageToPem = function(t, e) {
                        var r = {
                            type: "PKCS7",
                            body: i.toDer(t.toAsn1()).getBytes()
                        };
                        return n.pem.encode(r, {
                            maxline: e
                        })
                    }, s.messageFromAsn1 = function(t) {
                        var e = {},
                            r = [];
                        if (!i.validate(t, s.asn1.contentInfoValidator, e, r)) {
                            var a = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
                            throw a.errors = r, a
                        }
                        var o, u = i.derToOid(e.contentType);
                        switch (u) {
                            case n.pki.oids.envelopedData:
                                o = s.createEnvelopedData();
                                break;
                            case n.pki.oids.encryptedData:
                                o = s.createEncryptedData();
                                break;
                            case n.pki.oids.signedData:
                                o = s.createSignedData();
                                break;
                            default:
                                throw new Error("Cannot read PKCS#7 message. ContentType with OID " + u + " is not (yet) supported.")
                        }
                        return o.fromAsn1(e.content.value[0]), o
                    }, s.createSignedData = function() {
                        var t = null;
                        return t = {
                            type: n.pki.oids.signedData,
                            version: 1,
                            certificates: [],
                            crls: [],
                            signers: [],
                            digestAlgorithmIdentifiers: [],
                            contentInfo: null,
                            signerInfos: [],
                            fromAsn1: function(e) {
                                if (l(t, e, s.asn1.signedDataValidator), t.certificates = [], t.crls = [], t.digestAlgorithmIdentifiers = [], t.contentInfo = null, t.signerInfos = [], t.rawCapture.certificates)
                                    for (var r = t.rawCapture.certificates.value, i = 0; i < r.length; ++i) t.certificates.push(n.pki.certificateFromAsn1(r[i]))
                            },
                            toAsn1: function() {
                                t.contentInfo || t.sign();
                                for (var e = [], r = 0; r < t.certificates.length; ++r) e.push(n.pki.certificateToAsn1(t.certificates[r]));
                                var s = [],
                                    a = i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, i.integerToDer(t.version).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.SET, !0, t.digestAlgorithmIdentifiers), t.contentInfo])]);
                                return e.length > 0 && a.value[0].value.push(i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, e)), s.length > 0 && a.value[0].value.push(i.create(i.Class.CONTEXT_SPECIFIC, 1, !0, s)), a.value[0].value.push(i.create(i.Class.UNIVERSAL, i.Type.SET, !0, t.signerInfos)), i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(t.type).getBytes()), a])
                            },
                            addSigner: function(e) {
                                var r = e.issuer,
                                    i = e.serialNumber;
                                if (e.certificate) {
                                    var s = e.certificate;
                                    "string" == typeof s && (s = n.pki.certificateFromPem(s)), r = s.issuer.attributes, i = s.serialNumber
                                }
                                var a = e.key;
                                if (!a) throw new Error("Could not add PKCS#7 signer; no private key specified.");
                                "string" == typeof a && (a = n.pki.privateKeyFromPem(a));
                                var o = e.digestAlgorithm || n.pki.oids.sha1;
                                switch (o) {
                                    case n.pki.oids.sha1:
                                    case n.pki.oids.sha256:
                                    case n.pki.oids.sha384:
                                    case n.pki.oids.sha512:
                                    case n.pki.oids.md5:
                                        break;
                                    default:
                                        throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + o)
                                }
                                var u = e.authenticatedAttributes || [];
                                if (u.length > 0) {
                                    for (var c = !1, h = !1, l = 0; l < u.length; ++l) {
                                        var f = u[l];
                                        if (c || f.type !== n.pki.oids.contentType) {
                                            if (h || f.type !== n.pki.oids.messageDigest);
                                            else if (h = !0, c) break
                                        } else if (c = !0, h) break
                                    }
                                    if (!c || !h) throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.")
                                }
                                t.signers.push({
                                    key: a,
                                    version: 1,
                                    issuer: r,
                                    serialNumber: i,
                                    digestAlgorithm: o,
                                    signatureAlgorithm: n.pki.oids.rsaEncryption,
                                    signature: null,
                                    authenticatedAttributes: u,
                                    unauthenticatedAttributes: []
                                })
                            },
                            sign: function(e) {
                                var r;
                                e = e || {}, ("object" !== h(t.content) || null === t.contentInfo) && (t.contentInfo = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(n.pki.oids.data).getBytes())]), "content" in t && (t.content instanceof n.util.ByteBuffer ? r = t.content.bytes() : "string" == typeof t.content && (r = n.util.encodeUtf8(t.content)), e.detached ? t.detachedContent = i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, r) : t.contentInfo.value.push(i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, r)])))), 0 !== t.signers.length && function(e) {
                                    var r;
                                    if (!(r = t.detachedContent ? t.detachedContent : (r = t.contentInfo.value[1]).value[0])) throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
                                    var s = i.derToOid(t.contentInfo.value[0].value),
                                        a = i.toDer(r);
                                    for (var o in a.getByte(), i.getBerValueLength(a), a = a.getBytes(), e) e[o].start().update(a);
                                    for (var h = new Date, l = 0; l < t.signers.length; ++l) {
                                        var f = t.signers[l];
                                        if (0 === f.authenticatedAttributes.length) {
                                            if (s !== n.pki.oids.data) throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.")
                                        } else {
                                            f.authenticatedAttributesAsn1 = i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, []);
                                            for (var p = i.create(i.Class.UNIVERSAL, i.Type.SET, !0, []), d = 0; d < f.authenticatedAttributes.length; ++d) {
                                                var g = f.authenticatedAttributes[d];
                                                g.type === n.pki.oids.messageDigest ? g.value = e[f.digestAlgorithm].digest() : g.type === n.pki.oids.signingTime && (g.value || (g.value = h)), p.value.push(c(g)), f.authenticatedAttributesAsn1.value.push(c(g))
                                            }
                                            a = i.toDer(p).getBytes(), f.md.start().update(a)
                                        }
                                        f.signature = f.key.sign(f.md, "RSASSA-PKCS1-V1_5");
                                        var y = n.util.bytesToHex(f.signature);
                                        console.log(y)
                                    }
                                    t.signerInfos = function(t) {
                                        for (var e = [], r = 0; r < t.length; ++r) e.push(u(t[r]));
                                        return e
                                    }(t.signers)
                                }(function() {
                                    for (var e = {}, r = 0; r < t.signers.length; ++r) {
                                        var s = t.signers[r];
                                        (a = s.digestAlgorithm) in e || (e[a] = n.md[n.pki.oids[a]].create()), 0 === s.authenticatedAttributes.length ? s.md = e[a] : s.md = n.md[n.pki.oids[a]].create()
                                    }
                                    for (var a in t.digestAlgorithmIdentifiers = [], e) t.digestAlgorithmIdentifiers.push(i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(a).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.NULL, !1, "")]));
                                    return e
                                }())
                            },
                            verify: function() {
                                throw new Error("PKCS#7 signature verification not yet implemented.")
                            },
                            addCertificate: function(e) {
                                "string" == typeof e && (e = n.pki.certificateFromPem(e), console.log(e)), t.certificates.push(e)
                            },
                            addCertificateRevokationList: function(t) {
                                throw new Error("PKCS#7 CRL support not yet implemented.")
                            }
                        }
                    }, s.createEncryptedData = function() {
                        var t = null;
                        return t = {
                            type: n.pki.oids.encryptedData,
                            version: 0,
                            encryptedContent: {
                                algorithm: n.pki.oids["aes256-CBC"]
                            },
                            fromAsn1: function(e) {
                                l(t, e, s.asn1.encryptedDataValidator)
                            },
                            decrypt: function(e) {
                                void 0 !== e && (t.encryptedContent.key = e), f(t)
                            }
                        }
                    }, s.createEnvelopedData = function() {
                        var t = null;
                        return t = {
                            type: n.pki.oids.envelopedData,
                            version: 0,
                            recipients: [],
                            encryptedContent: {
                                algorithm: n.pki.oids["aes256-CBC"]
                            },
                            fromAsn1: function(e) {
                                var r = l(t, e, s.asn1.envelopedDataValidator);
                                t.recipients = function(t) {
                                    for (var e = [], r = 0; r < t.length; ++r) e.push(a(t[r]));
                                    return e
                                }(r.recipientInfos.value)
                            },
                            toAsn1: function() {
                                return i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(t.type).getBytes()), i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, i.integerToDer(t.version).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.SET, !0, o(t.recipients)), i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, (e = t.encryptedContent, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(n.pki.oids.data).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(e.algorithm).getBytes()), i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, e.parameter.getBytes())]), i.create(i.Class.CONTEXT_SPECIFIC, 0, !0, [i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, e.content.getBytes())])]))])])]);
                                var e
                            },
                            findRecipient: function(e) {
                                for (var r = e.issuer.attributes, n = 0; n < t.recipients.length; ++n) {
                                    var i = t.recipients[n],
                                        s = i.issuer;
                                    if (i.serialNumber === e.serialNumber && s.length === r.length) {
                                        for (var a = !0, o = 0; o < r.length; ++o)
                                            if (s[o].type !== r[o].type || s[o].value !== r[o].value) {
                                                a = !1;
                                                break
                                            }
                                        if (a) return i
                                    }
                                }
                                return null
                            },
                            decrypt: function(e, r) {
                                if (void 0 === t.encryptedContent.key && void 0 !== e && void 0 !== r) switch (e.encryptedContent.algorithm) {
                                    case n.pki.oids.rsaEncryption:
                                    case n.pki.oids.desCBC:
                                        var i = r.decrypt(e.encryptedContent.content);
                                        t.encryptedContent.key = n.util.createBuffer(i);
                                        break;
                                    default:
                                        throw new Error("Unsupported asymmetric cipher, OID " + e.encryptedContent.algorithm)
                                }
                                f(t)
                            },
                            addRecipient: function(e) {
                                t.recipients.push({
                                    version: 0,
                                    issuer: e.issuer.attributes,
                                    serialNumber: e.serialNumber,
                                    encryptedContent: {
                                        algorithm: n.pki.oids.rsaEncryption,
                                        key: e.publicKey
                                    }
                                })
                            },
                            encrypt: function(e, r) {
                                if (void 0 === t.encryptedContent.content) {
                                    var i, s, a;
                                    switch (r = r || t.encryptedContent.algorithm, e = e || t.encryptedContent.key, r) {
                                        case n.pki.oids["aes128-CBC"]:
                                            i = 16, s = 16, a = n.aes.createEncryptionCipher;
                                            break;
                                        case n.pki.oids["aes192-CBC"]:
                                            i = 24, s = 16, a = n.aes.createEncryptionCipher;
                                            break;
                                        case n.pki.oids["aes256-CBC"]:
                                            i = 32, s = 16, a = n.aes.createEncryptionCipher;
                                            break;
                                        case n.pki.oids["des-EDE3-CBC"]:
                                            i = 24, s = 8, a = n.des.createEncryptionCipher;
                                            break;
                                        default:
                                            throw new Error("Unsupported symmetric cipher, OID " + r)
                                    }
                                    if (void 0 === e) e = n.util.createBuffer(n.random.getBytes(i));
                                    else if (e.length() != i) throw new Error("Symmetric key has wrong length; got " + e.length() + " bytes, expected " + i + ".");
                                    t.encryptedContent.algorithm = r, t.encryptedContent.key = e, t.encryptedContent.parameter = n.util.createBuffer(n.random.getBytes(s));
                                    var o = a(e);
                                    if (o.start(t.encryptedContent.parameter.copy()), o.update(t.content), !o.finish()) throw new Error("Symmetric encryption failed.");
                                    t.encryptedContent.content = o.output
                                }
                                for (var u = 0; u < t.recipients.length; ++u) {
                                    var c = t.recipients[u];
                                    if (void 0 === c.encryptedContent.content) switch (c.encryptedContent.algorithm) {
                                        case n.pki.oids.rsaEncryption:
                                            c.encryptedContent.content = c.encryptedContent.key.encrypt(t.encryptedContent.key.data);
                                            break;
                                        default:
                                            throw new Error("Unsupported asymmetric cipher, OID " + c.encryptedContent.algorithm)
                                    }
                                }
                            }
                        }
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(5), r(8), r(14), r(9), r(1);
                    var i = t.exports = n.ssh = n.ssh || {};

                    function s(t, e) {
                        var r = e.toString(16);
                        r[0] >= "8" && (r = "00" + r);
                        var i = n.util.hexToBytes(r);
                        t.putInt32(i.length), t.putBytes(i)
                    }

                    function a(t, e) {
                        t.putInt32(e.length), t.putString(e)
                    }

                    function o() {
                        for (var t = n.md.sha1.create(), e = arguments.length, r = 0; r < e; ++r) t.update(arguments[r]);
                        return t.digest()
                    }
                    i.privateKeyToPutty = function(t, e, r) {
                        var i = "" === (e = e || "") ? "none" : "aes256-cbc",
                            u = "PuTTY-User-Key-File-2: ssh-rsa\r\n";
                        u += "Encryption: " + i + "\r\n", u += "Comment: " + (r = r || "") + "\r\n";
                        var c = n.util.createBuffer();
                        a(c, "ssh-rsa"), s(c, t.e), s(c, t.n);
                        var h = n.util.encode64(c.bytes(), 64),
                            l = Math.floor(h.length / 66) + 1;
                        u += "Public-Lines: " + l + "\r\n", u += h;
                        var f, p = n.util.createBuffer();
                        if (s(p, t.d), s(p, t.p), s(p, t.q), s(p, t.qInv), e) {
                            var d = p.length() + 16 - 1;
                            d -= d % 16;
                            var g = o(p.bytes());
                            g.truncate(g.length() - d + p.length()), p.putBuffer(g);
                            var y = n.util.createBuffer();
                            y.putBuffer(o("\0\0\0\0", e)), y.putBuffer(o("\0\0\0", e));
                            var v = n.aes.createEncryptionCipher(y.truncate(8), "CBC");
                            v.start(n.util.createBuffer().fillWithByte(0, 16)), v.update(p.copy()), v.finish();
                            var m = v.output;
                            m.truncate(16), f = n.util.encode64(m.bytes(), 64)
                        } else f = n.util.encode64(p.bytes(), 64);
                        u += "\r\nPrivate-Lines: " + (l = Math.floor(f.length / 66) + 1) + "\r\n", u += f;
                        var E = o("putty-private-key-file-mac-key", e),
                            S = n.util.createBuffer();
                        a(S, "ssh-rsa"), a(S, i), a(S, r), S.putInt32(c.length()), S.putBuffer(c), S.putInt32(p.length()), S.putBuffer(p);
                        var b = n.hmac.create();
                        return b.start("sha1", E), b.update(S.bytes()), u += "\r\nPrivate-MAC: " + b.digest().toHex() + "\r\n"
                    }, i.publicKeyToOpenSSH = function(t, e) {
                        e = e || "";
                        var r = n.util.createBuffer();
                        return a(r, "ssh-rsa"), s(r, t.e), s(r, t.n), "ssh-rsa " + n.util.encode64(r.bytes()) + " " + e
                    }, i.privateKeyToOpenSSH = function(t, e) {
                        return e ? n.pki.encryptRsaPrivateKey(t, e, {
                            legacy: !0,
                            algorithm: "aes128"
                        }) : n.pki.privateKeyToPem(t)
                    }, i.getPublicKeyFingerprint = function(t, e) {
                        var r = (e = e || {}).md || n.md.md5.create(),
                            i = n.util.createBuffer();
                        a(i, "ssh-rsa"), s(i, t.e), s(i, t.n), r.start(), r.update(i.getBytes());
                        var o = r.digest();
                        if ("hex" === e.encoding) {
                            var u = o.toHex();
                            return e.delimiter ? u.match(/.{2}/g).join(e.delimiter) : u
                        }
                        if ("binary" === e.encoding) return o.getBytes();
                        if (e.encoding) throw new Error('Unknown encoding "' + e.encoding + '".');
                        return o
                    }
                }, function(t, e, r) {
                    var n = r(0);
                    r(31), r(33), r(1);
                    var i = "forge.task",
                        s = {},
                        a = 0;
                    n.debug.set(i, "tasks", s);
                    var o = {};
                    n.debug.set(i, "queues", o);
                    var u = "ready",
                        c = "running",
                        h = "blocked",
                        l = "sleeping",
                        f = "done",
                        p = "error",
                        d = "stop",
                        g = "start",
                        y = {
                            ready: {}
                        };
                    y[u][d] = u, y[u][g] = c, y[u].cancel = f, y[u].fail = p, y[c] = {}, y[c][d] = u, y[c][g] = c, y[c].block = h, y[c].unblock = c, y[c].sleep = l, y[c].wakeup = c, y[c].cancel = f, y[c].fail = p, y[h] = {}, y[h][d] = h, y[h][g] = h, y[h].block = h, y[h].unblock = h, y[h].sleep = h, y[h].wakeup = h, y[h].cancel = f, y[h].fail = p, y[l] = {}, y[l][d] = l, y[l][g] = l, y[l].block = l, y[l].unblock = l, y[l].sleep = l, y[l].wakeup = l, y[l].cancel = f, y[l].fail = p, y[f] = {}, y[f][d] = f, y[f][g] = f, y[f].block = f, y[f].unblock = f, y[f].sleep = f, y[f].wakeup = f, y[f].cancel = f, y[f].fail = p, y[p] = {}, y[p][d] = p, y[p][g] = p, y[p].block = p, y[p].unblock = p, y[p].sleep = p, y[p].wakeup = p, y[p].cancel = p, y[p].fail = p;
                    var v = function(t) {
                        this.id = -1, this.name = t.name || "?", this.parent = t.parent || null, this.run = t.run, this.subtasks = [], this.error = !1, this.state = u, this.blocks = 0, this.timeoutId = null, this.swapTime = null, this.userData = null, this.id = a++, s[this.id] = this
                    };
                    v.prototype.debug = function(t) {
                        t = t || "", n.log.debug(i, t, "[%s][%s] task:", this.id, this.name, this, "subtasks:", this.subtasks.length, "queue:", o)
                    }, v.prototype.next = function(t, e) {
                        "function" == typeof t && (e = t, t = this.name);
                        var r = new v({
                            run: e,
                            name: t,
                            parent: this
                        });
                        return r.state = c, r.type = this.type, r.successCallback = this.successCallback || null, r.failureCallback = this.failureCallback || null, this.subtasks.push(r), this
                    }, v.prototype.parallel = function(t, e) {
                        return n.util.isArray(t) && (e = t, t = this.name), this.next(t, (function(r) {
                            var i = r;
                            i.block(e.length);
                            for (var s = function(t, r) {
                                    n.task.start({
                                        type: t,
                                        run: function(t) {
                                            e[r](t)
                                        },
                                        success: function(t) {
                                            i.unblock()
                                        },
                                        failure: function(t) {
                                            i.unblock()
                                        }
                                    })
                                }, a = 0; a < e.length; a++) s(t + "__parallel-" + r.id + "-" + a, a)
                        }))
                    }, v.prototype.stop = function() {
                        this.state = y[this.state][d]
                    }, v.prototype.start = function() {
                        this.error = !1, this.state = y[this.state][g], this.state === c && (this.start = new Date, this.run(this), m(this, 0))
                    }, v.prototype.block = function(t) {
                        t = void 0 === t ? 1 : t, this.blocks += t, this.blocks > 0 && (this.state = y[this.state].block)
                    }, v.prototype.unblock = function(t) {
                        return t = void 0 === t ? 1 : t, this.blocks -= t, 0 === this.blocks && this.state !== f && (this.state = c, m(this, 0)), this.blocks
                    }, v.prototype.sleep = function(t) {
                        t = void 0 === t ? 0 : t, this.state = y[this.state].sleep;
                        var e = this;
                        this.timeoutId = setTimeout((function() {
                            e.timeoutId = null, e.state = c, m(e, 0)
                        }), t)
                    }, v.prototype.wait = function(t) {
                        t.wait(this)
                    }, v.prototype.wakeup = function() {
                        this.state === l && (cancelTimeout(this.timeoutId), this.timeoutId = null, this.state = c, m(this, 0))
                    }, v.prototype.cancel = function() {
                        this.state = y[this.state].cancel, this.permitsNeeded = 0, null !== this.timeoutId && (cancelTimeout(this.timeoutId), this.timeoutId = null), this.subtasks = []
                    }, v.prototype.fail = function(t) {
                        if (this.error = !0, E(this, !0), t) t.error = this.error, t.swapTime = this.swapTime, t.userData = this.userData, m(t, 0);
                        else {
                            if (null !== this.parent) {
                                for (var e = this.parent; null !== e.parent;) e.error = this.error, e.swapTime = this.swapTime, e.userData = this.userData, e = e.parent;
                                E(e, !0)
                            }
                            this.failureCallback && this.failureCallback(this)
                        }
                    };
                    var m = function t(e, r) {
                            var n = r > 30 || +new Date - e.swapTime > 20,
                                i = function(r) {
                                    if (r++, e.state === c)
                                        if (n && (e.swapTime = +new Date), e.subtasks.length > 0) {
                                            var i = e.subtasks.shift();
                                            i.error = e.error, i.swapTime = e.swapTime, i.userData = e.userData, i.run(i), i.error || t(i, r)
                                        } else E(e), e.error || null !== e.parent && (e.parent.error = e.error, e.parent.swapTime = e.swapTime, e.parent.userData = e.userData, t(e.parent, r))
                                };
                            n ? setTimeout(i, 0) : i(r)
                        },
                        E = function(t, e) {
                            t.state = f, delete s[t.id], null === t.parent && (t.type in o ? 0 === o[t.type].length ? n.log.error(i, "[%s][%s] task queue empty [%s]", t.id, t.name, t.type) : o[t.type][0] !== t ? n.log.error(i, "[%s][%s] task not first in queue [%s]", t.id, t.name, t.type) : (o[t.type].shift(), 0 === o[t.type].length ? delete o[t.type] : o[t.type][0].start()) : n.log.error(i, "[%s][%s] task queue missing [%s]", t.id, t.name, t.type), e || (t.error && t.failureCallback ? t.failureCallback(t) : !t.error && t.successCallback && t.successCallback(t)))
                        };
                    t.exports = n.task = n.task || {}, n.task.start = function(t) {
                        var e = new v({
                            run: t.run,
                            name: t.name || "?"
                        });
                        e.type = t.type, e.successCallback = t.success || null, e.failureCallback = t.failure || null, e.type in o ? o[t.type].push(e) : (o[e.type] = [e], function(t) {
                            t.error = !1, t.state = y[t.state][g], setTimeout((function() {
                                t.state === c && (t.swapTime = +new Date, t.run(t), m(t, 0))
                            }), 0)
                        }(e))
                    }, n.task.cancel = function(t) {
                        t in o && (o[t] = [o[t][0]])
                    }, n.task.createCondition = function() {
                        var t = {
                            tasks: {},
                            wait: function(e) {
                                e.id in t.tasks || (e.block(), t.tasks[e.id] = e)
                            },
                            notify: function() {
                                var e = t.tasks;
                                for (var r in t.tasks = {}, e) e[r].unblock()
                            }
                        };
                        return t
                    }
                }])
            }, "object" === h(e) && "object" === h(s) ? s.exports = c() : (o = [], void 0 === (u = "function" == typeof(a = c) ? a.apply(e, o) : a) || (s.exports = u))
        }).call(this, r(151), r(250).setImmediate, r(2).Buffer, r(255)(t))
    }, function(t, e, r) {
        var n = r(36);
        t.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(n)
    }, function(t, e, r) {
        "use strict";
        var n = r(34),
            i = r(10),
            s = r(1),
            a = r(89),
            o = r(3),
            u = r(11),
            c = r(9),
            h = r(26),
            l = r(33),
            f = r(17),
            p = r(27),
            d = r(140),
            g = r(43),
            y = r(261),
            v = r(93),
            m = r(7)("replace"),
            E = Math.max,
            S = Math.min,
            b = s([].concat),
            C = s([].push),
            A = s("".indexOf),
            w = s("".slice),
            T = "$0" === "a".replace(/./, "$0"),
            x = !!/./ [m] && "" === /./ [m]("a", "$0");
        a("replace", (function(t, e, r) {
            var s = x ? "$" : "$0";
            return [function(t, r) {
                var n = p(this),
                    s = null == t ? void 0 : g(t, m);
                return s ? i(s, t, n, r) : i(e, f(n), t, r)
            }, function(t, i) {
                var a = u(this),
                    o = f(t);
                if ("string" == typeof i && -1 === A(i, s) && -1 === A(i, "$<")) {
                    var p = r(e, a, o, i);
                    if (p.done) return p.value
                }
                var g = c(i);
                g || (i = f(i));
                var m = a.global;
                if (m) {
                    var T = a.unicode;
                    a.lastIndex = 0
                }
                for (var x = [];;) {
                    var I = v(a, o);
                    if (null === I) break;
                    if (C(x, I), !m) break;
                    "" === f(I[0]) && (a.lastIndex = d(o, l(a.lastIndex), T))
                }
                for (var B, F = "", R = 0, D = 0; D < x.length; D++) {
                    for (var N = f((I = x[D])[0]), _ = E(S(h(I.index), o.length), 0), P = [], k = 1; k < I.length; k++) C(P, void 0 === (B = I[k]) ? B : String(B));
                    var L = I.groups;
                    if (g) {
                        var O = b([N], P, _, o);
                        void 0 !== L && C(O, L);
                        var U = f(n(i, void 0, O))
                    } else U = y(N, o, _, P, L, i);
                    _ >= R && (F += w(o, R, _) + U, R = _ + N.length)
                }
                return F + w(o, R)
            }]
        }), !!o((function() {
            var t = /./;
            return t.exec = function() {
                var t = [];
                return t.groups = {
                    a: "7"
                }, t
            }, "7" !== "".replace(t, "$<a>")
        })) || !T || x)
    }, function(t, e, r) {
        var n = r(13),
            i = r(55).EXISTS,
            s = r(1),
            a = r(16).f,
            o = Function.prototype,
            u = s(o.toString),
            c = /^\s*function ([^ (]*)/,
            h = s(c.exec);
        n && !i && a(o, "name", {
            configurable: !0,
            get: function() {
                try {
                    return h(c, u(this))[1]
                } catch (t) {
                    return ""
                }
            }
        })
    }, function(t, e, r) {
        "use strict";
        var n = r(10),
            i = r(89),
            s = r(11),
            a = r(27),
            o = r(262),
            u = r(17),
            c = r(43),
            h = r(93);
        i("search", (function(t, e, r) {
            return [function(e) {
                var r = a(this),
                    i = null == e ? void 0 : c(e, t);
                return i ? n(i, e, r) : new RegExp(e)[t](u(r))
            }, function(t) {
                var n = s(this),
                    i = u(t),
                    a = r(e, n, i);
                if (a.done) return a.value;
                var c = n.lastIndex;
                o(c, 0) || (n.lastIndex = 0);
                var l = h(n, i);
                return o(n.lastIndex, c) || (n.lastIndex = c), null === l ? -1 : l.index
            }]
        }))
    }, function(t, e, r) {
        var n = r(1);
        t.exports = n(1..valueOf)
    }, function(t, e, r) {
        var n = r(3),
            i = r(7),
            s = r(54),
            a = i("iterator");
        t.exports = !n((function() {
            var t = new URL("b?a=1&b=2&c=3", "http://a"),
                e = t.searchParams,
                r = "";
            return t.pathname = "c%20d", e.forEach((function(t, n) {
                e.delete("b"), r += n + t
            })), s && !t.toJSON || !e.sort || "http://a/c%20d?a=1&c=3" !== t.href || "3" !== e.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !e[a] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://").host || "#%D0%B1" !== new URL("http://a#").hash || "a1c3" !== r || "x" !== new URL("http://x", void 0).host
        }))
    }, function(t, e, r) {
        "use strict";
        var n = r(0),
            i = r(39),
            s = r(10),
            a = r(15),
            o = r(269),
            u = r(145),
            c = r(91),
            h = r(20),
            l = r(128),
            f = r(100),
            p = r(75),
            d = n.Array;
        t.exports = function(t) {
            var e = a(t),
                r = c(this),
                n = arguments.length,
                g = n > 1 ? arguments[1] : void 0,
                y = void 0 !== g;
            y && (g = i(g, n > 2 ? arguments[2] : void 0));
            var v, m, E, S, b, C, A = p(e),
                w = 0;
            if (!A || this == d && u(A))
                for (v = h(e), m = r ? new this(v) : d(v); v > w; w++) C = y ? g(e[w], w) : e[w], l(m, w, C);
            else
                for (b = (S = f(e, A)).next, m = r ? new this : []; !(E = s(b, S)).done; w++) C = y ? o(S, g, [E.value, w], !0) : E.value, l(m, w, C);
            return m.length = w, m
        }
    }, function(t, e, r) {
        var n = r(10),
            i = r(11),
            s = r(43);
        t.exports = function(t, e, r) {
            var a, o;
            i(t);
            try {
                if (!(a = s(t, "return"))) {
                    if ("throw" === e) throw r;
                    return r
                }
                a = n(a, t)
            } catch (t) {
                o = !0, a = t
            }
            if ("throw" === e) throw r;
            if (o) throw a;
            return i(a), r
        }
    }, function(t, e, r) {
        "use strict";
        r(31);
        var n = r(5),
            i = r(0),
            s = r(28),
            a = r(10),
            o = r(1),
            u = r(190),
            c = r(19),
            h = r(143),
            l = r(47),
            f = r(167),
            p = r(25),
            d = r(74),
            g = r(9),
            y = r(12),
            v = r(39),
            m = r(46),
            E = r(11),
            S = r(14),
            b = r(17),
            C = r(37),
            A = r(40),
            w = r(100),
            T = r(75),
            x = r(7),
            I = r(148),
            B = x("iterator"),
            F = p.set,
            R = p.getterFor("URLSearchParams"),
            D = p.getterFor("URLSearchParamsIterator"),
            N = s("fetch"),
            _ = s("Request"),
            P = s("Headers"),
            k = _ && _.prototype,
            L = P && P.prototype,
            O = i.RegExp,
            U = i.TypeError,
            V = i.decodeURIComponent,
            H = i.encodeURIComponent,
            j = o("".charAt),
            M = o([].join),
            K = o([].push),
            q = o("".replace),
            z = o([].shift),
            G = o([].splice),
            Y = o("".split),
            W = o("".slice),
            X = /\+/g,
            Q = Array(4),
            Z = function(t) {
                return Q[t - 1] || (Q[t - 1] = O("((?:%[\\da-f]{2}){" + t + "})", "gi"))
            },
            J = function(t) {
                try {
                    return V(t)
                } catch (e) {
                    return t
                }
            },
            $ = function(t) {
                var e = q(t, X, " "),
                    r = 4;
                try {
                    return V(e)
                } catch (t) {
                    for (; r;) e = q(e, Z(r--), J);
                    return e
                }
            },
            tt = /[!'()~]|%20/g,
            et = {
                "!": "%21",
                "'": "%27",
                "(": "%28",
                ")": "%29",
                "~": "%7E",
                "%20": "+"
            },
            rt = function(t) {
                return et[t]
            },
            nt = function(t) {
                return q(H(t), tt, rt)
            },
            it = function(t, e) {
                if (e)
                    for (var r, n, i = Y(e, "&"), s = 0; s < i.length;)(r = i[s++]).length && (n = Y(r, "="), K(t, {
                        key: $(z(n)),
                        value: $(M(n, "="))
                    }))
            },
            st = function(t) {
                this.entries.length = 0, it(this.entries, t)
            },
            at = function(t, e) {
                if (t < e) throw U("Not enough arguments")
            },
            ot = f((function(t, e) {
                F(this, {
                    type: "URLSearchParamsIterator",
                    iterator: w(R(t).entries),
                    kind: e
                })
            }), "Iterator", (function() {
                var t = D(this),
                    e = t.kind,
                    r = t.iterator.next(),
                    n = r.value;
                return r.done || (r.value = "keys" === e ? n.key : "values" === e ? n.value : [n.key, n.value]), r
            })),
            ut = function() {
                d(this, ct);
                var t, e, r, n, i, s, o, u, c, h = arguments.length > 0 ? arguments[0] : void 0,
                    l = this,
                    f = [];
                if (F(l, {
                        type: "URLSearchParams",
                        entries: f,
                        updateURL: function() {},
                        updateSearchParams: st
                    }), void 0 !== h)
                    if (S(h))
                        if (t = T(h))
                            for (r = (e = w(h, t)).next; !(n = a(r, e)).done;) {
                                if (s = (i = w(E(n.value))).next, (o = a(s, i)).done || (u = a(s, i)).done || !a(s, i).done) throw U("Expected sequence with length 2");
                                K(f, {
                                    key: b(o.value),
                                    value: b(u.value)
                                })
                            } else
                                for (c in h) y(h, c) && K(f, {
                                    key: c,
                                    value: b(h[c])
                                });
                        else it(f, "string" == typeof h ? "?" === j(h, 0) ? W(h, 1) : h : b(h))
            },
            ct = ut.prototype;
        if (h(ct, {
                append: function(t, e) {
                    at(arguments.length, 2);
                    var r = R(this);
                    K(r.entries, {
                        key: b(t),
                        value: b(e)
                    }), r.updateURL()
                },
                delete: function(t) {
                    at(arguments.length, 1);
                    for (var e = R(this), r = e.entries, n = b(t), i = 0; i < r.length;) r[i].key === n ? G(r, i, 1) : i++;
                    e.updateURL()
                },
                get: function(t) {
                    at(arguments.length, 1);
                    for (var e = R(this).entries, r = b(t), n = 0; n < e.length; n++)
                        if (e[n].key === r) return e[n].value;
                    return null
                },
                getAll: function(t) {
                    at(arguments.length, 1);
                    for (var e = R(this).entries, r = b(t), n = [], i = 0; i < e.length; i++) e[i].key === r && K(n, e[i].value);
                    return n
                },
                has: function(t) {
                    at(arguments.length, 1);
                    for (var e = R(this).entries, r = b(t), n = 0; n < e.length;)
                        if (e[n++].key === r) return !0;
                    return !1
                },
                set: function(t, e) {
                    at(arguments.length, 1);
                    for (var r, n = R(this), i = n.entries, s = !1, a = b(t), o = b(e), u = 0; u < i.length; u++)(r = i[u]).key === a && (s ? G(i, u--, 1) : (s = !0, r.value = o));
                    s || K(i, {
                        key: a,
                        value: o
                    }), n.updateURL()
                },
                sort: function() {
                    var t = R(this);
                    I(t.entries, (function(t, e) {
                        return t.key > e.key ? 1 : -1
                    })), t.updateURL()
                },
                forEach: function(t) {
                    for (var e, r = R(this).entries, n = v(t, arguments.length > 1 ? arguments[1] : void 0), i = 0; i < r.length;) n((e = r[i++]).value, e.key, this)
                },
                keys: function() {
                    return new ot(this, "keys")
                },
                values: function() {
                    return new ot(this, "values")
                },
                entries: function() {
                    return new ot(this, "entries")
                }
            }, {
                enumerable: !0
            }), c(ct, B, ct.entries, {
                name: "entries"
            }), c(ct, "toString", (function() {
                for (var t, e = R(this).entries, r = [], n = 0; n < e.length;) t = e[n++], K(r, nt(t.key) + "=" + nt(t.value));
                return M(r, "&")
            }), {
                enumerable: !0
            }), l(ut, "URLSearchParams"), n({
                global: !0,
                forced: !u
            }, {
                URLSearchParams: ut
            }), !u && g(P)) {
            var ht = o(L.has),
                lt = o(L.set),
                ft = function(t) {
                    if (S(t)) {
                        var e, r = t.body;
                        if ("URLSearchParams" === m(r)) return e = t.headers ? new P(t.headers) : new P, ht(e, "content-type") || lt(e, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), C(t, {
                            body: A(0, b(r)),
                            headers: A(0, e)
                        })
                    }
                    return t
                };
            if (g(N) && n({
                    global: !0,
                    enumerable: !0,
                    forced: !0
                }, {
                    fetch: function(t) {
                        return N(t, arguments.length > 1 ? ft(arguments[1]) : {})
                    }
                }), g(_)) {
                var pt = function(t) {
                    return d(this, k), new _(t, arguments.length > 1 ? ft(arguments[1]) : {})
                };
                k.constructor = pt, pt.prototype = k, n({
                    global: !0,
                    forced: !0
                }, {
                    Request: pt
                })
            }
        }
        t.exports = {
            URLSearchParams: ut,
            getState: R
        }
    }, function(t, e, r) {
        var n = r(13),
            i = r(0),
            s = r(1),
            a = r(86),
            o = r(146),
            u = r(24),
            c = r(16).f,
            h = r(44).f,
            l = r(29),
            f = r(138),
            p = r(17),
            d = r(88),
            g = r(136),
            y = r(19),
            v = r(3),
            m = r(12),
            E = r(25).enforce,
            S = r(97),
            b = r(7),
            C = r(162),
            A = r(163),
            w = b("match"),
            T = i.RegExp,
            x = T.prototype,
            I = i.SyntaxError,
            B = s(d),
            F = s(x.exec),
            R = s("".charAt),
            D = s("".replace),
            N = s("".indexOf),
            _ = s("".slice),
            P = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/,
            k = /a/g,
            L = /a/g,
            O = new T(k) !== k,
            U = g.UNSUPPORTED_Y,
            V = n && (!O || U || C || A || v((function() {
                return L[w] = !1, T(k) != k || T(L) == L || "/a/i" != T(k, "i")
            })));
        if (a("RegExp", V)) {
            for (var H = function(t, e) {
                    var r, n, i, s, a, c, h = l(x, this),
                        d = f(t),
                        g = void 0 === e,
                        y = [],
                        v = t;
                    if (!h && d && g && t.constructor === H) return t;
                    if ((d || l(x, t)) && (t = t.source, g && (e = "flags" in v ? v.flags : B(v))), t = void 0 === t ? "" : p(t), e = void 0 === e ? "" : p(e), v = t, C && "dotAll" in k && (n = !!e && N(e, "s") > -1) && (e = D(e, /s/g, "")), r = e, U && "sticky" in k && (i = !!e && N(e, "y") > -1) && (e = D(e, /y/g, "")), A && (t = (s = function(t) {
                            for (var e, r = t.length, n = 0, i = "", s = [], a = {}, o = !1, u = !1, c = 0, h = ""; n <= r; n++) {
                                if ("\\" === (e = R(t, n))) e += R(t, ++n);
                                else if ("]" === e) o = !1;
                                else if (!o) switch (!0) {
                                    case "[" === e:
                                        o = !0;
                                        break;
                                    case "(" === e:
                                        F(P, _(t, n + 1)) && (n += 2, u = !0), i += e, c++;
                                        continue;
                                    case ">" === e && u:
                                        if ("" === h || m(a, h)) throw new I("Invalid capture group name");
                                        a[h] = !0, s[s.length] = [h, c], u = !1, h = "";
                                        continue
                                }
                                u ? h += e : i += e
                            }
                            return [i, s]
                        }(t))[0], y = s[1]), a = o(T(t, e), h ? this : x, H), (n || i || y.length) && (c = E(a), n && (c.dotAll = !0, c.raw = H(function(t) {
                            for (var e, r = t.length, n = 0, i = "", s = !1; n <= r; n++) "\\" !== (e = R(t, n)) ? s || "." !== e ? ("[" === e ? s = !0 : "]" === e && (s = !1), i += e) : i += "[\\s\\S]" : i += e + R(t, ++n);
                            return i
                        }(t), r)), i && (c.sticky = !0), y.length && (c.groups = y)), t !== v) try {
                        u(a, "source", "" === v ? "(?:)" : v)
                    } catch (t) {}
                    return a
                }, j = function(t) {
                    t in H || c(H, t, {
                        configurable: !0,
                        get: function() {
                            return T[t]
                        },
                        set: function(e) {
                            T[t] = e
                        }
                    })
                }, M = h(T), K = 0; M.length > K;) j(M[K++]);
            x.constructor = H, H.prototype = x, y(i, "RegExp", H)
        }
        S("RegExp")
    }, function(t, e, r) {
        "use strict";

        function n(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }
        var i = r(51).BigInteger,
            s = r(196),
            a = r(77),
            o = function() {
                function t() {
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.ct = 1, this.p2 = null, this.sm3keybase = null, this.sm3c3 = null, this.key = new Array(32), this.keyOff = 0
                }
                var e, r, o;
                return e = t, (r = [{
                    key: "reset",
                    value: function() {
                        this.sm3keybase = new s, this.sm3c3 = new s;
                        var t = a.hexToArray(this.p2.getX().toBigInteger().toRadix(16)),
                            e = a.hexToArray(this.p2.getY().toBigInteger().toRadix(16));
                        this.sm3keybase.blockUpdate(t, 0, t.length), this.sm3c3.blockUpdate(t, 0, t.length), this.sm3keybase.blockUpdate(e, 0, e.length), this.ct = 1, this.nextKey()
                    }
                }, {
                    key: "nextKey",
                    value: function() {
                        var t = new s(this.sm3keybase);
                        t.update(this.ct >> 24 & 255), t.update(this.ct >> 16 & 255), t.update(this.ct >> 8 & 255), t.update(255 & this.ct), t.doFinal(this.key, 0), this.keyOff = 0, this.ct++
                    }
                }, {
                    key: "initEncipher",
                    value: function(t) {
                        var e = a.generateKeyPairHex(),
                            r = new i(e.privateKey, 16),
                            n = e.publicKey;
                        return this.p2 = t.multiply(r), this.reset(), n.length > 128 && (n = n.substr(n.length - 128)), n
                    }
                }, {
                    key: "encryptBlock",
                    value: function(t) {
                        this.sm3c3.blockUpdate(t, 0, t.length);
                        for (var e = 0; e < t.length; e++) this.keyOff === this.key.length && this.nextKey(), t[e] ^= 255 & this.key[this.keyOff++]
                    }
                }, {
                    key: "initDecipher",
                    value: function(t, e) {
                        this.p2 = e.multiply(t), this.reset()
                    }
                }, {
                    key: "decryptBlock",
                    value: function(t) {
                        for (var e = 0; e < t.length; e++) this.keyOff === this.key.length && this.nextKey(), t[e] ^= 255 & this.key[this.keyOff++];
                        this.sm3c3.blockUpdate(t, 0, t.length)
                    }
                }, {
                    key: "doFinal",
                    value: function(t) {
                        var e = a.hexToArray(this.p2.getY().toBigInteger().toRadix(16));
                        this.sm3c3.blockUpdate(e, 0, e.length), this.sm3c3.doFinal(t, 0), this.reset()
                    }
                }, {
                    key: "createPoint",
                    value: function(t, e) {
                        var r = "04" + t + e;
                        return a.getGlobalCurve().decodePointHex(r)
                    }
                }]) && n(e.prototype, r), o && n(e, o), t
            }();
        t.exports = o
    }, function(t, e, r) {
        "use strict";

        function n(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function i(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }
        r(272), r(30), r(38), r(129), r(275);
        var s = r(51).BigInteger,
            a = r(77),
            o = function(t, e, r, n, i) {
                for (var s = 0; s < i; s++) r[n + s] = t[e + s]
            },
            u = {
                minValue: -2147483648,
                maxValue: 2147483647,
                parse: function(t) {
                    if (t < this.minValue) {
                        for (var e = Number(-t).toString(2), r = e.substr(e.length - 31, 31), n = "", i = 0; i < r.length; i++) {
                            n += "0" === r.substr(i, 1) ? "1" : "0"
                        }
                        return parseInt(n, 2) + 1
                    }
                    if (t > this.maxValue) {
                        for (var s = Number(t).toString(2), a = s.substr(s.length - 31, 31), o = "", u = 0; u < a.length; u++) {
                            o += "0" === a.substr(u, 1) ? "1" : "0"
                        }
                        return -(parseInt(o, 2) + 1)
                    }
                    return t
                },
                parseByte: function(t) {
                    if (t < 0) {
                        for (var e = Number(-t).toString(2), r = e.substr(e.length - 8, 8), n = "", i = 0; i < r.length; i++) {
                            n += "0" === r.substr(i, 1) ? "1" : "0"
                        }
                        return (parseInt(n, 2) + 1) % 256
                    }
                    if (t > 255) {
                        var s = Number(t).toString(2);
                        return parseInt(s.substr(s.length - 8, 8), 2)
                    }
                    return t
                }
            },
            c = function() {
                function t() {
                    n(this, t), this.xBuf = [], this.xBufOff = 0, this.byteCount = 0, this.DIGEST_LENGTH = 32, this.v0 = [1937774191, 1226093241, 388252375, 3666478592, 2842636476, 372324522, 3817729613, 2969243214], this.v0 = [1937774191, 1226093241, 388252375, -628488704, -1452330820, 372324522, -477237683, -1325724082], this.v = new Array(8), this.v_ = new Array(8), this.X0 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.X = new Array(68), this.xOff = 0, this.T_00_15 = 2043430169, this.T_16_63 = 2055708042, arguments.length > 0 ? this.initDigest(arguments.length <= 0 ? void 0 : arguments[0]) : this.init()
                }
                var e, r, c;
                return e = t, (r = [{
                    key: "init",
                    value: function() {
                        this.xBuf = new Array(4), this.reset()
                    }
                }, {
                    key: "initDigest",
                    value: function(t) {
                        this.xBuf = [].concat(t.xBuf), this.xBufOff = t.xBufOff, this.byteCount = t.byteCount, o(t.X, 0, this.X, 0, t.X.length), this.xOff = t.xOff, o(t.v, 0, this.v, 0, t.v.length)
                    }
                }, {
                    key: "getDigestSize",
                    value: function() {
                        return this.DIGEST_LENGTH
                    }
                }, {
                    key: "reset",
                    value: function() {
                        this.byteCount = 0, this.xBufOff = 0;
                        for (var t = Object.keys(this.xBuf), e = 0, r = t.length; e < r; e++) this.xBuf[t[e]] = null;
                        o(this.v0, 0, this.v, 0, this.v0.length), this.xOff = 0, o(this.X0, 0, this.X, 0, this.X0.length)
                    }
                }, {
                    key: "processBlock",
                    value: function() {
                        var t, e = this.X,
                            r = new Array(64);
                        for (t = 16; t < 68; t++) e[t] = this.p1(e[t - 16] ^ e[t - 9] ^ this.rotate(e[t - 3], 15)) ^ this.rotate(e[t - 13], 7) ^ e[t - 6];
                        for (t = 0; t < 64; t++) r[t] = e[t] ^ e[t + 4];
                        var n, i, s, a, c, h = this.v,
                            l = this.v_;
                        for (o(h, 0, l, 0, this.v0.length), t = 0; t < 16; t++) c = this.rotate(l[0], 12), n = u.parse(u.parse(c + l[4]) + this.rotate(this.T_00_15, t)), i = (n = this.rotate(n, 7)) ^ c, s = u.parse(u.parse(this.ff_00_15(l[0], l[1], l[2]) + l[3]) + i) + r[t], a = u.parse(u.parse(this.gg_00_15(l[4], l[5], l[6]) + l[7]) + n) + e[t], l[3] = l[2], l[2] = this.rotate(l[1], 9), l[1] = l[0], l[0] = s, l[7] = l[6], l[6] = this.rotate(l[5], 19), l[5] = l[4], l[4] = this.p0(a);
                        for (t = 16; t < 64; t++) c = this.rotate(l[0], 12), n = u.parse(u.parse(c + l[4]) + this.rotate(this.T_16_63, t)), i = (n = this.rotate(n, 7)) ^ c, s = u.parse(u.parse(this.ff_16_63(l[0], l[1], l[2]) + l[3]) + i) + r[t], a = u.parse(u.parse(this.gg_16_63(l[4], l[5], l[6]) + l[7]) + n) + e[t], l[3] = l[2], l[2] = this.rotate(l[1], 9), l[1] = l[0], l[0] = s, l[7] = l[6], l[6] = this.rotate(l[5], 19), l[5] = l[4], l[4] = this.p0(a);
                        for (t = 0; t < 8; t++) h[t] ^= u.parse(l[t]);
                        this.xOff = 0, o(this.X0, 0, this.X, 0, this.X0.length)
                    }
                }, {
                    key: "processWord",
                    value: function(t, e) {
                        var r = t[e] << 24;
                        r |= (255 & t[++e]) << 16, r |= (255 & t[++e]) << 8, r |= 255 & t[++e], this.X[this.xOff] = r, 16 == ++this.xOff && this.processBlock()
                    }
                }, {
                    key: "processLength",
                    value: function(t) {
                        this.xOff > 14 && this.processBlock(), this.X[14] = this.urShiftLong(t, 32), this.X[15] = 4294967295 & t
                    }
                }, {
                    key: "intToBigEndian",
                    value: function(t, e, r) {
                        e[r] = 255 & u.parseByte(this.urShift(t, 24)), e[++r] = 255 & u.parseByte(this.urShift(t, 16)), e[++r] = 255 & u.parseByte(this.urShift(t, 8)), e[++r] = 255 & u.parseByte(t)
                    }
                }, {
                    key: "doFinal",
                    value: function(t, e) {
                        this.finish();
                        for (var r = 0; r < 8; r++) this.intToBigEndian(this.v[r], t, e + 4 * r);
                        return this.reset(), this.DIGEST_LENGTH
                    }
                }, {
                    key: "update",
                    value: function(t) {
                        this.xBuf[this.xBufOff++] = t, this.xBufOff === this.xBuf.length && (this.processWord(this.xBuf, 0), this.xBufOff = 0), this.byteCount++
                    }
                }, {
                    key: "blockUpdate",
                    value: function(t, e, r) {
                        for (; 0 !== this.xBufOff && r > 0;) this.update(t[e]), e++, r--;
                        for (; r > this.xBuf.length;) this.processWord(t, e), e += this.xBuf.length, r -= this.xBuf.length, this.byteCount += this.xBuf.length;
                        for (; r > 0;) this.update(t[e]), e++, r--
                    }
                }, {
                    key: "finish",
                    value: function() {
                        var t = this.byteCount << 3;
                        for (this.update(128); 0 !== this.xBufOff;) this.update(0);
                        this.processLength(t), this.processBlock()
                    }
                }, {
                    key: "rotate",
                    value: function(t, e) {
                        return t << e | this.urShift(t, 32 - e)
                    }
                }, {
                    key: "p0",
                    value: function(t) {
                        return t ^ this.rotate(t, 9) ^ this.rotate(t, 17)
                    }
                }, {
                    key: "p1",
                    value: function(t) {
                        return t ^ this.rotate(t, 15) ^ this.rotate(t, 23)
                    }
                }, {
                    key: "ff_00_15",
                    value: function(t, e, r) {
                        return t ^ e ^ r
                    }
                }, {
                    key: "ff_16_63",
                    value: function(t, e, r) {
                        return t & e | t & r | e & r
                    }
                }, {
                    key: "gg_00_15",
                    value: function(t, e, r) {
                        return t ^ e ^ r
                    }
                }, {
                    key: "gg_16_63",
                    value: function(t, e, r) {
                        return t & e | ~t & r
                    }
                }, {
                    key: "urShift",
                    value: function(t, e) {
                        return (t > u.maxValue || t < u.minValue) && (t = u.parse(t)), t >= 0 ? t >> e : (t >> e) + (2 << ~e)
                    }
                }, {
                    key: "urShiftLong",
                    value: function(t, e) {
                        var r, n = new s;
                        if (n.fromInt(t), n.signum() >= 0) r = n.shiftRight(e).intValue();
                        else {
                            var i = new s;
                            i.fromInt(2);
                            var a = ~e,
                                o = "";
                            if (a < 0) {
                                for (var u = 64 + a, c = 0; c < u; c++) o += "0";
                                var h = new s;
                                h.fromInt(t >> e);
                                var l = new s("10" + o, 2);
                                o = l.toRadix(10), r = l.add(h).toRadix(10)
                            } else r = (t >> e) + (o = i.shiftLeft(~e).intValue())
                        }
                        return r
                    }
                }, {
                    key: "getZ",
                    value: function(t, e) {
                        var r = a.parseUtf8StringToHex("1234567812345678"),
                            n = 4 * r.length;
                        this.update(n >> 8 & 255), this.update(255 & n);
                        var i = a.hexToArray(r);
                        this.blockUpdate(i, 0, i.length);
                        var s = a.hexToArray(t.curve.a.toBigInteger().toRadix(16)),
                            o = a.hexToArray(t.curve.b.toBigInteger().toRadix(16)),
                            u = a.hexToArray(t.getX().toBigInteger().toRadix(16)),
                            c = a.hexToArray(t.getY().toBigInteger().toRadix(16)),
                            h = a.hexToArray(e.substr(0, 64)),
                            l = a.hexToArray(e.substr(64, 64));
                        this.blockUpdate(s, 0, s.length), this.blockUpdate(o, 0, o.length), this.blockUpdate(u, 0, u.length), this.blockUpdate(c, 0, c.length), this.blockUpdate(h, 0, h.length), this.blockUpdate(l, 0, l.length);
                        var f = new Array(this.getDigestSize());
                        return this.doFinal(f, 0), f
                    }
                }, {
                    key: "getNewZ",
                    value: function(t, e, r) {
                        var n = r,
                            i = 4 * n.length;
                        this.update(i >> 8 & 255), this.update(255 & i);
                        var s = a.hexToArray(n);
                        this.blockUpdate(s, 0, s.length);
                        var o = a.hexToArray(t.curve.a.toBigInteger().toRadix(16)),
                            u = a.hexToArray(t.curve.b.toBigInteger().toRadix(16)),
                            c = a.hexToArray(t.getX().toBigInteger().toRadix(16)),
                            h = a.hexToArray(t.getY().toBigInteger().toRadix(16)),
                            l = a.hexToArray(e.substr(0, 64)),
                            f = a.hexToArray(e.substr(64, 64));
                        this.blockUpdate(o, 0, o.length), this.blockUpdate(u, 0, u.length), this.blockUpdate(c, 0, c.length), this.blockUpdate(h, 0, h.length), this.blockUpdate(l, 0, l.length), this.blockUpdate(f, 0, f.length);
                        var p = new Array(this.getDigestSize());
                        return this.doFinal(p, 0), p
                    }
                }]) && i(e.prototype, r), c && i(e, c), t
            }();
        t.exports = c
    }, function(t, e, r) {
        "use strict";

        function n(t, e) {
            return t.length >= e ? t : new Array(e - t.length + 1).join("0") + t
        }

        function i(t) {
            for (var e = "", r = 0; r < t.length / 2; r++) e += n(parseInt(t.substr(2 * r, 2), 16).toString(2), 8);
            return e
        }

        function s(t, e) {
            return t.substring(e % t.length) + t.substr(0, e % t.length)
        }

        function a(t, e, r) {
            for (var n, i = t || "", s = e || "", a = [], o = i.length - 1; o >= 0; o--) n = r(i[o], s[o], n), a[o] = n[0];
            return a.join("")
        }

        function o(t, e) {
            return a(t, e, (function(t, e) {
                return [t === e ? "0" : "1"]
            }))
        }

        function u(t, e) {
            return a(t, e, (function(t, e) {
                return ["1" === t && "1" === e ? "1" : "0"]
            }))
        }

        function c(t, e) {
            return a(t, e, (function(t, e) {
                return ["1" === t || "1" === e ? "1" : "0"]
            }))
        }

        function h(t, e) {
            return a(t, e, (function(t, e, r) {
                var n = r ? r[1] : "0";
                return t !== e ? ["0" === n ? "1" : "0", n] : [n, t]
            }))
        }

        function l(t) {
            return function() {
                for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++) r[n] = arguments[n];
                return r.reduce((function(e, r) {
                    return t(e, r)
                }))
            }
        }

        function f(t) {
            return l(o)(t, s(t, 9), s(t, 17))
        }

        function p(t, e, r, n) {
            return n >= 0 && n <= 15 ? l(o)(t, e, r) : l(c)(u(t, e), u(t, r), u(e, r))
        }

        function d(t, e, r, n) {
            return n >= 0 && n <= 15 ? l(o)(t, e, r) : c(u(t, e), u(a(t, void 0, (function(t) {
                return ["1" === t ? "0" : "1"]
            })), r))
        }

        function g(t) {
            return i(t >= 0 && t <= 15 ? "79cc4519" : "7a879d8a")
        }

        function y(t, e) {
            for (var r, n = [], i = [], a = 0; a < 16; a++) n.push(e.substr(32 * a, 32));
            for (var u = 16; u < 68; u++) n.push(l(o)((r = l(o)(n[u - 16], n[u - 9], s(n[u - 3], 15)), l(o)(r, s(r, 15), s(r, 23))), s(n[u - 13], 7), n[u - 6]));
            for (var c = 0; c < 64; c++) i.push(o(n[c], n[c + 4]));
            for (var y = [], v = 0; v < 8; v++) y.push(t.substr(32 * v, 32));
            for (var m, E, S, b, C = y[0], A = y[1], w = y[2], T = y[3], x = y[4], I = y[5], B = y[6], F = y[7], R = 0; R < 64; R++) E = o(m = s(l(h)(s(C, 12), x, s(g(R), R)), 7), s(C, 12)), S = l(h)(p(C, A, w, R), T, E, i[R]), b = l(h)(d(x, I, B, R), F, m, n[R]), T = w, w = s(A, 9), A = C, C = S, F = B, B = s(I, 19), I = x, x = f(b);
            return o([C, A, w, T, x, I, B, F].join(""), t)
        }
        r(58), r(30), r(38), r(278), r(153), r(129), t.exports = function(t, e) {
            var r = "hex" == e ? i(t) : function(t) {
                    for (var e = "", r = 0, i = t.length; r < i; r++) {
                        e += n(t[r].codePointAt(0).toString(2), 8)
                    }
                    return e
                }(t),
                s = r.length,
                a = s % 512;
            a = a >= 448 ? 512 - a % 448 - 1 : 448 - a - 1;
            for (var o = "".concat(r, "1").concat(n("", a)).concat(n(s.toString(2), 64)).toString(), u = (s + a + 65) / 512, c = i("7380166f4914b2b9172442d7da8a0600a96f30bc163138aae38dee4db0fb0e4e"), h = 0; h <= u - 1; h++) {
                c = y(c, o.substr(512 * h, 512))
            }
            return function(t) {
                for (var e = "", r = 0; r < t.length / 8; r++) e += n(parseInt(t.substr(8 * r, 8), 2).toString(16), 2);
                return e
            }(c)
        }
    }, function(t, e, r) {
        "use strict";
        r.r(e), r.d(e, "SM2", (function() {
            return I
        })), r.d(e, "SM3", (function() {
            return S
        })), r.d(e, "SM4", (function() {
            return V
        }));
        var n = r(60),
            i = r.n(n),
            s = r(2),
            a = r(6),
            o = a.BigInteger.prototype.Barrett;

        function u(t, e) {
            this.x = e, this.q = t
        }

        function c(t, e, r, n) {
            this.curve = t, this.x = e, this.y = r, this.z = null == n ? a.BigInteger.ONE : n, this.zinv = null
        }

        function h(t, e, r) {
            this.q = t, this.a = this.fromBigInteger(e), this.b = this.fromBigInteger(r), this.infinity = new c(this, null, null), this.reducer = new o(this.q)
        }
        u.prototype.equals = function(t) {
            return t == this || this.q.equals(t.q) && this.x.equals(t.x)
        }, u.prototype.toBigInteger = function() {
            return this.x
        }, u.prototype.negate = function() {
            return new u(this.q, this.x.negate().mod(this.q))
        }, u.prototype.add = function(t) {
            return new u(this.q, this.x.add(t.toBigInteger()).mod(this.q))
        }, u.prototype.subtract = function(t) {
            return new u(this.q, this.x.subtract(t.toBigInteger()).mod(this.q))
        }, u.prototype.multiply = function(t) {
            return new u(this.q, this.x.multiply(t.toBigInteger()).mod(this.q))
        }, u.prototype.square = function() {
            return new u(this.q, this.x.square().mod(this.q))
        }, u.prototype.divide = function(t) {
            return new u(this.q, this.x.multiply(t.toBigInteger().modInverse(this.q)).mod(this.q))
        }, c.prototype.getX = function() {
            null == this.zinv && (this.zinv = this.z.modInverse(this.curve.q));
            var t = this.x.toBigInteger().multiply(this.zinv);
            return this.curve.reduce(t), this.curve.fromBigInteger(t)
        }, c.prototype.getY = function() {
            null == this.zinv && (this.zinv = this.z.modInverse(this.curve.q));
            var t = this.y.toBigInteger().multiply(this.zinv);
            return this.curve.reduce(t), this.curve.fromBigInteger(t)
        }, c.prototype.equals = function(t) {
            return t == this || (this.isInfinity() ? t.isInfinity() : t.isInfinity() ? this.isInfinity() : !!t.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(t.z)).mod(this.curve.q).equals(a.BigInteger.ZERO) && t.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(t.z)).mod(this.curve.q).equals(a.BigInteger.ZERO))
        }, c.prototype.isInfinity = function() {
            return null == this.x && null == this.y || this.z.equals(a.BigInteger.ZERO) && !this.y.toBigInteger().equals(a.BigInteger.ZERO)
        }, c.prototype.negate = function() {
            return new c(this.curve, this.x, this.y.negate(), this.z)
        }, c.prototype.add = function(t) {
            if (this.isInfinity()) return t;
            if (t.isInfinity()) return this;
            var e = t.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(t.z)).mod(this.curve.q),
                r = t.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(t.z)).mod(this.curve.q);
            if (a.BigInteger.ZERO.equals(r)) return a.BigInteger.ZERO.equals(e) ? this.twice() : this.curve.getInfinity();
            var n = new a.BigInteger("3"),
                i = this.x.toBigInteger(),
                s = this.y.toBigInteger(),
                o = (t.x.toBigInteger(), t.y.toBigInteger(), r.square()),
                u = o.multiply(r),
                h = i.multiply(o),
                l = e.square().multiply(this.z),
                f = l.subtract(h.shiftLeft(1)).multiply(t.z).subtract(u).multiply(r).mod(this.curve.q),
                p = h.multiply(n).multiply(e).subtract(s.multiply(u)).subtract(l.multiply(e)).multiply(t.z).add(e.multiply(u)).mod(this.curve.q),
                d = u.multiply(this.z).multiply(t.z).mod(this.curve.q);
            return new c(this.curve, this.curve.fromBigInteger(f), this.curve.fromBigInteger(p), d)
        }, c.prototype.twice = function() {
            if (this.isInfinity()) return this;
            if (0 == this.y.toBigInteger().signum()) return this.curve.getInfinity();
            var t = new a.BigInteger("3"),
                e = this.x.toBigInteger(),
                r = this.y.toBigInteger(),
                n = r.multiply(this.z),
                i = n.multiply(r).mod(this.curve.q),
                s = this.curve.a.toBigInteger(),
                o = e.square().multiply(t);
            a.BigInteger.ZERO.equals(s) || (o = o.add(this.z.square().multiply(s)));
            var u = (o = o.mod(this.curve.q)).square().subtract(e.shiftLeft(3).multiply(i)).shiftLeft(1).multiply(n).mod(this.curve.q),
                h = o.multiply(t).multiply(e).subtract(i.shiftLeft(1)).shiftLeft(2).multiply(i).subtract(o.square().multiply(o)).mod(this.curve.q),
                l = n.square().multiply(n).shiftLeft(3).mod(this.curve.q);
            return new c(this.curve, this.curve.fromBigInteger(u), this.curve.fromBigInteger(h), l)
        }, c.prototype.multiply = function(t) {
            if (this.isInfinity()) return this;
            if (0 == t.signum()) return this.curve.getInfinity();
            var e, r = t,
                n = r.multiply(new a.BigInteger("3")),
                i = this.negate(),
                s = this;
            for (e = n.bitLength() - 2; e > 0; --e) {
                s = s.twice();
                var o = n.testBit(e);
                o != r.testBit(e) && (s = s.add(o ? this : i))
            }
            return s
        }, c.prototype.multiplyTwo = function(t, e, r) {
            var n;
            n = t.bitLength() > r.bitLength() ? t.bitLength() - 1 : r.bitLength() - 1;
            for (var i = this.curve.getInfinity(), s = this.add(e); n >= 0;) i = i.twice(), t.testBit(n) ? i = r.testBit(n) ? i.add(s) : i.add(this) : r.testBit(n) && (i = i.add(e)), --n;
            return i
        }, h.prototype.getQ = function() {
            return this.q
        }, h.prototype.getA = function() {
            return this.a
        }, h.prototype.getB = function() {
            return this.b
        }, h.prototype.equals = function(t) {
            return t == this || this.q.equals(t.q) && this.a.equals(t.a) && this.b.equals(t.b)
        }, h.prototype.getInfinity = function() {
            return this.infinity
        }, h.prototype.fromBigInteger = function(t) {
            return new u(this.q, t)
        }, h.prototype.reduce = function(t) {
            this.reducer.reduce(t)
        }, h.prototype.decodePointHex = function(t) {
            switch (parseInt(t.substr(0, 2), 16)) {
                case 0:
                    return this.infinity;
                case 2:
                case 3:
                    return null;
                case 4:
                case 6:
                case 7:
                    var e = (t.length - 2) / 2,
                        r = t.substr(2, e),
                        n = t.substr(e + 2, e);
                    return new c(this, this.fromBigInteger(new a.BigInteger(r, 16)), this.fromBigInteger(new a.BigInteger(n, 16)));
                default:
                    return null
            }
        }, h.prototype.encodePointHex = function(t) {
            if (t.isInfinity()) return "00";
            var e = t.getX().toBigInteger().toString(16),
                r = t.getY().toBigInteger().toString(16),
                n = this.getQ().toString(16).length;
            for (n % 2 != 0 && n++; e.length < n;) e = "0" + e;
            for (; r.length < n;) r = "0" + r;
            return "04" + e + r
        };
        var l, f, p = function(t, e) {
                return t << (e %= 32) | t >>> 32 - e
            },
            d = function(t, e) {
                var r = e - t.length;
                return (r > 0 ? "0".repeat(r) : "") + t
            },
            g = function(t) {
                return t < 16 ? 2043430169 : 2055708042
            },
            y = function(t, e, r, n) {
                return n < 16 ? t ^ e ^ r : t & e | t & r | e & r
            },
            v = function(t, e, r, n) {
                return n < 16 ? t ^ e ^ r : t & e | ~t & r
            },
            m = function(t, e, r) {
                for (var n, i, s, a, o, u = function(t) {
                        var e, r = new Array(132);
                        t.forEach((function(t, e) {
                            r[e] = t
                        }));
                        for (var n = 16; n < 68; n++) r[n] = (e = r[n - 16] ^ r[n - 9] ^ p(r[n - 3], 15)) ^ p(e, 15) ^ p(e, 23) ^ p(r[n - 13], 7) ^ r[n - 6];
                        for (var i = 0; i < 64; i++) r[i + 68] = r[i] ^ r[i + 4];
                        return r
                    }(e), c = t[0], h = t[1], l = t[2], f = t[3], d = t[4], m = t[5], E = t[6], S = t[7], b = 0; b < 64; b++) i = (n = p(p(c, 12) + d + p(g(b), b), 7)) ^ p(c, 12), s = y(c, h, l, b) + f + i + u[b + 68], a = v(d, m, E, b) + S + n + u[b], f = l, l = p(h, 9), h = c, c = s, S = E, E = p(m, 19), m = d, d = (o = a) ^ p(o, 9) ^ p(o, 17);
                return [c ^ t[0], h ^ t[1], l ^ t[2], f ^ t[3], d ^ t[4], m ^ t[5], E ^ t[6], S ^ t[7]]
            },
            E = function(t, e, r) {
                if ("string" == typeof t ? t = s.Buffer.from(t, e || "utf8") : t instanceof ArrayBuffer && (t = s.Buffer.from(t)), !s.Buffer.isBuffer(t)) throw new TypeError('Expected "string" | "Buffer" | "ArrayBuffer" but received "' + Object.prototype.toString.call(t) + '"');
                var n, a, o, u, c, h;
                n = t, a = s.Buffer.alloc(1, 128), u = s.Buffer.alloc(o = (o = n.length % 64) >= 56 ? 64 - o % 56 - 1 : 56 - o - 1, 0), c = s.Buffer.alloc(8), h = 8 * n.length, c.writeUInt32BE(Math.floor(h / Math.pow(2, 32)), 0), c.writeUInt32BE(h % Math.pow(2, 32), 4);
                for (var l = (t = s.Buffer.concat([n, a, u, c], n.length + 1 + o + 8)).length / 64, f = new Array(l), p = 0; p < l; p++) {
                    f[p] = new Array(16);
                    for (var d = 0; d < 16; d++) f[p][d] = t.readUInt32BE(64 * p + 4 * d)
                }
                var g = new Array(l);
                g[0] = [1937774191, 1226093241, 388252375, 3666478592, 2842636476, 372324522, 3817729613, 2969243214];
                for (var y = 0; y < l; y++) g[y + 1] = m(g[y], f[y]);
                var v = s.Buffer.alloc(32);
                return g[l].forEach((function(t, e) {
                    return v.writeInt32BE(t, 4 * e)
                })), r ? v.toString(r) : i()(v)
            },
            S = {
                __proto__: null,
                digest: E
            },
            b = new a.SecureRandom,
            C = (l = new h(new a.BigInteger("FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF", 16), new a.BigInteger("FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC", 16), new a.BigInteger("28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93", 16)), f = l.decodePointHex("0432C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0"), {
                curve: l,
                G: f,
                n: new a.BigInteger("FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123", 16)
            }),
            A = C.curve,
            w = C.G,
            T = C.n;

        function x(t, e) {
            for (var r = [], n = Math.ceil(e / 32), i = e % 32, a = 1; a <= n; a++) {
                var o = s.Buffer.allocUnsafe(4);
                o.writeUInt32BE(a);
                var u = E(s.Buffer.concat([t, o]));
                r.push(a === n && i ? s.Buffer.from(u).slice(0, i) : s.Buffer.from(u))
            }
            return s.Buffer.concat(r, e)
        }
        var I = {
                __proto__: null,
                constants: {
                    C1C2C3: 0,
                    C1C3C2: 1,
                    PC: "04"
                },
                generateKeyPair: function() {
                    var t = new a.BigInteger(T.bitLength(), b).mod(T.subtract(new a.BigInteger("2"))).add(a.BigInteger.ONE),
                        e = d(t.toString(16), 64),
                        r = w.multiply(t);
                    return {
                        privateKey: e,
                        publicKey: "04" + d(r.getX().toBigInteger().toString(16), 64) + d(r.getY().toBigInteger().toString(16), 64)
                    }
                },
                encrypt: function(t, e, r) {
                    var n = r || {},
                        o = n.mode,
                        u = void 0 === o ? 1 : o,
                        c = n.outputEncoding,
                        h = n.pc;
                    if ("string" == typeof t ? t = s.Buffer.from(t, n.inputEncoding || "utf8") : t instanceof ArrayBuffer && (t = s.Buffer.from(t)), !s.Buffer.isBuffer(t)) throw new TypeError('Expected "string" | "Buffer" | "ArrayBuffer" but received "' + Object.prototype.toString.call(t) + '"');
                    var l = new a.BigInteger(T.bitLength(), b).mod(T.subtract(a.BigInteger.ONE)).add(a.BigInteger.ONE),
                        f = w.multiply(l),
                        p = d(f.getX().toBigInteger().toString(16), 64) + d(f.getY().toBigInteger().toString(16), 64),
                        g = A.decodePointHex(e).multiply(l),
                        y = d(g.getX().toBigInteger().toString(16), 64),
                        v = d(g.getY().toBigInteger().toString(16), 64),
                        m = x(s.Buffer.from(y + v, "hex"), t.length),
                        S = d(new a.BigInteger(t.toString("hex"), 16).xor(new a.BigInteger(m.toString("hex"), 16)).toString(16), 2 * t.length),
                        C = E(y + t.toString("hex") + v, "hex", "hex"),
                        I = s.Buffer.from((h ? "04" : "") + (0 === u ? p + S + C : p + C + S), "hex");
                    return c ? I.toString(c) : i()(I)
                },
                decrypt: function(t, e, r) {
                    var n = r || {},
                        o = n.mode,
                        u = void 0 === o ? 1 : o,
                        c = n.outputEncoding,
                        h = n.pc;
                    if ("string" == typeof t ? t = s.Buffer.from(t, n.inputEncoding) : t instanceof ArrayBuffer && (t = s.Buffer.from(t)), !s.Buffer.isBuffer(t)) throw new TypeError('Expected "string" | "Buffer" | "ArrayBuffer" but received "' + Object.prototype.toString.call(t) + '"');
                    var l = (t = h ? t.slice(1) : t).slice(0, 32).toString("hex"),
                        f = t.slice(32, 64).toString("hex"),
                        p = A.decodePointHex("04" + l + f).multiply(new a.BigInteger(e, 16)),
                        g = d(p.getX().toBigInteger().toString(16), 64),
                        y = d(p.getY().toBigInteger().toString(16), 64),
                        v = t.slice(64, 96),
                        m = t.slice(96);
                    0 === u && (v = t.slice(t.length - 32), m = t.slice(64, t.length - 32));
                    var S = x(s.Buffer.from(g + y, "hex"), m.length),
                        b = new a.BigInteger(m.toString("hex"), 16).xor(new a.BigInteger(S.toString("hex"), 16)).toString(16),
                        C = E(g + b + y, "hex", "hex") === v.toString("hex") ? s.Buffer.from(b, "hex") : s.Buffer.alloc(0);
                    return c ? C.toString(c) : i()(C)
                }
            },
            B = [
                [214, 144, 233, 254, 204, 225, 61, 183, 22, 182, 20, 194, 40, 251, 44, 5],
                [43, 103, 154, 118, 42, 190, 4, 195, 170, 68, 19, 38, 73, 134, 6, 153],
                [156, 66, 80, 244, 145, 239, 152, 122, 51, 84, 11, 67, 237, 207, 172, 98],
                [228, 179, 28, 169, 201, 8, 232, 149, 128, 223, 148, 250, 117, 143, 63, 166],
                [71, 7, 167, 252, 243, 115, 23, 186, 131, 89, 60, 25, 230, 133, 79, 168],
                [104, 107, 129, 178, 113, 100, 218, 139, 248, 235, 15, 75, 112, 86, 157, 53],
                [30, 36, 14, 94, 99, 88, 209, 162, 37, 34, 124, 59, 1, 33, 120, 135],
                [212, 0, 70, 87, 159, 211, 39, 82, 76, 54, 2, 231, 160, 196, 200, 158],
                [234, 191, 138, 210, 64, 199, 56, 181, 163, 247, 242, 206, 249, 97, 21, 161],
                [224, 174, 93, 164, 155, 52, 26, 85, 173, 147, 50, 48, 245, 140, 177, 227],
                [29, 246, 226, 46, 130, 102, 202, 96, 192, 41, 35, 171, 13, 83, 78, 111],
                [213, 219, 55, 69, 222, 253, 142, 47, 3, 255, 106, 114, 109, 108, 91, 81],
                [141, 27, 175, 146, 187, 221, 188, 127, 17, 217, 92, 65, 31, 16, 90, 216],
                [10, 193, 49, 136, 165, 205, 123, 189, 45, 116, 208, 18, 184, 229, 180, 176],
                [137, 105, 151, 74, 12, 150, 119, 126, 101, 185, 241, 9, 197, 110, 198, 132],
                [24, 240, 125, 236, 58, 220, 77, 32, 121, 238, 95, 62, 215, 203, 57, 72]
            ],
            F = [2746333894, 1453994832, 1736282519, 2993693404],
            R = [462357, 472066609, 943670861, 1415275113, 1886879365, 2358483617, 2830087869, 3301692121, 3773296373, 4228057617, 404694573, 876298825, 1347903077, 1819507329, 2291111581, 2762715833, 3234320085, 3705924337, 4177462797, 337322537, 808926789, 1280531041, 1752135293, 2223739545, 2695343797, 3166948049, 3638552301, 4110090761, 269950501, 741554753, 1213159005, 1684763257],
            D = /^[0-9a-f]{32}$/i,
            N = function(t) {
                return B[(4026531840 & t) >>> 28][(251658240 & t) >>> 24] << 24 | B[(15728640 & t) >>> 20][(983040 & t) >>> 16] << 16 | B[(61440 & t) >>> 12][(3840 & t) >>> 8] << 8 | B[(240 & t) >>> 4][(15 & t) >>> 0] << 0
            },
            _ = function(t) {
                return (e = N(t)) ^ p(e, 2) ^ p(e, 10) ^ p(e, 18) ^ p(e, 24);
                var e
            },
            P = function(t) {
                var e, r = new Array(36);
                r[0] = t[0] ^ F[0], r[1] = t[1] ^ F[1], r[2] = t[2] ^ F[2], r[3] = t[3] ^ F[3];
                for (var n = new Array(32), i = 0; i < 32; i++) r[i + 4] = r[i] ^ (e = N(r[i + 1] ^ r[i + 2] ^ r[i + 3] ^ R[i])) ^ p(e, 13) ^ p(e, 23), n[i] = r[i + 4];
                return n
            },
            k = function(t, e) {
                for (var r = P(e), n = 0; n < 32; n++) t[n + 4] = t[n] ^ _(t[n + 1] ^ t[n + 2] ^ t[n + 3] ^ r[n]);
                return [t[35], t[34], t[33], t[32]]
            },
            L = function(t, e) {
                for (var r = P(e).reverse(), n = 0; n < 32; n++) t[n + 4] = t[n] ^ _(t[n + 1] ^ t[n + 2] ^ t[n + 3] ^ r[n]);
                return [t[35], t[34], t[33], t[32]]
            },
            O = function(t) {
                return [t.readInt32BE(0), t.readInt32BE(4), t.readInt32BE(8), t.readInt32BE(12)]
            },
            U = function(t) {
                for (var e = s.Buffer.alloc(16), r = 0; r < 4; r++) e.writeInt32BE(t[r], 4 * r);
                return e
            },
            V = {
                __proto__: null,
                constants: {
                    ECB: 1,
                    CBC: 2
                },
                encrypt: function(t, e, r) {
                    var n = r || {},
                        a = n.mode,
                        o = n.iv,
                        u = n.outputEncoding;
                    if ("string" == typeof t ? t = s.Buffer.from(t, n.inputEncoding || "utf8") : t instanceof ArrayBuffer && (t = s.Buffer.from(t)), !s.Buffer.isBuffer(t)) throw new TypeError('Expected "string" | "Buffer" | "ArrayBuffer" but received "' + Object.prototype.toString.call(t) + '"');
                    if (!D.test(e)) throw new TypeError("Invalid value of cipher `key`");
                    if (e = s.Buffer.from(e, "hex"), 2 === a && !D.test(o)) throw new TypeError("Invalid value of `iv` option");
                    return function(t, e, r, n) {
                        r && (r = O(r)), e = O(e);
                        for (var a = [], o = (t = function(t) {
                                var e = 16 - t.length % 16,
                                    r = s.Buffer.alloc(e, e);
                                return s.Buffer.concat([t, r], t.length + e)
                            }(t)).length / 16, u = 0; u < o; u++)
                            if (r) {
                                var c = 16 * u,
                                    h = [r[0] ^ t.readInt32BE(c), r[1] ^ t.readInt32BE(c + 4), r[2] ^ t.readInt32BE(c + 8), r[3] ^ t.readInt32BE(c + 12)],
                                    l = k(h, e);
                                a.push(U(l)), r = l.slice(0)
                            } else {
                                var f = 16 * u,
                                    p = [t.readInt32BE(f), t.readInt32BE(f + 4), t.readInt32BE(f + 8), t.readInt32BE(f + 12)],
                                    d = k(p, e);
                                a.push(U(d))
                            }
                        var g = s.Buffer.concat(a, t.length);
                        return n ? g.toString(n) : i()(g)
                    }(t, e, o = 2 === a ? s.Buffer.from(o, "hex") : null, u)
                },
                decrypt: function(t, e, r) {
                    var n = r || {},
                        a = n.mode,
                        o = n.iv,
                        u = n.outputEncoding;
                    if ("string" == typeof t ? t = s.Buffer.from(t, n.inputEncoding) : t instanceof ArrayBuffer && (t = s.Buffer.from(t)), !s.Buffer.isBuffer(t)) throw new TypeError('Expected "string" | "Buffer" | "ArrayBuffer" but received "' + Object.prototype.toString.call(t) + '"');
                    if (!D.test(e)) throw new TypeError("Invalid value of cipher `key`");
                    if (e = s.Buffer.from(e, "hex"), 2 === a && !D.test(o)) throw new TypeError("Invalid value of `iv` option");
                    return function(t, e, r, n) {
                        r && (r = O(r)), e = O(e);
                        var a = [],
                            o = t.length / 16;
                        if (r)
                            for (var u = o - 1; u >= 0; u--) {
                                var c, h = 16 * u;
                                c = u > 0 ? [t.readInt32BE(h - 16), t.readInt32BE(h - 16 + 4), t.readInt32BE(h - 16 + 8), t.readInt32BE(h - 16 + 12)] : r;
                                var l = [t.readInt32BE(h), t.readInt32BE(h + 4), t.readInt32BE(h + 8), t.readInt32BE(h + 12)],
                                    f = L(l, e);
                                a.unshift(U([f[0] ^ c[0], f[1] ^ c[1], f[2] ^ c[2], f[3] ^ c[3]]))
                            } else
                                for (var p = 0; p < o; p++) {
                                    var d = 16 * p,
                                        g = [t.readInt32BE(d), t.readInt32BE(d + 4), t.readInt32BE(d + 8), t.readInt32BE(d + 12)],
                                        y = L(g, e);
                                    a.push(U(y))
                                }
                        var v = s.Buffer.concat(a, t.length - a[a.length - 1][15]);
                        return n ? v.toString(n) : i()(v)
                    }(t, e, o = 2 === a ? s.Buffer.from(o, "hex") : null, u)
                }
            }
    }, function(t, e, r) {
        "use strict";
        var n = r(32),
            i = function(t) {
                var e, r;
                this.promise = new t((function(t, n) {
                    if (void 0 !== e || void 0 !== r) throw TypeError("Bad Promise constructor");
                    e = t, r = n
                })), this.resolve = n(e), this.reject = n(r)
            };
        t.exports.f = function(t) {
            return new i(t)
        }
    }, function(t, e, r) {
        (function(t) {
            var r = {
                    userAgent: !1
                },
                n = {};
            /*!
            Copyright (c) 2011, Yahoo! Inc. All rights reserved.
            Code licensed under the BSD License:
            http://developer.yahoo.com/yui/license.html
            version: 2.9.0
            */
            if (void 0 === i) var i = {};
            i.lang = {
                extend: function(t, e, n) {
                    if (!e || !t) throw new Error("YAHOO.lang.extend failed, please check that all dependencies are included.");
                    var i = function() {};
                    if (i.prototype = e.prototype, t.prototype = new i, t.prototype.constructor = t, t.superclass = e.prototype, e.prototype.constructor == Object.prototype.constructor && (e.prototype.constructor = e), n) {
                        var s;
                        for (s in n) t.prototype[s] = n[s];
                        var a = function() {},
                            o = ["toString", "valueOf"];
                        try {
                            /MSIE/.test(r.userAgent) && (a = function(t, e) {
                                for (s = 0; s < o.length; s += 1) {
                                    var r = o[s],
                                        n = e[r];
                                    "function" == typeof n && n != Object.prototype[r] && (t[r] = n)
                                }
                            })
                        } catch (t) {}
                        a(t.prototype, n)
                    }
                }
            };
            /*! CryptoJS v3.1.2 core-fix.js
             * code.google.com/p/crypto-js
             * (c) 2009-2013 by Jeff Mott. All rights reserved.
             * code.google.com/p/crypto-js/wiki/License
             * THIS IS FIX of 'core.js' to fix Hmac issue.
             * https://code.google.com/p/crypto-js/issues/detail?id=84
             * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
             */
            var s, a, o, u, c, h, l, f, p, d, g, y = y || (s = Math, o = (a = {}).lib = {}, u = o.Base = function() {
                function t() {}
                return {
                    extend: function(e) {
                        t.prototype = this;
                        var r = new t;
                        return e && r.mixIn(e), r.hasOwnProperty("init") || (r.init = function() {
                            r.$super.init.apply(this, arguments)
                        }), r.init.prototype = r, r.$super = this, r
                    },
                    create: function() {
                        var t = this.extend();
                        return t.init.apply(t, arguments), t
                    },
                    init: function() {},
                    mixIn: function(t) {
                        for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]);
                        t.hasOwnProperty("toString") && (this.toString = t.toString)
                    },
                    clone: function() {
                        return this.init.prototype.extend(this)
                    }
                }
            }(), c = o.WordArray = u.extend({
                init: function(t, e) {
                    t = this.words = t || [], this.sigBytes = null != e ? e : 4 * t.length
                },
                toString: function(t) {
                    return (t || l).stringify(this)
                },
                concat: function(t) {
                    var e = this.words,
                        r = t.words,
                        n = this.sigBytes,
                        i = t.sigBytes;
                    if (this.clamp(), n % 4)
                        for (var s = 0; s < i; s++) {
                            var a = r[s >>> 2] >>> 24 - s % 4 * 8 & 255;
                            e[n + s >>> 2] |= a << 24 - (n + s) % 4 * 8
                        } else
                            for (s = 0; s < i; s += 4) e[n + s >>> 2] = r[s >>> 2];
                    return this.sigBytes += i, this
                },
                clamp: function() {
                    var t = this.words,
                        e = this.sigBytes;
                    t[e >>> 2] &= 4294967295 << 32 - e % 4 * 8, t.length = s.ceil(e / 4)
                },
                clone: function() {
                    var t = u.clone.call(this);
                    return t.words = this.words.slice(0), t
                },
                random: function(t) {
                    for (var e = [], r = 0; r < t; r += 4) e.push(4294967296 * s.random() | 0);
                    return new c.init(e, t)
                }
            }), h = a.enc = {}, l = h.Hex = {
                stringify: function(t) {
                    for (var e = t.words, r = t.sigBytes, n = [], i = 0; i < r; i++) {
                        var s = e[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        n.push((s >>> 4).toString(16)), n.push((15 & s).toString(16))
                    }
                    return n.join("")
                },
                parse: function(t) {
                    for (var e = t.length, r = [], n = 0; n < e; n += 2) r[n >>> 3] |= parseInt(t.substr(n, 2), 16) << 24 - n % 8 * 4;
                    return new c.init(r, e / 2)
                }
            }, f = h.Latin1 = {
                stringify: function(t) {
                    for (var e = t.words, r = t.sigBytes, n = [], i = 0; i < r; i++) {
                        var s = e[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        n.push(String.fromCharCode(s))
                    }
                    return n.join("")
                },
                parse: function(t) {
                    for (var e = t.length, r = [], n = 0; n < e; n++) r[n >>> 2] |= (255 & t.charCodeAt(n)) << 24 - n % 4 * 8;
                    return new c.init(r, e)
                }
            }, p = h.Utf8 = {
                stringify: function(t) {
                    try {
                        return decodeURIComponent(escape(f.stringify(t)))
                    } catch (t) {
                        throw new Error("Malformed UTF-8 data")
                    }
                },
                parse: function(t) {
                    return f.parse(unescape(encodeURIComponent(t)))
                }
            }, d = o.BufferedBlockAlgorithm = u.extend({
                reset: function() {
                    this._data = new c.init, this._nDataBytes = 0
                },
                _append: function(t) {
                    "string" == typeof t && (t = p.parse(t)), this._data.concat(t), this._nDataBytes += t.sigBytes
                },
                _process: function(t) {
                    var e = this._data,
                        r = e.words,
                        n = e.sigBytes,
                        i = this.blockSize,
                        a = n / (4 * i),
                        o = (a = t ? s.ceil(a) : s.max((0 | a) - this._minBufferSize, 0)) * i,
                        u = s.min(4 * o, n);
                    if (o) {
                        for (var h = 0; h < o; h += i) this._doProcessBlock(r, h);
                        var l = r.splice(0, o);
                        e.sigBytes -= u
                    }
                    return new c.init(l, u)
                },
                clone: function() {
                    var t = u.clone.call(this);
                    return t._data = this._data.clone(), t
                },
                _minBufferSize: 0
            }), o.Hasher = d.extend({
                cfg: u.extend(),
                init: function(t) {
                    this.cfg = this.cfg.extend(t), this.reset()
                },
                reset: function() {
                    d.reset.call(this), this._doReset()
                },
                update: function(t) {
                    return this._append(t), this._process(), this
                },
                finalize: function(t) {
                    return t && this._append(t), this._doFinalize()
                },
                blockSize: 16,
                _createHelper: function(t) {
                    return function(e, r) {
                        return new t.init(r).finalize(e)
                    }
                },
                _createHmacHelper: function(t) {
                    return function(e, r) {
                        return new g.HMAC.init(t, r).finalize(e)
                    }
                }
            }), g = a.algo = {}, a);
            ! function(t) {
                var e, r = (e = y).lib,
                    n = r.Base,
                    i = r.WordArray;
                (e = e.x64 = {}).Word = n.extend({
                    init: function(t, e) {
                        this.high = t, this.low = e
                    }
                }), e.WordArray = n.extend({
                    init: function(t, e) {
                        t = this.words = t || [], this.sigBytes = null != e ? e : 8 * t.length
                    },
                    toX32: function() {
                        for (var t = this.words, e = t.length, r = [], n = 0; n < e; n++) {
                            var s = t[n];
                            r.push(s.high), r.push(s.low)
                        }
                        return i.create(r, this.sigBytes)
                    },
                    clone: function() {
                        for (var t = n.clone.call(this), e = t.words = this.words.slice(0), r = e.length, i = 0; i < r; i++) e[i] = e[i].clone();
                        return t
                    }
                })
            }(), y.lib.Cipher || function(t) {
                    var e = (p = y).lib,
                        r = e.Base,
                        n = e.WordArray,
                        i = e.BufferedBlockAlgorithm,
                        s = p.enc.Base64,
                        a = p.algo.EvpKDF,
                        o = e.Cipher = i.extend({
                            cfg: r.extend(),
                            createEncryptor: function(t, e) {
                                return this.create(this._ENC_XFORM_MODE, t, e)
                            },
                            createDecryptor: function(t, e) {
                                return this.create(this._DEC_XFORM_MODE, t, e)
                            },
                            init: function(t, e, r) {
                                this.cfg = this.cfg.extend(r), this._xformMode = t, this._key = e, this.reset()
                            },
                            reset: function() {
                                i.reset.call(this), this._doReset()
                            },
                            process: function(t) {
                                return this._append(t), this._process()
                            },
                            finalize: function(t) {
                                return t && this._append(t), this._doFinalize()
                            },
                            keySize: 4,
                            ivSize: 4,
                            _ENC_XFORM_MODE: 1,
                            _DEC_XFORM_MODE: 2,
                            _createHelper: function(t) {
                                return {
                                    encrypt: function(e, r, n) {
                                        return ("string" == typeof r ? d : f).encrypt(t, e, r, n)
                                    },
                                    decrypt: function(e, r, n) {
                                        return ("string" == typeof r ? d : f).decrypt(t, e, r, n)
                                    }
                                }
                            }
                        });
                    e.StreamCipher = o.extend({
                        _doFinalize: function() {
                            return this._process(!0)
                        },
                        blockSize: 1
                    });
                    var u = p.mode = {},
                        c = function(t, e, r) {
                            var n = this._iv;
                            n ? this._iv = void 0 : n = this._prevBlock;
                            for (var i = 0; i < r; i++) t[e + i] ^= n[i]
                        },
                        h = (e.BlockCipherMode = r.extend({
                            createEncryptor: function(t, e) {
                                return this.Encryptor.create(t, e)
                            },
                            createDecryptor: function(t, e) {
                                return this.Decryptor.create(t, e)
                            },
                            init: function(t, e) {
                                this._cipher = t, this._iv = e
                            }
                        })).extend();
                    h.Encryptor = h.extend({
                        processBlock: function(t, e) {
                            var r = this._cipher,
                                n = r.blockSize;
                            c.call(this, t, e, n), r.encryptBlock(t, e), this._prevBlock = t.slice(e, e + n)
                        }
                    }), h.Decryptor = h.extend({
                        processBlock: function(t, e) {
                            var r = this._cipher,
                                n = r.blockSize,
                                i = t.slice(e, e + n);
                            r.decryptBlock(t, e), c.call(this, t, e, n), this._prevBlock = i
                        }
                    }), u = u.CBC = h, h = (p.pad = {}).Pkcs7 = {
                        pad: function(t, e) {
                            for (var r, i = (r = (r = 4 * e) - t.sigBytes % r) << 24 | r << 16 | r << 8 | r, s = [], a = 0; a < r; a += 4) s.push(i);
                            r = n.create(s, r), t.concat(r)
                        },
                        unpad: function(t) {
                            t.sigBytes -= 255 & t.words[t.sigBytes - 1 >>> 2]
                        }
                    }, e.BlockCipher = o.extend({
                        cfg: o.cfg.extend({
                            mode: u,
                            padding: h
                        }),
                        reset: function() {
                            o.reset.call(this);
                            var t = (e = this.cfg).iv,
                                e = e.mode;
                            if (this._xformMode == this._ENC_XFORM_MODE) var r = e.createEncryptor;
                            else r = e.createDecryptor, this._minBufferSize = 1;
                            this._mode = r.call(e, this, t && t.words)
                        },
                        _doProcessBlock: function(t, e) {
                            this._mode.processBlock(t, e)
                        },
                        _doFinalize: function() {
                            var t = this.cfg.padding;
                            if (this._xformMode == this._ENC_XFORM_MODE) {
                                t.pad(this._data, this.blockSize);
                                var e = this._process(!0)
                            } else e = this._process(!0), t.unpad(e);
                            return e
                        },
                        blockSize: 4
                    });
                    var l = e.CipherParams = r.extend({
                            init: function(t) {
                                this.mixIn(t)
                            },
                            toString: function(t) {
                                return (t || this.formatter).stringify(this)
                            }
                        }),
                        f = (u = (p.format = {}).OpenSSL = {
                            stringify: function(t) {
                                var e = t.ciphertext;
                                return ((t = t.salt) ? n.create([1398893684, 1701076831]).concat(t).concat(e) : e).toString(s)
                            },
                            parse: function(t) {
                                var e = (t = s.parse(t)).words;
                                if (1398893684 == e[0] && 1701076831 == e[1]) {
                                    var r = n.create(e.slice(2, 4));
                                    e.splice(0, 4), t.sigBytes -= 16
                                }
                                return l.create({
                                    ciphertext: t,
                                    salt: r
                                })
                            }
                        }, e.SerializableCipher = r.extend({
                            cfg: r.extend({
                                format: u
                            }),
                            encrypt: function(t, e, r, n) {
                                n = this.cfg.extend(n);
                                var i = t.createEncryptor(r, n);
                                return e = i.finalize(e), i = i.cfg, l.create({
                                    ciphertext: e,
                                    key: r,
                                    iv: i.iv,
                                    algorithm: t,
                                    mode: i.mode,
                                    padding: i.padding,
                                    blockSize: t.blockSize,
                                    formatter: n.format
                                })
                            },
                            decrypt: function(t, e, r, n) {
                                return n = this.cfg.extend(n), e = this._parse(e, n.format), t.createDecryptor(r, n).finalize(e.ciphertext)
                            },
                            _parse: function(t, e) {
                                return "string" == typeof t ? e.parse(t, this) : t
                            }
                        })),
                        p = (p.kdf = {}).OpenSSL = {
                            execute: function(t, e, r, i) {
                                return i || (i = n.random(8)), t = a.create({
                                    keySize: e + r
                                }).compute(t, i), r = n.create(t.words.slice(e), 4 * r), t.sigBytes = 4 * e, l.create({
                                    key: t,
                                    iv: r,
                                    salt: i
                                })
                            }
                        },
                        d = e.PasswordBasedCipher = f.extend({
                            cfg: f.cfg.extend({
                                kdf: p
                            }),
                            encrypt: function(t, e, r, n) {
                                return r = (n = this.cfg.extend(n)).kdf.execute(r, t.keySize, t.ivSize), n.iv = r.iv, (t = f.encrypt.call(this, t, e, r.key, n)).mixIn(r), t
                            },
                            decrypt: function(t, e, r, n) {
                                return n = this.cfg.extend(n), e = this._parse(e, n.format), r = n.kdf.execute(r, t.keySize, t.ivSize, e.salt), n.iv = r.iv, f.decrypt.call(this, t, e, r.key, n)
                            }
                        })
                }(),
                function() {
                    for (var t = y, e = t.lib.BlockCipher, r = t.algo, n = [], i = [], s = [], a = [], o = [], u = [], c = [], h = [], l = [], f = [], p = [], d = 0; 256 > d; d++) p[d] = 128 > d ? d << 1 : d << 1 ^ 283;
                    var g = 0,
                        v = 0;
                    for (d = 0; 256 > d; d++) {
                        var m = (m = v ^ v << 1 ^ v << 2 ^ v << 3 ^ v << 4) >>> 8 ^ 255 & m ^ 99;
                        n[g] = m, i[m] = g;
                        var E = p[g],
                            S = p[E],
                            b = p[S],
                            C = 257 * p[m] ^ 16843008 * m;
                        s[g] = C << 24 | C >>> 8, a[g] = C << 16 | C >>> 16, o[g] = C << 8 | C >>> 24, u[g] = C, C = 16843009 * b ^ 65537 * S ^ 257 * E ^ 16843008 * g, c[m] = C << 24 | C >>> 8, h[m] = C << 16 | C >>> 16, l[m] = C << 8 | C >>> 24, f[m] = C, g ? (g = E ^ p[p[p[b ^ E]]], v ^= p[p[v]]) : g = v = 1
                    }
                    var A = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
                    r = r.AES = e.extend({
                        _doReset: function() {
                            for (var t = (r = this._key).words, e = r.sigBytes / 4, r = 4 * ((this._nRounds = e + 6) + 1), i = this._keySchedule = [], s = 0; s < r; s++)
                                if (s < e) i[s] = t[s];
                                else {
                                    var a = i[s - 1];
                                    s % e ? 6 < e && 4 == s % e && (a = n[a >>> 24] << 24 | n[a >>> 16 & 255] << 16 | n[a >>> 8 & 255] << 8 | n[255 & a]) : (a = n[(a = a << 8 | a >>> 24) >>> 24] << 24 | n[a >>> 16 & 255] << 16 | n[a >>> 8 & 255] << 8 | n[255 & a], a ^= A[s / e | 0] << 24), i[s] = i[s - e] ^ a
                                }
                            for (t = this._invKeySchedule = [], e = 0; e < r; e++) s = r - e, a = e % 4 ? i[s] : i[s - 4], t[e] = 4 > e || 4 >= s ? a : c[n[a >>> 24]] ^ h[n[a >>> 16 & 255]] ^ l[n[a >>> 8 & 255]] ^ f[n[255 & a]]
                        },
                        encryptBlock: function(t, e) {
                            this._doCryptBlock(t, e, this._keySchedule, s, a, o, u, n)
                        },
                        decryptBlock: function(t, e) {
                            var r = t[e + 1];
                            t[e + 1] = t[e + 3], t[e + 3] = r, this._doCryptBlock(t, e, this._invKeySchedule, c, h, l, f, i), r = t[e + 1], t[e + 1] = t[e + 3], t[e + 3] = r
                        },
                        _doCryptBlock: function(t, e, r, n, i, s, a, o) {
                            for (var u = this._nRounds, c = t[e] ^ r[0], h = t[e + 1] ^ r[1], l = t[e + 2] ^ r[2], f = t[e + 3] ^ r[3], p = 4, d = 1; d < u; d++) {
                                var g = n[c >>> 24] ^ i[h >>> 16 & 255] ^ s[l >>> 8 & 255] ^ a[255 & f] ^ r[p++],
                                    y = n[h >>> 24] ^ i[l >>> 16 & 255] ^ s[f >>> 8 & 255] ^ a[255 & c] ^ r[p++],
                                    v = n[l >>> 24] ^ i[f >>> 16 & 255] ^ s[c >>> 8 & 255] ^ a[255 & h] ^ r[p++];
                                f = n[f >>> 24] ^ i[c >>> 16 & 255] ^ s[h >>> 8 & 255] ^ a[255 & l] ^ r[p++], c = g, h = y, l = v
                            }
                            g = (o[c >>> 24] << 24 | o[h >>> 16 & 255] << 16 | o[l >>> 8 & 255] << 8 | o[255 & f]) ^ r[p++], y = (o[h >>> 24] << 24 | o[l >>> 16 & 255] << 16 | o[f >>> 8 & 255] << 8 | o[255 & c]) ^ r[p++], v = (o[l >>> 24] << 24 | o[f >>> 16 & 255] << 16 | o[c >>> 8 & 255] << 8 | o[255 & h]) ^ r[p++], f = (o[f >>> 24] << 24 | o[c >>> 16 & 255] << 16 | o[h >>> 8 & 255] << 8 | o[255 & l]) ^ r[p++], t[e] = g, t[e + 1] = y, t[e + 2] = v, t[e + 3] = f
                        },
                        keySize: 8
                    });
                    t.AES = e._createHelper(r)
                }(),
                function() {
                    function t(t, e) {
                        var r = (this._lBlock >>> t ^ this._rBlock) & e;
                        this._rBlock ^= r, this._lBlock ^= r << t
                    }

                    function e(t, e) {
                        var r = (this._rBlock >>> t ^ this._lBlock) & e;
                        this._lBlock ^= r, this._rBlock ^= r << t
                    }
                    var r = y,
                        n = (i = r.lib).WordArray,
                        i = i.BlockCipher,
                        s = r.algo,
                        a = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4],
                        o = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32],
                        u = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
                        c = [{
                            0: 8421888,
                            268435456: 32768,
                            536870912: 8421378,
                            805306368: 2,
                            1073741824: 512,
                            1342177280: 8421890,
                            1610612736: 8389122,
                            1879048192: 8388608,
                            2147483648: 514,
                            2415919104: 8389120,
                            2684354560: 33280,
                            2952790016: 8421376,
                            3221225472: 32770,
                            3489660928: 8388610,
                            3758096384: 0,
                            4026531840: 33282,
                            134217728: 0,
                            402653184: 8421890,
                            671088640: 33282,
                            939524096: 32768,
                            1207959552: 8421888,
                            1476395008: 512,
                            1744830464: 8421378,
                            2013265920: 2,
                            2281701376: 8389120,
                            2550136832: 33280,
                            2818572288: 8421376,
                            3087007744: 8389122,
                            3355443200: 8388610,
                            3623878656: 32770,
                            3892314112: 514,
                            4160749568: 8388608,
                            1: 32768,
                            268435457: 2,
                            536870913: 8421888,
                            805306369: 8388608,
                            1073741825: 8421378,
                            1342177281: 33280,
                            1610612737: 512,
                            1879048193: 8389122,
                            2147483649: 8421890,
                            2415919105: 8421376,
                            2684354561: 8388610,
                            2952790017: 33282,
                            3221225473: 514,
                            3489660929: 8389120,
                            3758096385: 32770,
                            4026531841: 0,
                            134217729: 8421890,
                            402653185: 8421376,
                            671088641: 8388608,
                            939524097: 512,
                            1207959553: 32768,
                            1476395009: 8388610,
                            1744830465: 2,
                            2013265921: 33282,
                            2281701377: 32770,
                            2550136833: 8389122,
                            2818572289: 514,
                            3087007745: 8421888,
                            3355443201: 8389120,
                            3623878657: 0,
                            3892314113: 33280,
                            4160749569: 8421378
                        }, {
                            0: 1074282512,
                            16777216: 16384,
                            33554432: 524288,
                            50331648: 1074266128,
                            67108864: 1073741840,
                            83886080: 1074282496,
                            100663296: 1073758208,
                            117440512: 16,
                            134217728: 540672,
                            150994944: 1073758224,
                            167772160: 1073741824,
                            184549376: 540688,
                            201326592: 524304,
                            218103808: 0,
                            234881024: 16400,
                            251658240: 1074266112,
                            8388608: 1073758208,
                            25165824: 540688,
                            41943040: 16,
                            58720256: 1073758224,
                            75497472: 1074282512,
                            92274688: 1073741824,
                            109051904: 524288,
                            125829120: 1074266128,
                            142606336: 524304,
                            159383552: 0,
                            176160768: 16384,
                            192937984: 1074266112,
                            209715200: 1073741840,
                            226492416: 540672,
                            243269632: 1074282496,
                            260046848: 16400,
                            268435456: 0,
                            285212672: 1074266128,
                            301989888: 1073758224,
                            318767104: 1074282496,
                            335544320: 1074266112,
                            352321536: 16,
                            369098752: 540688,
                            385875968: 16384,
                            402653184: 16400,
                            419430400: 524288,
                            436207616: 524304,
                            452984832: 1073741840,
                            469762048: 540672,
                            486539264: 1073758208,
                            503316480: 1073741824,
                            520093696: 1074282512,
                            276824064: 540688,
                            293601280: 524288,
                            310378496: 1074266112,
                            327155712: 16384,
                            343932928: 1073758208,
                            360710144: 1074282512,
                            377487360: 16,
                            394264576: 1073741824,
                            411041792: 1074282496,
                            427819008: 1073741840,
                            444596224: 1073758224,
                            461373440: 524304,
                            478150656: 0,
                            494927872: 16400,
                            511705088: 1074266128,
                            528482304: 540672
                        }, {
                            0: 260,
                            1048576: 0,
                            2097152: 67109120,
                            3145728: 65796,
                            4194304: 65540,
                            5242880: 67108868,
                            6291456: 67174660,
                            7340032: 67174400,
                            8388608: 67108864,
                            9437184: 67174656,
                            10485760: 65792,
                            11534336: 67174404,
                            12582912: 67109124,
                            13631488: 65536,
                            14680064: 4,
                            15728640: 256,
                            524288: 67174656,
                            1572864: 67174404,
                            2621440: 0,
                            3670016: 67109120,
                            4718592: 67108868,
                            5767168: 65536,
                            6815744: 65540,
                            7864320: 260,
                            8912896: 4,
                            9961472: 256,
                            11010048: 67174400,
                            12058624: 65796,
                            13107200: 65792,
                            14155776: 67109124,
                            15204352: 67174660,
                            16252928: 67108864,
                            16777216: 67174656,
                            17825792: 65540,
                            18874368: 65536,
                            19922944: 67109120,
                            20971520: 256,
                            22020096: 67174660,
                            23068672: 67108868,
                            24117248: 0,
                            25165824: 67109124,
                            26214400: 67108864,
                            27262976: 4,
                            28311552: 65792,
                            29360128: 67174400,
                            30408704: 260,
                            31457280: 65796,
                            32505856: 67174404,
                            17301504: 67108864,
                            18350080: 260,
                            19398656: 67174656,
                            20447232: 0,
                            21495808: 65540,
                            22544384: 67109120,
                            23592960: 256,
                            24641536: 67174404,
                            25690112: 65536,
                            26738688: 67174660,
                            27787264: 65796,
                            28835840: 67108868,
                            29884416: 67109124,
                            30932992: 67174400,
                            31981568: 4,
                            33030144: 65792
                        }, {
                            0: 2151682048,
                            65536: 2147487808,
                            131072: 4198464,
                            196608: 2151677952,
                            262144: 0,
                            327680: 4198400,
                            393216: 2147483712,
                            458752: 4194368,
                            524288: 2147483648,
                            589824: 4194304,
                            655360: 64,
                            720896: 2147487744,
                            786432: 2151678016,
                            851968: 4160,
                            917504: 4096,
                            983040: 2151682112,
                            32768: 2147487808,
                            98304: 64,
                            163840: 2151678016,
                            229376: 2147487744,
                            294912: 4198400,
                            360448: 2151682112,
                            425984: 0,
                            491520: 2151677952,
                            557056: 4096,
                            622592: 2151682048,
                            688128: 4194304,
                            753664: 4160,
                            819200: 2147483648,
                            884736: 4194368,
                            950272: 4198464,
                            1015808: 2147483712,
                            1048576: 4194368,
                            1114112: 4198400,
                            1179648: 2147483712,
                            1245184: 0,
                            1310720: 4160,
                            1376256: 2151678016,
                            1441792: 2151682048,
                            1507328: 2147487808,
                            1572864: 2151682112,
                            1638400: 2147483648,
                            1703936: 2151677952,
                            1769472: 4198464,
                            1835008: 2147487744,
                            1900544: 4194304,
                            1966080: 64,
                            2031616: 4096,
                            1081344: 2151677952,
                            1146880: 2151682112,
                            1212416: 0,
                            1277952: 4198400,
                            1343488: 4194368,
                            1409024: 2147483648,
                            1474560: 2147487808,
                            1540096: 64,
                            1605632: 2147483712,
                            1671168: 4096,
                            1736704: 2147487744,
                            1802240: 2151678016,
                            1867776: 4160,
                            1933312: 2151682048,
                            1998848: 4194304,
                            2064384: 4198464
                        }, {
                            0: 128,
                            4096: 17039360,
                            8192: 262144,
                            12288: 536870912,
                            16384: 537133184,
                            20480: 16777344,
                            24576: 553648256,
                            28672: 262272,
                            32768: 16777216,
                            36864: 537133056,
                            40960: 536871040,
                            45056: 553910400,
                            49152: 553910272,
                            53248: 0,
                            57344: 17039488,
                            61440: 553648128,
                            2048: 17039488,
                            6144: 553648256,
                            10240: 128,
                            14336: 17039360,
                            18432: 262144,
                            22528: 537133184,
                            26624: 553910272,
                            30720: 536870912,
                            34816: 537133056,
                            38912: 0,
                            43008: 553910400,
                            47104: 16777344,
                            51200: 536871040,
                            55296: 553648128,
                            59392: 16777216,
                            63488: 262272,
                            65536: 262144,
                            69632: 128,
                            73728: 536870912,
                            77824: 553648256,
                            81920: 16777344,
                            86016: 553910272,
                            90112: 537133184,
                            94208: 16777216,
                            98304: 553910400,
                            102400: 553648128,
                            106496: 17039360,
                            110592: 537133056,
                            114688: 262272,
                            118784: 536871040,
                            122880: 0,
                            126976: 17039488,
                            67584: 553648256,
                            71680: 16777216,
                            75776: 17039360,
                            79872: 537133184,
                            83968: 536870912,
                            88064: 17039488,
                            92160: 128,
                            96256: 553910272,
                            100352: 262272,
                            104448: 553910400,
                            108544: 0,
                            112640: 553648128,
                            116736: 16777344,
                            120832: 262144,
                            124928: 537133056,
                            129024: 536871040
                        }, {
                            0: 268435464,
                            256: 8192,
                            512: 270532608,
                            768: 270540808,
                            1024: 268443648,
                            1280: 2097152,
                            1536: 2097160,
                            1792: 268435456,
                            2048: 0,
                            2304: 268443656,
                            2560: 2105344,
                            2816: 8,
                            3072: 270532616,
                            3328: 2105352,
                            3584: 8200,
                            3840: 270540800,
                            128: 270532608,
                            384: 270540808,
                            640: 8,
                            896: 2097152,
                            1152: 2105352,
                            1408: 268435464,
                            1664: 268443648,
                            1920: 8200,
                            2176: 2097160,
                            2432: 8192,
                            2688: 268443656,
                            2944: 270532616,
                            3200: 0,
                            3456: 270540800,
                            3712: 2105344,
                            3968: 268435456,
                            4096: 268443648,
                            4352: 270532616,
                            4608: 270540808,
                            4864: 8200,
                            5120: 2097152,
                            5376: 268435456,
                            5632: 268435464,
                            5888: 2105344,
                            6144: 2105352,
                            6400: 0,
                            6656: 8,
                            6912: 270532608,
                            7168: 8192,
                            7424: 268443656,
                            7680: 270540800,
                            7936: 2097160,
                            4224: 8,
                            4480: 2105344,
                            4736: 2097152,
                            4992: 268435464,
                            5248: 268443648,
                            5504: 8200,
                            5760: 270540808,
                            6016: 270532608,
                            6272: 270540800,
                            6528: 270532616,
                            6784: 8192,
                            7040: 2105352,
                            7296: 2097160,
                            7552: 0,
                            7808: 268435456,
                            8064: 268443656
                        }, {
                            0: 1048576,
                            16: 33555457,
                            32: 1024,
                            48: 1049601,
                            64: 34604033,
                            80: 0,
                            96: 1,
                            112: 34603009,
                            128: 33555456,
                            144: 1048577,
                            160: 33554433,
                            176: 34604032,
                            192: 34603008,
                            208: 1025,
                            224: 1049600,
                            240: 33554432,
                            8: 34603009,
                            24: 0,
                            40: 33555457,
                            56: 34604032,
                            72: 1048576,
                            88: 33554433,
                            104: 33554432,
                            120: 1025,
                            136: 1049601,
                            152: 33555456,
                            168: 34603008,
                            184: 1048577,
                            200: 1024,
                            216: 34604033,
                            232: 1,
                            248: 1049600,
                            256: 33554432,
                            272: 1048576,
                            288: 33555457,
                            304: 34603009,
                            320: 1048577,
                            336: 33555456,
                            352: 34604032,
                            368: 1049601,
                            384: 1025,
                            400: 34604033,
                            416: 1049600,
                            432: 1,
                            448: 0,
                            464: 34603008,
                            480: 33554433,
                            496: 1024,
                            264: 1049600,
                            280: 33555457,
                            296: 34603009,
                            312: 1,
                            328: 33554432,
                            344: 1048576,
                            360: 1025,
                            376: 34604032,
                            392: 33554433,
                            408: 34603008,
                            424: 0,
                            440: 34604033,
                            456: 1049601,
                            472: 1024,
                            488: 33555456,
                            504: 1048577
                        }, {
                            0: 134219808,
                            1: 131072,
                            2: 134217728,
                            3: 32,
                            4: 131104,
                            5: 134350880,
                            6: 134350848,
                            7: 2048,
                            8: 134348800,
                            9: 134219776,
                            10: 133120,
                            11: 134348832,
                            12: 2080,
                            13: 0,
                            14: 134217760,
                            15: 133152,
                            2147483648: 2048,
                            2147483649: 134350880,
                            2147483650: 134219808,
                            2147483651: 134217728,
                            2147483652: 134348800,
                            2147483653: 133120,
                            2147483654: 133152,
                            2147483655: 32,
                            2147483656: 134217760,
                            2147483657: 2080,
                            2147483658: 131104,
                            2147483659: 134350848,
                            2147483660: 0,
                            2147483661: 134348832,
                            2147483662: 134219776,
                            2147483663: 131072,
                            16: 133152,
                            17: 134350848,
                            18: 32,
                            19: 2048,
                            20: 134219776,
                            21: 134217760,
                            22: 134348832,
                            23: 131072,
                            24: 0,
                            25: 131104,
                            26: 134348800,
                            27: 134219808,
                            28: 134350880,
                            29: 133120,
                            30: 2080,
                            31: 134217728,
                            2147483664: 131072,
                            2147483665: 2048,
                            2147483666: 134348832,
                            2147483667: 133152,
                            2147483668: 32,
                            2147483669: 134348800,
                            2147483670: 134217728,
                            2147483671: 134219808,
                            2147483672: 134350880,
                            2147483673: 134217760,
                            2147483674: 134219776,
                            2147483675: 0,
                            2147483676: 133120,
                            2147483677: 2080,
                            2147483678: 131104,
                            2147483679: 134350848
                        }],
                        h = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679],
                        l = s.DES = i.extend({
                            _doReset: function() {
                                for (var t = this._key.words, e = [], r = 0; 56 > r; r++) {
                                    var n = a[r] - 1;
                                    e[r] = t[n >>> 5] >>> 31 - n % 32 & 1
                                }
                                for (t = this._subKeys = [], n = 0; 16 > n; n++) {
                                    var i = t[n] = [],
                                        s = u[n];
                                    for (r = 0; 24 > r; r++) i[r / 6 | 0] |= e[(o[r] - 1 + s) % 28] << 31 - r % 6, i[4 + (r / 6 | 0)] |= e[28 + (o[r + 24] - 1 + s) % 28] << 31 - r % 6;
                                    for (i[0] = i[0] << 1 | i[0] >>> 31, r = 1; 7 > r; r++) i[r] >>>= 4 * (r - 1) + 3;
                                    i[7] = i[7] << 5 | i[7] >>> 27
                                }
                                for (e = this._invSubKeys = [], r = 0; 16 > r; r++) e[r] = t[15 - r]
                            },
                            encryptBlock: function(t, e) {
                                this._doCryptBlock(t, e, this._subKeys)
                            },
                            decryptBlock: function(t, e) {
                                this._doCryptBlock(t, e, this._invSubKeys)
                            },
                            _doCryptBlock: function(r, n, i) {
                                this._lBlock = r[n], this._rBlock = r[n + 1], t.call(this, 4, 252645135), t.call(this, 16, 65535), e.call(this, 2, 858993459), e.call(this, 8, 16711935), t.call(this, 1, 1431655765);
                                for (var s = 0; 16 > s; s++) {
                                    for (var a = i[s], o = this._lBlock, u = this._rBlock, l = 0, f = 0; 8 > f; f++) l |= c[f][((u ^ a[f]) & h[f]) >>> 0];
                                    this._lBlock = u, this._rBlock = o ^ l
                                }
                                i = this._lBlock, this._lBlock = this._rBlock, this._rBlock = i, t.call(this, 1, 1431655765), e.call(this, 8, 16711935), e.call(this, 2, 858993459), t.call(this, 16, 65535), t.call(this, 4, 252645135), r[n] = this._lBlock, r[n + 1] = this._rBlock
                            },
                            keySize: 2,
                            ivSize: 2,
                            blockSize: 2
                        });
                    r.DES = i._createHelper(l), s = s.TripleDES = i.extend({
                        _doReset: function() {
                            var t = this._key.words;
                            this._des1 = l.createEncryptor(n.create(t.slice(0, 2))), this._des2 = l.createEncryptor(n.create(t.slice(2, 4))), this._des3 = l.createEncryptor(n.create(t.slice(4, 6)))
                        },
                        encryptBlock: function(t, e) {
                            this._des1.encryptBlock(t, e), this._des2.decryptBlock(t, e), this._des3.encryptBlock(t, e)
                        },
                        decryptBlock: function(t, e) {
                            this._des3.decryptBlock(t, e), this._des2.encryptBlock(t, e), this._des1.decryptBlock(t, e)
                        },
                        keySize: 6,
                        ivSize: 2,
                        blockSize: 2
                    }), r.TripleDES = i._createHelper(s)
                }(),
                function() {
                    var t = y,
                        e = t.lib.WordArray;
                    t.enc.Base64 = {
                        stringify: function(t) {
                            var e = t.words,
                                r = t.sigBytes,
                                n = this._map;
                            t.clamp(), t = [];
                            for (var i = 0; i < r; i += 3)
                                for (var s = (e[i >>> 2] >>> 24 - i % 4 * 8 & 255) << 16 | (e[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255) << 8 | e[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255, a = 0; 4 > a && i + .75 * a < r; a++) t.push(n.charAt(s >>> 6 * (3 - a) & 63));
                            if (e = n.charAt(64))
                                for (; t.length % 4;) t.push(e);
                            return t.join("")
                        },
                        parse: function(t) {
                            var r = t.length,
                                n = this._map;
                            (i = n.charAt(64)) && (-1 != (i = t.indexOf(i)) && (r = i));
                            for (var i = [], s = 0, a = 0; a < r; a++)
                                if (a % 4) {
                                    var o = n.indexOf(t.charAt(a - 1)) << a % 4 * 2,
                                        u = n.indexOf(t.charAt(a)) >>> 6 - a % 4 * 2;
                                    i[s >>> 2] |= (o | u) << 24 - s % 4 * 8, s++
                                }
                            return e.create(i, s)
                        },
                        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                    }
                }(),
                function(t) {
                    function e(t, e, r, n, i, s, a) {
                        return ((t = t + (e & r | ~e & n) + i + a) << s | t >>> 32 - s) + e
                    }

                    function r(t, e, r, n, i, s, a) {
                        return ((t = t + (e & n | r & ~n) + i + a) << s | t >>> 32 - s) + e
                    }

                    function n(t, e, r, n, i, s, a) {
                        return ((t = t + (e ^ r ^ n) + i + a) << s | t >>> 32 - s) + e
                    }

                    function i(t, e, r, n, i, s, a) {
                        return ((t = t + (r ^ (e | ~n)) + i + a) << s | t >>> 32 - s) + e
                    }
                    for (var s = y, a = (u = s.lib).WordArray, o = u.Hasher, u = s.algo, c = [], h = 0; 64 > h; h++) c[h] = 4294967296 * t.abs(t.sin(h + 1)) | 0;
                    u = u.MD5 = o.extend({
                        _doReset: function() {
                            this._hash = new a.init([1732584193, 4023233417, 2562383102, 271733878])
                        },
                        _doProcessBlock: function(t, s) {
                            for (var a = 0; 16 > a; a++) {
                                var o = t[u = s + a];
                                t[u] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8)
                            }
                            a = this._hash.words;
                            var u = t[s + 0],
                                h = (o = t[s + 1], t[s + 2]),
                                l = t[s + 3],
                                f = t[s + 4],
                                p = t[s + 5],
                                d = t[s + 6],
                                g = t[s + 7],
                                y = t[s + 8],
                                v = t[s + 9],
                                m = t[s + 10],
                                E = t[s + 11],
                                S = t[s + 12],
                                b = t[s + 13],
                                C = t[s + 14],
                                A = t[s + 15],
                                w = e(w = a[0], I = a[1], x = a[2], T = a[3], u, 7, c[0]),
                                T = e(T, w, I, x, o, 12, c[1]),
                                x = e(x, T, w, I, h, 17, c[2]),
                                I = e(I, x, T, w, l, 22, c[3]);
                            w = e(w, I, x, T, f, 7, c[4]), T = e(T, w, I, x, p, 12, c[5]), x = e(x, T, w, I, d, 17, c[6]), I = e(I, x, T, w, g, 22, c[7]), w = e(w, I, x, T, y, 7, c[8]), T = e(T, w, I, x, v, 12, c[9]), x = e(x, T, w, I, m, 17, c[10]), I = e(I, x, T, w, E, 22, c[11]), w = e(w, I, x, T, S, 7, c[12]), T = e(T, w, I, x, b, 12, c[13]), x = e(x, T, w, I, C, 17, c[14]), w = r(w, I = e(I, x, T, w, A, 22, c[15]), x, T, o, 5, c[16]), T = r(T, w, I, x, d, 9, c[17]), x = r(x, T, w, I, E, 14, c[18]), I = r(I, x, T, w, u, 20, c[19]), w = r(w, I, x, T, p, 5, c[20]), T = r(T, w, I, x, m, 9, c[21]), x = r(x, T, w, I, A, 14, c[22]), I = r(I, x, T, w, f, 20, c[23]), w = r(w, I, x, T, v, 5, c[24]), T = r(T, w, I, x, C, 9, c[25]), x = r(x, T, w, I, l, 14, c[26]), I = r(I, x, T, w, y, 20, c[27]), w = r(w, I, x, T, b, 5, c[28]), T = r(T, w, I, x, h, 9, c[29]), x = r(x, T, w, I, g, 14, c[30]), w = n(w, I = r(I, x, T, w, S, 20, c[31]), x, T, p, 4, c[32]), T = n(T, w, I, x, y, 11, c[33]), x = n(x, T, w, I, E, 16, c[34]), I = n(I, x, T, w, C, 23, c[35]), w = n(w, I, x, T, o, 4, c[36]), T = n(T, w, I, x, f, 11, c[37]), x = n(x, T, w, I, g, 16, c[38]), I = n(I, x, T, w, m, 23, c[39]), w = n(w, I, x, T, b, 4, c[40]), T = n(T, w, I, x, u, 11, c[41]), x = n(x, T, w, I, l, 16, c[42]), I = n(I, x, T, w, d, 23, c[43]), w = n(w, I, x, T, v, 4, c[44]), T = n(T, w, I, x, S, 11, c[45]), x = n(x, T, w, I, A, 16, c[46]), w = i(w, I = n(I, x, T, w, h, 23, c[47]), x, T, u, 6, c[48]), T = i(T, w, I, x, g, 10, c[49]), x = i(x, T, w, I, C, 15, c[50]), I = i(I, x, T, w, p, 21, c[51]), w = i(w, I, x, T, S, 6, c[52]), T = i(T, w, I, x, l, 10, c[53]), x = i(x, T, w, I, m, 15, c[54]), I = i(I, x, T, w, o, 21, c[55]), w = i(w, I, x, T, y, 6, c[56]), T = i(T, w, I, x, A, 10, c[57]), x = i(x, T, w, I, d, 15, c[58]), I = i(I, x, T, w, b, 21, c[59]), w = i(w, I, x, T, f, 6, c[60]), T = i(T, w, I, x, E, 10, c[61]), x = i(x, T, w, I, h, 15, c[62]), I = i(I, x, T, w, v, 21, c[63]);
                            a[0] = a[0] + w | 0, a[1] = a[1] + I | 0, a[2] = a[2] + x | 0, a[3] = a[3] + T | 0
                        },
                        _doFinalize: function() {
                            var e = this._data,
                                r = e.words,
                                n = 8 * this._nDataBytes,
                                i = 8 * e.sigBytes;
                            r[i >>> 5] |= 128 << 24 - i % 32;
                            var s = t.floor(n / 4294967296);
                            for (r[15 + (i + 64 >>> 9 << 4)] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8), r[14 + (i + 64 >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8), e.sigBytes = 4 * (r.length + 1), this._process(), r = (e = this._hash).words, n = 0; 4 > n; n++) i = r[n], r[n] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8);
                            return e
                        },
                        clone: function() {
                            var t = o.clone.call(this);
                            return t._hash = this._hash.clone(), t
                        }
                    }), s.MD5 = o._createHelper(u), s.HmacMD5 = o._createHmacHelper(u)
                }(Math),
                function() {
                    var t = y,
                        e = (i = t.lib).WordArray,
                        r = i.Hasher,
                        n = [],
                        i = t.algo.SHA1 = r.extend({
                            _doReset: function() {
                                this._hash = new e.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                            },
                            _doProcessBlock: function(t, e) {
                                for (var r = this._hash.words, i = r[0], s = r[1], a = r[2], o = r[3], u = r[4], c = 0; 80 > c; c++) {
                                    if (16 > c) n[c] = 0 | t[e + c];
                                    else {
                                        var h = n[c - 3] ^ n[c - 8] ^ n[c - 14] ^ n[c - 16];
                                        n[c] = h << 1 | h >>> 31
                                    }
                                    h = (i << 5 | i >>> 27) + u + n[c], h = 20 > c ? h + (1518500249 + (s & a | ~s & o)) : 40 > c ? h + (1859775393 + (s ^ a ^ o)) : 60 > c ? h + ((s & a | s & o | a & o) - 1894007588) : h + ((s ^ a ^ o) - 899497514), u = o, o = a, a = s << 30 | s >>> 2, s = i, i = h
                                }
                                r[0] = r[0] + i | 0, r[1] = r[1] + s | 0, r[2] = r[2] + a | 0, r[3] = r[3] + o | 0, r[4] = r[4] + u | 0
                            },
                            _doFinalize: function() {
                                var t = this._data,
                                    e = t.words,
                                    r = 8 * this._nDataBytes,
                                    n = 8 * t.sigBytes;
                                return e[n >>> 5] |= 128 << 24 - n % 32, e[14 + (n + 64 >>> 9 << 4)] = Math.floor(r / 4294967296), e[15 + (n + 64 >>> 9 << 4)] = r, t.sigBytes = 4 * e.length, this._process(), this._hash
                            },
                            clone: function() {
                                var t = r.clone.call(this);
                                return t._hash = this._hash.clone(), t
                            }
                        });
                    t.SHA1 = r._createHelper(i), t.HmacSHA1 = r._createHmacHelper(i)
                }(),
                function(t) {
                    for (var e = y, r = (i = e.lib).WordArray, n = i.Hasher, i = e.algo, s = [], a = [], o = function(t) {
                            return 4294967296 * (t - (0 | t)) | 0
                        }, u = 2, c = 0; 64 > c;) {
                        var h;
                        t: {
                            h = u;
                            for (var l = t.sqrt(h), f = 2; f <= l; f++)
                                if (!(h % f)) {
                                    h = !1;
                                    break t
                                }
                            h = !0
                        }
                        h && (8 > c && (s[c] = o(t.pow(u, .5))), a[c] = o(t.pow(u, 1 / 3)), c++), u++
                    }
                    var p = [];
                    i = i.SHA256 = n.extend({
                        _doReset: function() {
                            this._hash = new r.init(s.slice(0))
                        },
                        _doProcessBlock: function(t, e) {
                            for (var r = this._hash.words, n = r[0], i = r[1], s = r[2], o = r[3], u = r[4], c = r[5], h = r[6], l = r[7], f = 0; 64 > f; f++) {
                                if (16 > f) p[f] = 0 | t[e + f];
                                else {
                                    var d = p[f - 15],
                                        g = p[f - 2];
                                    p[f] = ((d << 25 | d >>> 7) ^ (d << 14 | d >>> 18) ^ d >>> 3) + p[f - 7] + ((g << 15 | g >>> 17) ^ (g << 13 | g >>> 19) ^ g >>> 10) + p[f - 16]
                                }
                                d = l + ((u << 26 | u >>> 6) ^ (u << 21 | u >>> 11) ^ (u << 7 | u >>> 25)) + (u & c ^ ~u & h) + a[f] + p[f], g = ((n << 30 | n >>> 2) ^ (n << 19 | n >>> 13) ^ (n << 10 | n >>> 22)) + (n & i ^ n & s ^ i & s), l = h, h = c, c = u, u = o + d | 0, o = s, s = i, i = n, n = d + g | 0
                            }
                            r[0] = r[0] + n | 0, r[1] = r[1] + i | 0, r[2] = r[2] + s | 0, r[3] = r[3] + o | 0, r[4] = r[4] + u | 0, r[5] = r[5] + c | 0, r[6] = r[6] + h | 0, r[7] = r[7] + l | 0
                        },
                        _doFinalize: function() {
                            var e = this._data,
                                r = e.words,
                                n = 8 * this._nDataBytes,
                                i = 8 * e.sigBytes;
                            return r[i >>> 5] |= 128 << 24 - i % 32, r[14 + (i + 64 >>> 9 << 4)] = t.floor(n / 4294967296), r[15 + (i + 64 >>> 9 << 4)] = n, e.sigBytes = 4 * r.length, this._process(), this._hash
                        },
                        clone: function() {
                            var t = n.clone.call(this);
                            return t._hash = this._hash.clone(), t
                        }
                    });
                    e.SHA256 = n._createHelper(i), e.HmacSHA256 = n._createHmacHelper(i)
                }(Math),
                function() {
                    var t = y,
                        e = t.lib.WordArray,
                        r = (n = t.algo).SHA256,
                        n = n.SHA224 = r.extend({
                            _doReset: function() {
                                this._hash = new e.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
                            },
                            _doFinalize: function() {
                                var t = r._doFinalize.call(this);
                                return t.sigBytes -= 4, t
                            }
                        });
                    t.SHA224 = r._createHelper(n), t.HmacSHA224 = r._createHmacHelper(n)
                }(),
                function() {
                    function t() {
                        return n.create.apply(n, arguments)
                    }
                    for (var e = y, r = e.lib.Hasher, n = (s = e.x64).Word, i = s.WordArray, s = e.algo, a = [t(1116352408, 3609767458), t(1899447441, 602891725), t(3049323471, 3964484399), t(3921009573, 2173295548), t(961987163, 4081628472), t(1508970993, 3053834265), t(2453635748, 2937671579), t(2870763221, 3664609560), t(3624381080, 2734883394), t(310598401, 1164996542), t(607225278, 1323610764), t(1426881987, 3590304994), t(1925078388, 4068182383), t(2162078206, 991336113), t(2614888103, 633803317), t(3248222580, 3479774868), t(3835390401, 2666613458), t(4022224774, 944711139), t(264347078, 2341262773), t(604807628, 2007800933), t(770255983, 1495990901), t(1249150122, 1856431235), t(1555081692, 3175218132), t(1996064986, 2198950837), t(2554220882, 3999719339), t(2821834349, 766784016), t(2952996808, 2566594879), t(3210313671, 3203337956), t(3336571891, 1034457026), t(3584528711, 2466948901), t(113926993, 3758326383), t(338241895, 168717936), t(666307205, 1188179964), t(773529912, 1546045734), t(1294757372, 1522805485), t(1396182291, 2643833823), t(1695183700, 2343527390), t(1986661051, 1014477480), t(2177026350, 1206759142), t(2456956037, 344077627), t(2730485921, 1290863460), t(2820302411, 3158454273), t(3259730800, 3505952657), t(3345764771, 106217008), t(3516065817, 3606008344), t(3600352804, 1432725776), t(4094571909, 1467031594), t(275423344, 851169720), t(430227734, 3100823752), t(506948616, 1363258195), t(659060556, 3750685593), t(883997877, 3785050280), t(958139571, 3318307427), t(1322822218, 3812723403), t(1537002063, 2003034995), t(1747873779, 3602036899), t(1955562222, 1575990012), t(2024104815, 1125592928), t(2227730452, 2716904306), t(2361852424, 442776044), t(2428436474, 593698344), t(2756734187, 3733110249), t(3204031479, 2999351573), t(3329325298, 3815920427), t(3391569614, 3928383900), t(3515267271, 566280711), t(3940187606, 3454069534), t(4118630271, 4000239992), t(116418474, 1914138554), t(174292421, 2731055270), t(289380356, 3203993006), t(460393269, 320620315), t(685471733, 587496836), t(852142971, 1086792851), t(1017036298, 365543100), t(1126000580, 2618297676), t(1288033470, 3409855158), t(1501505948, 4234509866), t(1607167915, 987167468), t(1816402316, 1246189591)], o = [], u = 0; 80 > u; u++) o[u] = t();
                    s = s.SHA512 = r.extend({
                        _doReset: function() {
                            this._hash = new i.init([new n.init(1779033703, 4089235720), new n.init(3144134277, 2227873595), new n.init(1013904242, 4271175723), new n.init(2773480762, 1595750129), new n.init(1359893119, 2917565137), new n.init(2600822924, 725511199), new n.init(528734635, 4215389547), new n.init(1541459225, 327033209)])
                        },
                        _doProcessBlock: function(t, e) {
                            for (var r = (l = this._hash.words)[0], n = l[1], i = l[2], s = l[3], u = l[4], c = l[5], h = l[6], l = l[7], f = r.high, p = r.low, d = n.high, g = n.low, y = i.high, v = i.low, m = s.high, E = s.low, S = u.high, b = u.low, C = c.high, A = c.low, w = h.high, T = h.low, x = l.high, I = l.low, B = f, F = p, R = d, D = g, N = y, _ = v, P = m, k = E, L = S, O = b, U = C, V = A, H = w, j = T, M = x, K = I, q = 0; 80 > q; q++) {
                                var z = o[q];
                                if (16 > q) var G = z.high = 0 | t[e + 2 * q],
                                    Y = z.low = 0 | t[e + 2 * q + 1];
                                else {
                                    G = ((Y = (G = o[q - 15]).high) >>> 1 | (W = G.low) << 31) ^ (Y >>> 8 | W << 24) ^ Y >>> 7;
                                    var W = (W >>> 1 | Y << 31) ^ (W >>> 8 | Y << 24) ^ (W >>> 7 | Y << 25),
                                        X = ((Y = (X = o[q - 2]).high) >>> 19 | (Q = X.low) << 13) ^ (Y << 3 | Q >>> 29) ^ Y >>> 6,
                                        Q = (Q >>> 19 | Y << 13) ^ (Q << 3 | Y >>> 29) ^ (Q >>> 6 | Y << 26),
                                        Z = (Y = o[q - 7]).high,
                                        J = ($ = o[q - 16]).high,
                                        $ = $.low;
                                    G = (G = (G = G + Z + ((Y = W + Y.low) >>> 0 < W >>> 0 ? 1 : 0)) + X + ((Y = Y + Q) >>> 0 < Q >>> 0 ? 1 : 0)) + J + ((Y = Y + $) >>> 0 < $ >>> 0 ? 1 : 0);
                                    z.high = G, z.low = Y
                                }
                                Z = L & U ^ ~L & H, $ = O & V ^ ~O & j, z = B & R ^ B & N ^ R & N;
                                var tt = F & D ^ F & _ ^ D & _,
                                    et = (W = (B >>> 28 | F << 4) ^ (B << 30 | F >>> 2) ^ (B << 25 | F >>> 7), X = (F >>> 28 | B << 4) ^ (F << 30 | B >>> 2) ^ (F << 25 | B >>> 7), (Q = a[q]).high),
                                    rt = Q.low;
                                J = M + ((L >>> 14 | O << 18) ^ (L >>> 18 | O << 14) ^ (L << 23 | O >>> 9)) + ((Q = K + ((O >>> 14 | L << 18) ^ (O >>> 18 | L << 14) ^ (O << 23 | L >>> 9))) >>> 0 < K >>> 0 ? 1 : 0), M = H, K = j, H = U, j = V, U = L, V = O, L = P + (J = (J = (J = J + Z + ((Q = Q + $) >>> 0 < $ >>> 0 ? 1 : 0)) + et + ((Q = Q + rt) >>> 0 < rt >>> 0 ? 1 : 0)) + G + ((Q = Q + Y) >>> 0 < Y >>> 0 ? 1 : 0)) + ((O = k + Q | 0) >>> 0 < k >>> 0 ? 1 : 0) | 0, P = N, k = _, N = R, _ = D, R = B, D = F, B = J + (z = W + z + ((Y = X + tt) >>> 0 < X >>> 0 ? 1 : 0)) + ((F = Q + Y | 0) >>> 0 < Q >>> 0 ? 1 : 0) | 0
                            }
                            p = r.low = p + F, r.high = f + B + (p >>> 0 < F >>> 0 ? 1 : 0), g = n.low = g + D, n.high = d + R + (g >>> 0 < D >>> 0 ? 1 : 0), v = i.low = v + _, i.high = y + N + (v >>> 0 < _ >>> 0 ? 1 : 0), E = s.low = E + k, s.high = m + P + (E >>> 0 < k >>> 0 ? 1 : 0), b = u.low = b + O, u.high = S + L + (b >>> 0 < O >>> 0 ? 1 : 0), A = c.low = A + V, c.high = C + U + (A >>> 0 < V >>> 0 ? 1 : 0), T = h.low = T + j, h.high = w + H + (T >>> 0 < j >>> 0 ? 1 : 0), I = l.low = I + K, l.high = x + M + (I >>> 0 < K >>> 0 ? 1 : 0)
                        },
                        _doFinalize: function() {
                            var t = this._data,
                                e = t.words,
                                r = 8 * this._nDataBytes,
                                n = 8 * t.sigBytes;
                            return e[n >>> 5] |= 128 << 24 - n % 32, e[30 + (n + 128 >>> 10 << 5)] = Math.floor(r / 4294967296), e[31 + (n + 128 >>> 10 << 5)] = r, t.sigBytes = 4 * e.length, this._process(), this._hash.toX32()
                        },
                        clone: function() {
                            var t = r.clone.call(this);
                            return t._hash = this._hash.clone(), t
                        },
                        blockSize: 32
                    }), e.SHA512 = r._createHelper(s), e.HmacSHA512 = r._createHmacHelper(s)
                }(),
                function() {
                    var t = y,
                        e = (i = t.x64).Word,
                        r = i.WordArray,
                        n = (i = t.algo).SHA512,
                        i = i.SHA384 = n.extend({
                            _doReset: function() {
                                this._hash = new r.init([new e.init(3418070365, 3238371032), new e.init(1654270250, 914150663), new e.init(2438529370, 812702999), new e.init(355462360, 4144912697), new e.init(1731405415, 4290775857), new e.init(2394180231, 1750603025), new e.init(3675008525, 1694076839), new e.init(1203062813, 3204075428)])
                            },
                            _doFinalize: function() {
                                var t = n._doFinalize.call(this);
                                return t.sigBytes -= 16, t
                            }
                        });
                    t.SHA384 = n._createHelper(i), t.HmacSHA384 = n._createHmacHelper(i)
                }(),
                function() {
                    var t = y,
                        e = (n = t.lib).WordArray,
                        r = n.Hasher,
                        n = t.algo,
                        i = e.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
                        s = e.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
                        a = e.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),
                        o = e.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
                        u = e.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
                        c = e.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
                    n = n.RIPEMD160 = r.extend({
                        _doReset: function() {
                            this._hash = e.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                        },
                        _doProcessBlock: function(t, e) {
                            for (var r = 0; 16 > r; r++) {
                                var n = t[S = e + r];
                                t[S] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8)
                            }
                            var h, l, f, p, d, g, y, v, m, E, S = this._hash.words,
                                b = (n = u.words, c.words),
                                C = i.words,
                                A = s.words,
                                w = a.words,
                                T = o.words;
                            g = h = S[0], y = l = S[1], v = f = S[2], m = p = S[3], E = d = S[4];
                            var x;
                            for (r = 0; 80 > r; r += 1) x = h + t[e + C[r]] | 0, x = 16 > r ? x + ((l ^ f ^ p) + n[0]) : 32 > r ? x + ((l & f | ~l & p) + n[1]) : 48 > r ? x + (((l | ~f) ^ p) + n[2]) : 64 > r ? x + ((l & p | f & ~p) + n[3]) : x + ((l ^ (f | ~p)) + n[4]), x = (x = (x |= 0) << w[r] | x >>> 32 - w[r]) + d | 0, h = d, d = p, p = f << 10 | f >>> 22, f = l, l = x, x = g + t[e + A[r]] | 0, x = 16 > r ? x + ((y ^ (v | ~m)) + b[0]) : 32 > r ? x + ((y & m | v & ~m) + b[1]) : 48 > r ? x + (((y | ~v) ^ m) + b[2]) : 64 > r ? x + ((y & v | ~y & m) + b[3]) : x + ((y ^ v ^ m) + b[4]), x = (x = (x |= 0) << T[r] | x >>> 32 - T[r]) + E | 0, g = E, E = m, m = v << 10 | v >>> 22, v = y, y = x;
                            x = S[1] + f + m | 0, S[1] = S[2] + p + E | 0, S[2] = S[3] + d + g | 0, S[3] = S[4] + h + y | 0, S[4] = S[0] + l + v | 0, S[0] = x
                        },
                        _doFinalize: function() {
                            var t = this._data,
                                e = t.words,
                                r = 8 * this._nDataBytes,
                                n = 8 * t.sigBytes;
                            for (e[n >>> 5] |= 128 << 24 - n % 32, e[14 + (n + 64 >>> 9 << 4)] = 16711935 & (r << 8 | r >>> 24) | 4278255360 & (r << 24 | r >>> 8), t.sigBytes = 4 * (e.length + 1), this._process(), e = (t = this._hash).words, r = 0; 5 > r; r++) n = e[r], e[r] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8);
                            return t
                        },
                        clone: function() {
                            var t = r.clone.call(this);
                            return t._hash = this._hash.clone(), t
                        }
                    });
                    t.RIPEMD160 = r._createHelper(n), t.HmacRIPEMD160 = r._createHmacHelper(n)
                }(Math),
                function() {
                    var t = y,
                        e = t.enc.Utf8;
                    t.algo.HMAC = t.lib.Base.extend({
                        init: function(t, r) {
                            t = this._hasher = new t.init, "string" == typeof r && (r = e.parse(r));
                            var n = t.blockSize,
                                i = 4 * n;
                            r.sigBytes > i && (r = t.finalize(r)), r.clamp();
                            for (var s = this._oKey = r.clone(), a = this._iKey = r.clone(), o = s.words, u = a.words, c = 0; c < n; c++) o[c] ^= 1549556828, u[c] ^= 909522486;
                            s.sigBytes = a.sigBytes = i, this.reset()
                        },
                        reset: function() {
                            var t = this._hasher;
                            t.reset(), t.update(this._iKey)
                        },
                        update: function(t) {
                            return this._hasher.update(t), this
                        },
                        finalize: function(t) {
                            var e = this._hasher;
                            return t = e.finalize(t), e.reset(), e.finalize(this._oKey.clone().concat(t))
                        }
                    })
                }(),
                function() {
                    var t, e = y,
                        r = (t = e.lib).Base,
                        n = t.WordArray,
                        i = (t = e.algo).HMAC,
                        s = t.PBKDF2 = r.extend({
                            cfg: r.extend({
                                keySize: 4,
                                hasher: t.SHA1,
                                iterations: 1
                            }),
                            init: function(t) {
                                this.cfg = this.cfg.extend(t)
                            },
                            compute: function(t, e) {
                                var r = this.cfg,
                                    s = i.create(r.hasher, t),
                                    a = n.create(),
                                    o = n.create([1]),
                                    u = a.words,
                                    c = o.words,
                                    h = r.keySize;
                                for (r = r.iterations; u.length < h;) {
                                    var l = s.update(e).finalize(o);
                                    s.reset();
                                    for (var f = l.words, p = f.length, d = l, g = 1; g < r; g++) {
                                        d = s.finalize(d), s.reset();
                                        for (var y = d.words, v = 0; v < p; v++) f[v] ^= y[v]
                                    }
                                    a.concat(l), c[0]++
                                }
                                return a.sigBytes = 4 * h, a
                            }
                        });
                    e.PBKDF2 = function(t, e, r) {
                        return s.create(r).compute(t, e)
                    }
                }();
            /*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
             */
            var v, m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

            function E(t) {
                var e, r, n = "";
                for (e = 0; e + 3 <= t.length; e += 3) r = parseInt(t.substring(e, e + 3), 16), n += m.charAt(r >> 6) + m.charAt(63 & r);
                for (e + 1 == t.length ? (r = parseInt(t.substring(e, e + 1), 16), n += m.charAt(r << 2)) : e + 2 == t.length && (r = parseInt(t.substring(e, e + 2), 16), n += m.charAt(r >> 2) + m.charAt((3 & r) << 4)), "=";
                    (3 & n.length) > 0;) n += "=";
                return n
            }

            function S(t) {
                var e, r, n, i = "",
                    s = 0;
                for (e = 0; e < t.length && "=" != t.charAt(e); ++e)(n = m.indexOf(t.charAt(e))) < 0 || (0 == s ? (i += I(n >> 2), r = 3 & n, s = 1) : 1 == s ? (i += I(r << 2 | n >> 4), r = 15 & n, s = 2) : 2 == s ? (i += I(r), i += I(n >> 2), r = 3 & n, s = 3) : (i += I(r << 2 | n >> 4), i += I(15 & n), s = 0));
                return 1 == s && (i += I(r << 2)), i
            }

            function b(t) {
                var e, r = S(t),
                    n = new Array;
                for (e = 0; 2 * e < r.length; ++e) n[e] = parseInt(r.substring(2 * e, 2 * e + 2), 16);
                return n
            }

            function C(t, e, r) {
                null != t && ("number" == typeof t ? this.fromNumber(t, e, r) : null == e && "string" != typeof t ? this.fromString(t, 256) : this.fromString(t, e))
            }

            function A() {
                return new C(null)
            }
            "Microsoft Internet Explorer" == r.appName ? (C.prototype.am = function(t, e, r, n, i, s) {
                for (var a = 32767 & e, o = e >> 15; --s >= 0;) {
                    var u = 32767 & this[t],
                        c = this[t++] >> 15,
                        h = o * u + c * a;
                    i = ((u = a * u + ((32767 & h) << 15) + r[n] + (1073741823 & i)) >>> 30) + (h >>> 15) + o * c + (i >>> 30), r[n++] = 1073741823 & u
                }
                return i
            }, v = 30) : "Netscape" != r.appName ? (C.prototype.am = function(t, e, r, n, i, s) {
                for (; --s >= 0;) {
                    var a = e * this[t++] + r[n] + i;
                    i = Math.floor(a / 67108864), r[n++] = 67108863 & a
                }
                return i
            }, v = 26) : (C.prototype.am = function(t, e, r, n, i, s) {
                for (var a = 16383 & e, o = e >> 14; --s >= 0;) {
                    var u = 16383 & this[t],
                        c = this[t++] >> 14,
                        h = o * u + c * a;
                    i = ((u = a * u + ((16383 & h) << 14) + r[n] + i) >> 28) + (h >> 14) + o * c, r[n++] = 268435455 & u
                }
                return i
            }, v = 28), C.prototype.DB = v, C.prototype.DM = (1 << v) - 1, C.prototype.DV = 1 << v;
            C.prototype.FV = Math.pow(2, 52), C.prototype.F1 = 52 - v, C.prototype.F2 = 2 * v - 52;
            var w, T, x = new Array;
            for (w = "0".charCodeAt(0), T = 0; T <= 9; ++T) x[w++] = T;
            for (w = "a".charCodeAt(0), T = 10; T < 36; ++T) x[w++] = T;
            for (w = "A".charCodeAt(0), T = 10; T < 36; ++T) x[w++] = T;

            function I(t) {
                return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(t)
            }

            function B(t, e) {
                var r = x[t.charCodeAt(e)];
                return null == r ? -1 : r
            }

            function F(t) {
                var e = A();
                return e.fromInt(t), e
            }

            function R(t) {
                var e, r = 1;
                return 0 != (e = t >>> 16) && (t = e, r += 16), 0 != (e = t >> 8) && (t = e, r += 8), 0 != (e = t >> 4) && (t = e, r += 4), 0 != (e = t >> 2) && (t = e, r += 2), 0 != (e = t >> 1) && (t = e, r += 1), r
            }

            function D(t) {
                this.m = t
            }

            function N(t) {
                this.m = t, this.mp = t.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << t.DB - 15) - 1, this.mt2 = 2 * t.t
            }

            function _(t, e) {
                return t & e
            }

            function P(t, e) {
                return t | e
            }

            function k(t, e) {
                return t ^ e
            }

            function L(t, e) {
                return t & ~e
            }

            function O(t) {
                if (0 == t) return -1;
                var e = 0;
                return 0 == (65535 & t) && (t >>= 16, e += 16), 0 == (255 & t) && (t >>= 8, e += 8), 0 == (15 & t) && (t >>= 4, e += 4), 0 == (3 & t) && (t >>= 2, e += 2), 0 == (1 & t) && ++e, e
            }

            function U(t) {
                for (var e = 0; 0 != t;) t &= t - 1, ++e;
                return e
            }

            function V() {}

            function H(t) {
                return t
            }

            function j(t) {
                this.r2 = A(), this.q3 = A(), C.ONE.dlShiftTo(2 * t.t, this.r2), this.mu = this.r2.divide(t), this.m = t
            }
            D.prototype.convert = function(t) {
                return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t
            }, D.prototype.revert = function(t) {
                return t
            }, D.prototype.reduce = function(t) {
                t.divRemTo(this.m, null, t)
            }, D.prototype.mulTo = function(t, e, r) {
                t.multiplyTo(e, r), this.reduce(r)
            }, D.prototype.sqrTo = function(t, e) {
                t.squareTo(e), this.reduce(e)
            }, N.prototype.convert = function(t) {
                var e = A();
                return t.abs().dlShiftTo(this.m.t, e), e.divRemTo(this.m, null, e), t.s < 0 && e.compareTo(C.ZERO) > 0 && this.m.subTo(e, e), e
            }, N.prototype.revert = function(t) {
                var e = A();
                return t.copyTo(e), this.reduce(e), e
            }, N.prototype.reduce = function(t) {
                for (; t.t <= this.mt2;) t[t.t++] = 0;
                for (var e = 0; e < this.m.t; ++e) {
                    var r = 32767 & t[e],
                        n = r * this.mpl + ((r * this.mph + (t[e] >> 15) * this.mpl & this.um) << 15) & t.DM;
                    for (t[r = e + this.m.t] += this.m.am(0, n, t, e, 0, this.m.t); t[r] >= t.DV;) t[r] -= t.DV, t[++r]++
                }
                t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t)
            }, N.prototype.mulTo = function(t, e, r) {
                t.multiplyTo(e, r), this.reduce(r)
            }, N.prototype.sqrTo = function(t, e) {
                t.squareTo(e), this.reduce(e)
            }, C.prototype.copyTo = function(t) {
                for (var e = this.t - 1; e >= 0; --e) t[e] = this[e];
                t.t = this.t, t.s = this.s
            }, C.prototype.fromInt = function(t) {
                this.t = 1, this.s = t < 0 ? -1 : 0, t > 0 ? this[0] = t : t < -1 ? this[0] = t + this.DV : this.t = 0
            }, C.prototype.fromString = function(t, e) {
                var r;
                if (16 == e) r = 4;
                else if (8 == e) r = 3;
                else if (256 == e) r = 8;
                else if (2 == e) r = 1;
                else if (32 == e) r = 5;
                else {
                    if (4 != e) return void this.fromRadix(t, e);
                    r = 2
                }
                this.t = 0, this.s = 0;
                for (var n = t.length, i = !1, s = 0; --n >= 0;) {
                    var a = 8 == r ? 255 & t[n] : B(t, n);
                    a < 0 ? "-" == t.charAt(n) && (i = !0) : (i = !1, 0 == s ? this[this.t++] = a : s + r > this.DB ? (this[this.t - 1] |= (a & (1 << this.DB - s) - 1) << s, this[this.t++] = a >> this.DB - s) : this[this.t - 1] |= a << s, (s += r) >= this.DB && (s -= this.DB))
                }
                8 == r && 0 != (128 & t[0]) && (this.s = -1, s > 0 && (this[this.t - 1] |= (1 << this.DB - s) - 1 << s)), this.clamp(), i && C.ZERO.subTo(this, this)
            }, C.prototype.clamp = function() {
                for (var t = this.s & this.DM; this.t > 0 && this[this.t - 1] == t;) --this.t
            }, C.prototype.dlShiftTo = function(t, e) {
                var r;
                for (r = this.t - 1; r >= 0; --r) e[r + t] = this[r];
                for (r = t - 1; r >= 0; --r) e[r] = 0;
                e.t = this.t + t, e.s = this.s
            }, C.prototype.drShiftTo = function(t, e) {
                for (var r = t; r < this.t; ++r) e[r - t] = this[r];
                e.t = Math.max(this.t - t, 0), e.s = this.s
            }, C.prototype.lShiftTo = function(t, e) {
                var r, n = t % this.DB,
                    i = this.DB - n,
                    s = (1 << i) - 1,
                    a = Math.floor(t / this.DB),
                    o = this.s << n & this.DM;
                for (r = this.t - 1; r >= 0; --r) e[r + a + 1] = this[r] >> i | o, o = (this[r] & s) << n;
                for (r = a - 1; r >= 0; --r) e[r] = 0;
                e[a] = o, e.t = this.t + a + 1, e.s = this.s, e.clamp()
            }, C.prototype.rShiftTo = function(t, e) {
                e.s = this.s;
                var r = Math.floor(t / this.DB);
                if (r >= this.t) e.t = 0;
                else {
                    var n = t % this.DB,
                        i = this.DB - n,
                        s = (1 << n) - 1;
                    e[0] = this[r] >> n;
                    for (var a = r + 1; a < this.t; ++a) e[a - r - 1] |= (this[a] & s) << i, e[a - r] = this[a] >> n;
                    n > 0 && (e[this.t - r - 1] |= (this.s & s) << i), e.t = this.t - r, e.clamp()
                }
            }, C.prototype.subTo = function(t, e) {
                for (var r = 0, n = 0, i = Math.min(t.t, this.t); r < i;) n += this[r] - t[r], e[r++] = n & this.DM, n >>= this.DB;
                if (t.t < this.t) {
                    for (n -= t.s; r < this.t;) n += this[r], e[r++] = n & this.DM, n >>= this.DB;
                    n += this.s
                } else {
                    for (n += this.s; r < t.t;) n -= t[r], e[r++] = n & this.DM, n >>= this.DB;
                    n -= t.s
                }
                e.s = n < 0 ? -1 : 0, n < -1 ? e[r++] = this.DV + n : n > 0 && (e[r++] = n), e.t = r, e.clamp()
            }, C.prototype.multiplyTo = function(t, e) {
                var r = this.abs(),
                    n = t.abs(),
                    i = r.t;
                for (e.t = i + n.t; --i >= 0;) e[i] = 0;
                for (i = 0; i < n.t; ++i) e[i + r.t] = r.am(0, n[i], e, i, 0, r.t);
                e.s = 0, e.clamp(), this.s != t.s && C.ZERO.subTo(e, e)
            }, C.prototype.squareTo = function(t) {
                for (var e = this.abs(), r = t.t = 2 * e.t; --r >= 0;) t[r] = 0;
                for (r = 0; r < e.t - 1; ++r) {
                    var n = e.am(r, e[r], t, 2 * r, 0, 1);
                    (t[r + e.t] += e.am(r + 1, 2 * e[r], t, 2 * r + 1, n, e.t - r - 1)) >= e.DV && (t[r + e.t] -= e.DV, t[r + e.t + 1] = 1)
                }
                t.t > 0 && (t[t.t - 1] += e.am(r, e[r], t, 2 * r, 0, 1)), t.s = 0, t.clamp()
            }, C.prototype.divRemTo = function(t, e, r) {
                var n = t.abs();
                if (!(n.t <= 0)) {
                    var i = this.abs();
                    if (i.t < n.t) return null != e && e.fromInt(0), void(null != r && this.copyTo(r));
                    null == r && (r = A());
                    var s = A(),
                        a = this.s,
                        o = t.s,
                        u = this.DB - R(n[n.t - 1]);
                    u > 0 ? (n.lShiftTo(u, s), i.lShiftTo(u, r)) : (n.copyTo(s), i.copyTo(r));
                    var c = s.t,
                        h = s[c - 1];
                    if (0 != h) {
                        var l = h * (1 << this.F1) + (c > 1 ? s[c - 2] >> this.F2 : 0),
                            f = this.FV / l,
                            p = (1 << this.F1) / l,
                            d = 1 << this.F2,
                            g = r.t,
                            y = g - c,
                            v = null == e ? A() : e;
                        for (s.dlShiftTo(y, v), r.compareTo(v) >= 0 && (r[r.t++] = 1, r.subTo(v, r)), C.ONE.dlShiftTo(c, v), v.subTo(s, s); s.t < c;) s[s.t++] = 0;
                        for (; --y >= 0;) {
                            var m = r[--g] == h ? this.DM : Math.floor(r[g] * f + (r[g - 1] + d) * p);
                            if ((r[g] += s.am(0, m, r, y, 0, c)) < m)
                                for (s.dlShiftTo(y, v), r.subTo(v, r); r[g] < --m;) r.subTo(v, r)
                        }
                        null != e && (r.drShiftTo(c, e), a != o && C.ZERO.subTo(e, e)), r.t = c, r.clamp(), u > 0 && r.rShiftTo(u, r), a < 0 && C.ZERO.subTo(r, r)
                    }
                }
            }, C.prototype.invDigit = function() {
                if (this.t < 1) return 0;
                var t = this[0];
                if (0 == (1 & t)) return 0;
                var e = 3 & t;
                return (e = (e = (e = (e = e * (2 - (15 & t) * e) & 15) * (2 - (255 & t) * e) & 255) * (2 - ((65535 & t) * e & 65535)) & 65535) * (2 - t * e % this.DV) % this.DV) > 0 ? this.DV - e : -e
            }, C.prototype.isEven = function() {
                return 0 == (this.t > 0 ? 1 & this[0] : this.s)
            }, C.prototype.exp = function(t, e) {
                if (t > 4294967295 || t < 1) return C.ONE;
                var r = A(),
                    n = A(),
                    i = e.convert(this),
                    s = R(t) - 1;
                for (i.copyTo(r); --s >= 0;)
                    if (e.sqrTo(r, n), (t & 1 << s) > 0) e.mulTo(n, i, r);
                    else {
                        var a = r;
                        r = n, n = a
                    }
                return e.revert(r)
            }, C.prototype.toString = function(t) {
                if (this.s < 0) return "-" + this.negate().toString(t);
                var e;
                if (16 == t) e = 4;
                else if (8 == t) e = 3;
                else if (2 == t) e = 1;
                else if (32 == t) e = 5;
                else {
                    if (4 != t) return this.toRadix(t);
                    e = 2
                }
                var r, n = (1 << e) - 1,
                    i = !1,
                    s = "",
                    a = this.t,
                    o = this.DB - a * this.DB % e;
                if (a-- > 0)
                    for (o < this.DB && (r = this[a] >> o) > 0 && (i = !0, s = I(r)); a >= 0;) o < e ? (r = (this[a] & (1 << o) - 1) << e - o, r |= this[--a] >> (o += this.DB - e)) : (r = this[a] >> (o -= e) & n, o <= 0 && (o += this.DB, --a)), r > 0 && (i = !0), i && (s += I(r));
                return i ? s : "0"
            }, C.prototype.negate = function() {
                var t = A();
                return C.ZERO.subTo(this, t), t
            }, C.prototype.abs = function() {
                return this.s < 0 ? this.negate() : this
            }, C.prototype.compareTo = function(t) {
                var e = this.s - t.s;
                if (0 != e) return e;
                var r = this.t;
                if (0 != (e = r - t.t)) return this.s < 0 ? -e : e;
                for (; --r >= 0;)
                    if (0 != (e = this[r] - t[r])) return e;
                return 0
            }, C.prototype.bitLength = function() {
                return this.t <= 0 ? 0 : this.DB * (this.t - 1) + R(this[this.t - 1] ^ this.s & this.DM)
            }, C.prototype.mod = function(t) {
                var e = A();
                return this.abs().divRemTo(t, null, e), this.s < 0 && e.compareTo(C.ZERO) > 0 && t.subTo(e, e), e
            }, C.prototype.modPowInt = function(t, e) {
                var r;
                return r = t < 256 || e.isEven() ? new D(e) : new N(e), this.exp(t, r)
            }, C.ZERO = F(0), C.ONE = F(1), V.prototype.convert = H, V.prototype.revert = H, V.prototype.mulTo = function(t, e, r) {
                t.multiplyTo(e, r)
            }, V.prototype.sqrTo = function(t, e) {
                t.squareTo(e)
            }, j.prototype.convert = function(t) {
                if (t.s < 0 || t.t > 2 * this.m.t) return t.mod(this.m);
                if (t.compareTo(this.m) < 0) return t;
                var e = A();
                return t.copyTo(e), this.reduce(e), e
            }, j.prototype.revert = function(t) {
                return t
            }, j.prototype.reduce = function(t) {
                for (t.drShiftTo(this.m.t - 1, this.r2), t.t > this.m.t + 1 && (t.t = this.m.t + 1, t.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t.compareTo(this.r2) < 0;) t.dAddOffset(1, this.m.t + 1);
                for (t.subTo(this.r2, t); t.compareTo(this.m) >= 0;) t.subTo(this.m, t)
            }, j.prototype.mulTo = function(t, e, r) {
                t.multiplyTo(e, r), this.reduce(r)
            }, j.prototype.sqrTo = function(t, e) {
                t.squareTo(e), this.reduce(e)
            };
            var M = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997],
                K = (1 << 26) / M[M.length - 1];
            /*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
             */
            function q() {
                this.i = 0, this.j = 0, this.S = new Array
            }
            C.prototype.chunkSize = function(t) {
                    return Math.floor(Math.LN2 * this.DB / Math.log(t))
                }, C.prototype.toRadix = function(t) {
                    if (null == t && (t = 10), 0 == this.signum() || t < 2 || t > 36) return "0";
                    var e = this.chunkSize(t),
                        r = Math.pow(t, e),
                        n = F(r),
                        i = A(),
                        s = A(),
                        a = "";
                    for (this.divRemTo(n, i, s); i.signum() > 0;) a = (r + s.intValue()).toString(t).substr(1) + a, i.divRemTo(n, i, s);
                    return s.intValue().toString(t) + a
                }, C.prototype.fromRadix = function(t, e) {
                    this.fromInt(0), null == e && (e = 10);
                    for (var r = this.chunkSize(e), n = Math.pow(e, r), i = !1, s = 0, a = 0, o = 0; o < t.length; ++o) {
                        var u = B(t, o);
                        u < 0 ? "-" == t.charAt(o) && 0 == this.signum() && (i = !0) : (a = e * a + u, ++s >= r && (this.dMultiply(n), this.dAddOffset(a, 0), s = 0, a = 0))
                    }
                    s > 0 && (this.dMultiply(Math.pow(e, s)), this.dAddOffset(a, 0)), i && C.ZERO.subTo(this, this)
                }, C.prototype.fromNumber = function(t, e, r) {
                    if ("number" == typeof e)
                        if (t < 2) this.fromInt(1);
                        else
                            for (this.fromNumber(t, r), this.testBit(t - 1) || this.bitwiseTo(C.ONE.shiftLeft(t - 1), P, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e);) this.dAddOffset(2, 0), this.bitLength() > t && this.subTo(C.ONE.shiftLeft(t - 1), this);
                    else {
                        var n = new Array,
                            i = 7 & t;
                        n.length = 1 + (t >> 3), e.nextBytes(n), i > 0 ? n[0] &= (1 << i) - 1 : n[0] = 0, this.fromString(n, 256)
                    }
                }, C.prototype.bitwiseTo = function(t, e, r) {
                    var n, i, s = Math.min(t.t, this.t);
                    for (n = 0; n < s; ++n) r[n] = e(this[n], t[n]);
                    if (t.t < this.t) {
                        for (i = t.s & this.DM, n = s; n < this.t; ++n) r[n] = e(this[n], i);
                        r.t = this.t
                    } else {
                        for (i = this.s & this.DM, n = s; n < t.t; ++n) r[n] = e(i, t[n]);
                        r.t = t.t
                    }
                    r.s = e(this.s, t.s), r.clamp()
                }, C.prototype.changeBit = function(t, e) {
                    var r = C.ONE.shiftLeft(t);
                    return this.bitwiseTo(r, e, r), r
                }, C.prototype.addTo = function(t, e) {
                    for (var r = 0, n = 0, i = Math.min(t.t, this.t); r < i;) n += this[r] + t[r], e[r++] = n & this.DM, n >>= this.DB;
                    if (t.t < this.t) {
                        for (n += t.s; r < this.t;) n += this[r], e[r++] = n & this.DM, n >>= this.DB;
                        n += this.s
                    } else {
                        for (n += this.s; r < t.t;) n += t[r], e[r++] = n & this.DM, n >>= this.DB;
                        n += t.s
                    }
                    e.s = n < 0 ? -1 : 0, n > 0 ? e[r++] = n : n < -1 && (e[r++] = this.DV + n), e.t = r, e.clamp()
                }, C.prototype.dMultiply = function(t) {
                    this[this.t] = this.am(0, t - 1, this, 0, 0, this.t), ++this.t, this.clamp()
                }, C.prototype.dAddOffset = function(t, e) {
                    if (0 != t) {
                        for (; this.t <= e;) this[this.t++] = 0;
                        for (this[e] += t; this[e] >= this.DV;) this[e] -= this.DV, ++e >= this.t && (this[this.t++] = 0), ++this[e]
                    }
                }, C.prototype.multiplyLowerTo = function(t, e, r) {
                    var n, i = Math.min(this.t + t.t, e);
                    for (r.s = 0, r.t = i; i > 0;) r[--i] = 0;
                    for (n = r.t - this.t; i < n; ++i) r[i + this.t] = this.am(0, t[i], r, i, 0, this.t);
                    for (n = Math.min(t.t, e); i < n; ++i) this.am(0, t[i], r, i, 0, e - i);
                    r.clamp()
                }, C.prototype.multiplyUpperTo = function(t, e, r) {
                    --e;
                    var n = r.t = this.t + t.t - e;
                    for (r.s = 0; --n >= 0;) r[n] = 0;
                    for (n = Math.max(e - this.t, 0); n < t.t; ++n) r[this.t + n - e] = this.am(e - n, t[n], r, 0, 0, this.t + n - e);
                    r.clamp(), r.drShiftTo(1, r)
                }, C.prototype.modInt = function(t) {
                    if (t <= 0) return 0;
                    var e = this.DV % t,
                        r = this.s < 0 ? t - 1 : 0;
                    if (this.t > 0)
                        if (0 == e) r = this[0] % t;
                        else
                            for (var n = this.t - 1; n >= 0; --n) r = (e * r + this[n]) % t;
                    return r
                }, C.prototype.millerRabin = function(t) {
                    var e = this.subtract(C.ONE),
                        r = e.getLowestSetBit();
                    if (r <= 0) return !1;
                    var n = e.shiftRight(r);
                    (t = t + 1 >> 1) > M.length && (t = M.length);
                    for (var i = A(), s = 0; s < t; ++s) {
                        i.fromInt(M[Math.floor(Math.random() * M.length)]);
                        var a = i.modPow(n, this);
                        if (0 != a.compareTo(C.ONE) && 0 != a.compareTo(e)) {
                            for (var o = 1; o++ < r && 0 != a.compareTo(e);)
                                if (0 == (a = a.modPowInt(2, this)).compareTo(C.ONE)) return !1;
                            if (0 != a.compareTo(e)) return !1
                        }
                    }
                    return !0
                }, C.prototype.clone =
                /*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
                 */
                function() {
                    var t = A();
                    return this.copyTo(t), t
                }, C.prototype.intValue = function() {
                    if (this.s < 0) {
                        if (1 == this.t) return this[0] - this.DV;
                        if (0 == this.t) return -1
                    } else {
                        if (1 == this.t) return this[0];
                        if (0 == this.t) return 0
                    }
                    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0]
                }, C.prototype.byteValue = function() {
                    return 0 == this.t ? this.s : this[0] << 24 >> 24
                }, C.prototype.shortValue = function() {
                    return 0 == this.t ? this.s : this[0] << 16 >> 16
                }, C.prototype.signum = function() {
                    return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this[0] <= 0 ? 0 : 1
                }, C.prototype.toByteArray = function() {
                    var t = this.t,
                        e = new Array;
                    e[0] = this.s;
                    var r, n = this.DB - t * this.DB % 8,
                        i = 0;
                    if (t-- > 0)
                        for (n < this.DB && (r = this[t] >> n) != (this.s & this.DM) >> n && (e[i++] = r | this.s << this.DB - n); t >= 0;) n < 8 ? (r = (this[t] & (1 << n) - 1) << 8 - n, r |= this[--t] >> (n += this.DB - 8)) : (r = this[t] >> (n -= 8) & 255, n <= 0 && (n += this.DB, --t)), 0 != (128 & r) && (r |= -256), 0 == i && (128 & this.s) != (128 & r) && ++i, (i > 0 || r != this.s) && (e[i++] = r);
                    return e
                }, C.prototype.equals = function(t) {
                    return 0 == this.compareTo(t)
                }, C.prototype.min = function(t) {
                    return this.compareTo(t) < 0 ? this : t
                }, C.prototype.max = function(t) {
                    return this.compareTo(t) > 0 ? this : t
                }, C.prototype.and = function(t) {
                    var e = A();
                    return this.bitwiseTo(t, _, e), e
                }, C.prototype.or = function(t) {
                    var e = A();
                    return this.bitwiseTo(t, P, e), e
                }, C.prototype.xor = function(t) {
                    var e = A();
                    return this.bitwiseTo(t, k, e), e
                }, C.prototype.andNot = function(t) {
                    var e = A();
                    return this.bitwiseTo(t, L, e), e
                }, C.prototype.not = function() {
                    for (var t = A(), e = 0; e < this.t; ++e) t[e] = this.DM & ~this[e];
                    return t.t = this.t, t.s = ~this.s, t
                }, C.prototype.shiftLeft = function(t) {
                    var e = A();
                    return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e), e
                }, C.prototype.shiftRight = function(t) {
                    var e = A();
                    return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e), e
                }, C.prototype.getLowestSetBit = function() {
                    for (var t = 0; t < this.t; ++t)
                        if (0 != this[t]) return t * this.DB + O(this[t]);
                    return this.s < 0 ? this.t * this.DB : -1
                }, C.prototype.bitCount = function() {
                    for (var t = 0, e = this.s & this.DM, r = 0; r < this.t; ++r) t += U(this[r] ^ e);
                    return t
                }, C.prototype.testBit = function(t) {
                    var e = Math.floor(t / this.DB);
                    return e >= this.t ? 0 != this.s : 0 != (this[e] & 1 << t % this.DB)
                }, C.prototype.setBit = function(t) {
                    return this.changeBit(t, P)
                }, C.prototype.clearBit = function(t) {
                    return this.changeBit(t, L)
                }, C.prototype.flipBit = function(t) {
                    return this.changeBit(t, k)
                }, C.prototype.add = function(t) {
                    var e = A();
                    return this.addTo(t, e), e
                }, C.prototype.subtract = function(t) {
                    var e = A();
                    return this.subTo(t, e), e
                }, C.prototype.multiply = function(t) {
                    var e = A();
                    return this.multiplyTo(t, e), e
                }, C.prototype.divide = function(t) {
                    var e = A();
                    return this.divRemTo(t, e, null), e
                }, C.prototype.remainder = function(t) {
                    var e = A();
                    return this.divRemTo(t, null, e), e
                }, C.prototype.divideAndRemainder = function(t) {
                    var e = A(),
                        r = A();
                    return this.divRemTo(t, e, r), new Array(e, r)
                }, C.prototype.modPow = function(t, e) {
                    var r, n, i = t.bitLength(),
                        s = F(1);
                    if (i <= 0) return s;
                    r = i < 18 ? 1 : i < 48 ? 3 : i < 144 ? 4 : i < 768 ? 5 : 6, n = i < 8 ? new D(e) : e.isEven() ? new j(e) : new N(e);
                    var a = new Array,
                        o = 3,
                        u = r - 1,
                        c = (1 << r) - 1;
                    if (a[1] = n.convert(this), r > 1) {
                        var h = A();
                        for (n.sqrTo(a[1], h); o <= c;) a[o] = A(), n.mulTo(h, a[o - 2], a[o]), o += 2
                    }
                    var l, f, p = t.t - 1,
                        d = !0,
                        g = A();
                    for (i = R(t[p]) - 1; p >= 0;) {
                        for (i >= u ? l = t[p] >> i - u & c : (l = (t[p] & (1 << i + 1) - 1) << u - i, p > 0 && (l |= t[p - 1] >> this.DB + i - u)), o = r; 0 == (1 & l);) l >>= 1, --o;
                        if ((i -= o) < 0 && (i += this.DB, --p), d) a[l].copyTo(s), d = !1;
                        else {
                            for (; o > 1;) n.sqrTo(s, g), n.sqrTo(g, s), o -= 2;
                            o > 0 ? n.sqrTo(s, g) : (f = s, s = g, g = f), n.mulTo(g, a[l], s)
                        }
                        for (; p >= 0 && 0 == (t[p] & 1 << i);) n.sqrTo(s, g), f = s, s = g, g = f, --i < 0 && (i = this.DB - 1, --p)
                    }
                    return n.revert(s)
                }, C.prototype.modInverse = function(t) {
                    var e = t.isEven();
                    if (this.isEven() && e || 0 == t.signum()) return C.ZERO;
                    for (var r = t.clone(), n = this.clone(), i = F(1), s = F(0), a = F(0), o = F(1); 0 != r.signum();) {
                        for (; r.isEven();) r.rShiftTo(1, r), e ? (i.isEven() && s.isEven() || (i.addTo(this, i), s.subTo(t, s)), i.rShiftTo(1, i)) : s.isEven() || s.subTo(t, s), s.rShiftTo(1, s);
                        for (; n.isEven();) n.rShiftTo(1, n), e ? (a.isEven() && o.isEven() || (a.addTo(this, a), o.subTo(t, o)), a.rShiftTo(1, a)) : o.isEven() || o.subTo(t, o), o.rShiftTo(1, o);
                        r.compareTo(n) >= 0 ? (r.subTo(n, r), e && i.subTo(a, i), s.subTo(o, s)) : (n.subTo(r, n), e && a.subTo(i, a), o.subTo(s, o))
                    }
                    return 0 != n.compareTo(C.ONE) ? C.ZERO : o.compareTo(t) >= 0 ? o.subtract(t) : o.signum() < 0 ? (o.addTo(t, o), o.signum() < 0 ? o.add(t) : o) : o
                }, C.prototype.pow = function(t) {
                    return this.exp(t, new V)
                }, C.prototype.gcd = function(t) {
                    var e = this.s < 0 ? this.negate() : this.clone(),
                        r = t.s < 0 ? t.negate() : t.clone();
                    if (e.compareTo(r) < 0) {
                        var n = e;
                        e = r, r = n
                    }
                    var i = e.getLowestSetBit(),
                        s = r.getLowestSetBit();
                    if (s < 0) return e;
                    for (i < s && (s = i), s > 0 && (e.rShiftTo(s, e), r.rShiftTo(s, r)); e.signum() > 0;)(i = e.getLowestSetBit()) > 0 && e.rShiftTo(i, e), (i = r.getLowestSetBit()) > 0 && r.rShiftTo(i, r), e.compareTo(r) >= 0 ? (e.subTo(r, e), e.rShiftTo(1, e)) : (r.subTo(e, r), r.rShiftTo(1, r));
                    return s > 0 && r.lShiftTo(s, r), r
                }, C.prototype.isProbablePrime = function(t) {
                    var e, r = this.abs();
                    if (1 == r.t && r[0] <= M[M.length - 1]) {
                        for (e = 0; e < M.length; ++e)
                            if (r[0] == M[e]) return !0;
                        return !1
                    }
                    if (r.isEven()) return !1;
                    for (e = 1; e < M.length;) {
                        for (var n = M[e], i = e + 1; i < M.length && n < K;) n *= M[i++];
                        for (n = r.modInt(n); e < i;)
                            if (n % M[e++] == 0) return !1
                    }
                    return r.millerRabin(t)
                }, C.prototype.square = function() {
                    var t = A();
                    return this.squareTo(t), t
                }, q.prototype.init = function(t) {
                    var e, r, n;
                    for (e = 0; e < 256; ++e) this.S[e] = e;
                    for (r = 0, e = 0; e < 256; ++e) r = r + this.S[e] + t[e % t.length] & 255, n = this.S[e], this.S[e] = this.S[r], this.S[r] = n;
                    this.i = 0, this.j = 0
                }, q.prototype.next = function() {
                    var t;
                    return this.i = this.i + 1 & 255, this.j = this.j + this.S[this.i] & 255, t = this.S[this.i], this.S[this.i] = this.S[this.j], this.S[this.j] = t, this.S[t + this.S[this.i] & 255]
                };
            var z, G, Y;
            /*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
             */
            function W() {
                ! function(t) {
                    G[Y++] ^= 255 & t, G[Y++] ^= t >> 8 & 255, G[Y++] ^= t >> 16 & 255, G[Y++] ^= t >> 24 & 255, Y >= 256 && (Y -= 256)
                }((new Date).getTime())
            }
            if (null == G) {
                var X;
                if (G = new Array, Y = 0, void 0 !== n && (void 0 !== n.crypto || void 0 !== n.msCrypto)) {
                    var Q = n.crypto || n.msCrypto;
                    if (Q.getRandomValues) {
                        var Z = new Uint8Array(32);
                        for (Q.getRandomValues(Z), X = 0; X < 32; ++X) G[Y++] = Z[X]
                    } else if ("Netscape" == r.appName && r.appVersion < "5") {
                        var J = n.crypto.random(32);
                        for (X = 0; X < J.length; ++X) G[Y++] = 255 & J.charCodeAt(X)
                    }
                }
                for (; Y < 256;) X = Math.floor(65536 * Math.random()), G[Y++] = X >>> 8, G[Y++] = 255 & X;
                Y = 0, W()
            }

            function $() {
                if (null == z) {
                    for (W(), (z = new q).init(G), Y = 0; Y < G.length; ++Y) G[Y] = 0;
                    Y = 0
                }
                return z.next()
            }

            function tt() {}
            /*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
             */
            function et(t, e) {
                return new C(t, e)
            }

            function rt(t, e, r) {
                for (var n = "", i = 0; n.length < e;) n += r(String.fromCharCode.apply(String, t.concat([(4278190080 & i) >> 24, (16711680 & i) >> 16, (65280 & i) >> 8, 255 & i]))), i += 1;
                return n
            }

            function nt() {
                this.n = null, this.e = 0, this.d = null, this.p = null, this.q = null, this.dmp1 = null, this.dmq1 = null, this.coeff = null
            }

            function it(t, e, r) {
                for (var n = "", i = 0; n.length < e;) n += r(t + String.fromCharCode.apply(String, [(4278190080 & i) >> 24, (16711680 & i) >> 16, (65280 & i) >> 8, 255 & i])), i += 1;
                return n
            }
            /*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
             */
            function st(t, e) {
                this.x = e, this.q = t
            }

            function at(t, e, r, n) {
                this.curve = t, this.x = e, this.y = r, this.z = null == n ? C.ONE : n, this.zinv = null
            }

            function ot(t, e, r) {
                this.q = t, this.a = this.fromBigInteger(e), this.b = this.fromBigInteger(r), this.infinity = new at(this, null, null)
            }
            tt.prototype.nextBytes = function(t) {
                    var e;
                    for (e = 0; e < t.length; ++e) t[e] = $()
                }, nt.prototype.doPublic = function(t) {
                    return t.modPowInt(this.e, this.n)
                }, nt.prototype.setPublic = function(t, e) {
                    if (this.isPublic = !0, this.isPrivate = !1, "string" != typeof t) this.n = t, this.e = e;
                    else {
                        if (!(null != t && null != e && t.length > 0 && e.length > 0)) throw "Invalid RSA public key";
                        this.n = et(t, 16), this.e = parseInt(e, 16)
                    }
                }, nt.prototype.encrypt = function(t) {
                    var e = function(t, e) {
                        if (e < t.length + 11) throw "Message too long for RSA";
                        for (var r = new Array, n = t.length - 1; n >= 0 && e > 0;) {
                            var i = t.charCodeAt(n--);
                            i < 128 ? r[--e] = i : i > 127 && i < 2048 ? (r[--e] = 63 & i | 128, r[--e] = i >> 6 | 192) : (r[--e] = 63 & i | 128, r[--e] = i >> 6 & 63 | 128, r[--e] = i >> 12 | 224)
                        }
                        r[--e] = 0;
                        for (var s = new tt, a = new Array; e > 2;) {
                            for (a[0] = 0; 0 == a[0];) s.nextBytes(a);
                            r[--e] = a[0]
                        }
                        return r[--e] = 2, r[--e] = 0, new C(r)
                    }(t, this.n.bitLength() + 7 >> 3);
                    if (null == e) return null;
                    var r = this.doPublic(e);
                    if (null == r) return null;
                    var n = r.toString(16);
                    return 0 == (1 & n.length) ? n : "0" + n
                }, nt.prototype.encryptOAEP = function(t, e, r) {
                    var n = function(t, e, r, n) {
                        var i = ct.crypto.MessageDigest,
                            s = ct.crypto.Util,
                            a = null;
                        if (r || (r = "sha1"), "string" == typeof r && (a = i.getCanonicalAlgName(r), n = i.getHashLength(a), r = function(t) {
                                return At(s.hashHex(wt(t), a))
                            }), t.length + 2 * n + 2 > e) throw "Message too long for RSA";
                        var o, u = "";
                        for (o = 0; o < e - t.length - 2 * n - 2; o += 1) u += "\0";
                        var c = r("") + u + "" + t,
                            h = new Array(n);
                        (new tt).nextBytes(h);
                        var l = rt(h, c.length, r),
                            f = [];
                        for (o = 0; o < c.length; o += 1) f[o] = c.charCodeAt(o) ^ l.charCodeAt(o);
                        var p = rt(f, h.length, r),
                            d = [0];
                        for (o = 0; o < h.length; o += 1) d[o + 1] = h[o] ^ p.charCodeAt(o);
                        return new C(d.concat(f))
                    }(t, this.n.bitLength() + 7 >> 3, e, r);
                    if (null == n) return null;
                    var i = this.doPublic(n);
                    if (null == i) return null;
                    var s = i.toString(16);
                    return 0 == (1 & s.length) ? s : "0" + s
                }, nt.prototype.type = "RSA", nt.prototype.doPrivate = function(t) {
                    if (null == this.p || null == this.q) return t.modPow(this.d, this.n);
                    for (var e = t.mod(this.p).modPow(this.dmp1, this.p), r = t.mod(this.q).modPow(this.dmq1, this.q); e.compareTo(r) < 0;) e = e.add(this.p);
                    return e.subtract(r).multiply(this.coeff).mod(this.p).multiply(this.q).add(r)
                }, nt.prototype.setPrivate = function(t, e, r) {
                    if (this.isPrivate = !0, "string" != typeof t) this.n = t, this.e = e, this.d = r;
                    else {
                        if (!(null != t && null != e && t.length > 0 && e.length > 0)) throw "Invalid RSA private key";
                        this.n = et(t, 16), this.e = parseInt(e, 16), this.d = et(r, 16)
                    }
                }, nt.prototype.setPrivateEx = function(t, e, r, n, i, s, a, o) {
                    if (this.isPrivate = !0, this.isPublic = !1, null == t) throw "RSASetPrivateEx N == null";
                    if (null == e) throw "RSASetPrivateEx E == null";
                    if (0 == t.length) throw "RSASetPrivateEx N.length == 0";
                    if (0 == e.length) throw "RSASetPrivateEx E.length == 0";
                    if (!(null != t && null != e && t.length > 0 && e.length > 0)) throw "Invalid RSA private key in RSASetPrivateEx";
                    this.n = et(t, 16), this.e = parseInt(e, 16), this.d = et(r, 16), this.p = et(n, 16), this.q = et(i, 16), this.dmp1 = et(s, 16), this.dmq1 = et(a, 16), this.coeff = et(o, 16)
                }, nt.prototype.generate = function(t, e) {
                    var r = new tt,
                        n = t >> 1;
                    this.e = parseInt(e, 16);
                    for (var i = new C(e, 16);;) {
                        for (; this.p = new C(t - n, 1, r), 0 != this.p.subtract(C.ONE).gcd(i).compareTo(C.ONE) || !this.p.isProbablePrime(10););
                        for (; this.q = new C(n, 1, r), 0 != this.q.subtract(C.ONE).gcd(i).compareTo(C.ONE) || !this.q.isProbablePrime(10););
                        if (this.p.compareTo(this.q) <= 0) {
                            var s = this.p;
                            this.p = this.q, this.q = s
                        }
                        var a = this.p.subtract(C.ONE),
                            o = this.q.subtract(C.ONE),
                            u = a.multiply(o);
                        if (0 == u.gcd(i).compareTo(C.ONE) && (this.n = this.p.multiply(this.q), this.n.bitLength() == t)) {
                            this.d = i.modInverse(u), this.dmp1 = this.d.mod(a), this.dmq1 = this.d.mod(o), this.coeff = this.q.modInverse(this.p);
                            break
                        }
                    }
                    this.isPrivate = !0
                }, nt.prototype.decrypt = function(t) {
                    if (t.length != Math.ceil(this.n.bitLength() / 4)) throw new Error("wrong ctext length");
                    var e = et(t, 16),
                        r = this.doPrivate(e);
                    return null == r ? null :
                        /*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
                         */
                        function(t, e) {
                            for (var r = t.toByteArray(), n = 0; n < r.length && 0 == r[n];) ++n;
                            if (r.length - n != e - 1 || 2 != r[n]) return null;
                            for (++n; 0 != r[n];)
                                if (++n >= r.length) return null;
                            for (var i = ""; ++n < r.length;) {
                                var s = 255 & r[n];
                                s < 128 ? i += String.fromCharCode(s) : s > 191 && s < 224 ? (i += String.fromCharCode((31 & s) << 6 | 63 & r[n + 1]), ++n) : (i += String.fromCharCode((15 & s) << 12 | (63 & r[n + 1]) << 6 | 63 & r[n + 2]), n += 2)
                            }
                            return i
                        }(r, this.n.bitLength() + 7 >> 3)
                }, nt.prototype.decryptOAEP = function(t, e, r) {
                    if (t.length != Math.ceil(this.n.bitLength() / 4)) throw new Error("wrong ctext length");
                    var n = et(t, 16),
                        i = this.doPrivate(n);
                    return null == i ? null : function(t, e, r, n) {
                        var i = ct.crypto.MessageDigest,
                            s = ct.crypto.Util,
                            a = null;
                        for (r || (r = "sha1"), "string" == typeof r && (a = i.getCanonicalAlgName(r), n = i.getHashLength(a), r = function(t) {
                                return At(s.hashHex(wt(t), a))
                            }), t = t.toByteArray(), o = 0; o < t.length; o += 1) t[o] &= 255;
                        for (; t.length < e;) t.unshift(0);
                        if ((t = String.fromCharCode.apply(String, t)).length < 2 * n + 2) throw "Cipher too short";
                        var o, u = t.substr(1, n),
                            c = t.substr(n + 1),
                            h = it(c, n, r),
                            l = [];
                        for (o = 0; o < u.length; o += 1) l[o] = u.charCodeAt(o) ^ h.charCodeAt(o);
                        var f = it(String.fromCharCode.apply(String, l), t.length - n, r),
                            p = [];
                        for (o = 0; o < c.length; o += 1) p[o] = c.charCodeAt(o) ^ f.charCodeAt(o);
                        if ((p = String.fromCharCode.apply(String, p)).substr(0, n) !== r("")) throw "Hash mismatch";
                        var d = (p = p.substr(n)).indexOf("");
                        if ((-1 != d ? p.substr(0, d).lastIndexOf("\0") : -1) + 1 != d) throw "Malformed data";
                        return p.substr(d + 1)
                    }(i, this.n.bitLength() + 7 >> 3, e, r)
                }, st.prototype.equals = function(t) {
                    return t == this || this.q.equals(t.q) && this.x.equals(t.x)
                }, st.prototype.toBigInteger = function() {
                    return this.x
                }, st.prototype.negate = function() {
                    return new st(this.q, this.x.negate().mod(this.q))
                }, st.prototype.add = function(t) {
                    return new st(this.q, this.x.add(t.toBigInteger()).mod(this.q))
                }, st.prototype.subtract = function(t) {
                    return new st(this.q, this.x.subtract(t.toBigInteger()).mod(this.q))
                }, st.prototype.multiply = function(t) {
                    return new st(this.q, this.x.multiply(t.toBigInteger()).mod(this.q))
                }, st.prototype.square = function() {
                    return new st(this.q, this.x.square().mod(this.q))
                }, st.prototype.divide = function(t) {
                    return new st(this.q, this.x.multiply(t.toBigInteger().modInverse(this.q)).mod(this.q))
                }, at.prototype.getX = function() {
                    return null == this.zinv && (this.zinv = this.z.modInverse(this.curve.q)), this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))
                }, at.prototype.getY = function() {
                    return null == this.zinv && (this.zinv = this.z.modInverse(this.curve.q)), this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))
                }, at.prototype.equals = function(t) {
                    return t == this || (this.isInfinity() ? t.isInfinity() : t.isInfinity() ? this.isInfinity() : !!t.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(t.z)).mod(this.curve.q).equals(C.ZERO) && t.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(t.z)).mod(this.curve.q).equals(C.ZERO))
                }, at.prototype.isInfinity = function() {
                    return null == this.x && null == this.y || this.z.equals(C.ZERO) && !this.y.toBigInteger().equals(C.ZERO)
                }, at.prototype.negate = function() {
                    return new at(this.curve, this.x, this.y.negate(), this.z)
                }, at.prototype.add = function(t) {
                    if (this.isInfinity()) return t;
                    if (t.isInfinity()) return this;
                    var e = t.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(t.z)).mod(this.curve.q),
                        r = t.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(t.z)).mod(this.curve.q);
                    if (C.ZERO.equals(r)) return C.ZERO.equals(e) ? this.twice() : this.curve.getInfinity();
                    var n = new C("3"),
                        i = this.x.toBigInteger(),
                        s = this.y.toBigInteger(),
                        a = (t.x.toBigInteger(), t.y.toBigInteger(), r.square()),
                        o = a.multiply(r),
                        u = i.multiply(a),
                        c = e.square().multiply(this.z),
                        h = c.subtract(u.shiftLeft(1)).multiply(t.z).subtract(o).multiply(r).mod(this.curve.q),
                        l = u.multiply(n).multiply(e).subtract(s.multiply(o)).subtract(c.multiply(e)).multiply(t.z).add(e.multiply(o)).mod(this.curve.q),
                        f = o.multiply(this.z).multiply(t.z).mod(this.curve.q);
                    return new at(this.curve, this.curve.fromBigInteger(h), this.curve.fromBigInteger(l), f)
                }, at.prototype.twice = function() {
                    if (this.isInfinity()) return this;
                    if (0 == this.y.toBigInteger().signum()) return this.curve.getInfinity();
                    var t = new C("3"),
                        e = this.x.toBigInteger(),
                        r = this.y.toBigInteger(),
                        n = r.multiply(this.z),
                        i = n.multiply(r).mod(this.curve.q),
                        s = this.curve.a.toBigInteger(),
                        a = e.square().multiply(t);
                    C.ZERO.equals(s) || (a = a.add(this.z.square().multiply(s)));
                    var o = (a = a.mod(this.curve.q)).square().subtract(e.shiftLeft(3).multiply(i)).shiftLeft(1).multiply(n).mod(this.curve.q),
                        u = a.multiply(t).multiply(e).subtract(i.shiftLeft(1)).shiftLeft(2).multiply(i).subtract(a.square().multiply(a)).mod(this.curve.q),
                        c = n.square().multiply(n).shiftLeft(3).mod(this.curve.q);
                    return new at(this.curve, this.curve.fromBigInteger(o), this.curve.fromBigInteger(u), c)
                }, at.prototype.multiply = function(t) {
                    if (this.isInfinity()) return this;
                    if (0 == t.signum()) return this.curve.getInfinity();
                    var e, r = t,
                        n = r.multiply(new C("3")),
                        i = this.negate(),
                        s = this,
                        a = this.curve.q.subtract(t),
                        o = a.multiply(new C("3")),
                        u = new at(this.curve, this.x, this.y),
                        c = u.negate();
                    for (e = n.bitLength() - 2; e > 0; --e) {
                        s = s.twice();
                        var h = n.testBit(e);
                        h != r.testBit(e) && (s = s.add(h ? this : i))
                    }
                    for (e = o.bitLength() - 2; e > 0; --e) {
                        u = u.twice();
                        var l = o.testBit(e);
                        l != a.testBit(e) && (u = u.add(l ? u : c))
                    }
                    return s
                }, at.prototype.multiplyTwo = function(t, e, r) {
                    var n;
                    n = t.bitLength() > r.bitLength() ? t.bitLength() - 1 : r.bitLength() - 1;
                    for (var i = this.curve.getInfinity(), s = this.add(e); n >= 0;) i = i.twice(), t.testBit(n) ? i = r.testBit(n) ? i.add(s) : i.add(this) : r.testBit(n) && (i = i.add(e)), --n;
                    return i
                }, ot.prototype.getQ = function() {
                    return this.q
                }, ot.prototype.getA = function() {
                    return this.a
                }, ot.prototype.getB = function() {
                    return this.b
                }, ot.prototype.equals = function(t) {
                    return t == this || this.q.equals(t.q) && this.a.equals(t.a) && this.b.equals(t.b)
                }, ot.prototype.getInfinity = function() {
                    return this.infinity
                }, ot.prototype.fromBigInteger = function(t) {
                    return new st(this.q, t)
                }, ot.prototype.decodePointHex = function(t) {
                    switch (parseInt(t.substr(0, 2), 16)) {
                        case 0:
                            return this.infinity;
                        case 2:
                        case 3:
                            return null;
                        case 4:
                        case 6:
                        case 7:
                            var e = (t.length - 2) / 2,
                                r = t.substr(2, e),
                                n = t.substr(e + 2, e);
                            return new at(this, this.fromBigInteger(new C(r, 16)), this.fromBigInteger(new C(n, 16)));
                        default:
                            return null
                    }
                },
                /*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
                 */
                st.prototype.getByteLength = function() {
                    return Math.floor((this.toBigInteger().bitLength() + 7) / 8)
                }, at.prototype.getEncoded = function(t) {
                    var e = function(t, e) {
                            var r = t.toByteArrayUnsigned();
                            if (e < r.length) r = r.slice(r.length - e);
                            else
                                for (; e > r.length;) r.unshift(0);
                            return r
                        },
                        r = this.getX().toBigInteger(),
                        n = this.getY().toBigInteger(),
                        i = e(r, 32);
                    return t ? n.isEven() ? i.unshift(2) : i.unshift(3) : (i.unshift(4), i = i.concat(e(n, 32))), i
                }, at.decodeFrom = function(t, e) {
                    e[0];
                    var r = e.length - 1,
                        n = e.slice(1, 1 + r / 2),
                        i = e.slice(1 + r / 2, 1 + r);
                    n.unshift(0), i.unshift(0);
                    var s = new C(n),
                        a = new C(i);
                    return new at(t, t.fromBigInteger(s), t.fromBigInteger(a))
                }, at.decodeFromHex = function(t, e) {
                    e.substr(0, 2);
                    var r = e.length - 2,
                        n = e.substr(2, r / 2),
                        i = e.substr(2 + r / 2, r / 2),
                        s = new C(n, 16),
                        a = new C(i, 16);
                    return new at(t, t.fromBigInteger(s), t.fromBigInteger(a))
                }, at.prototype.add2D = function(t) {
                    if (this.isInfinity()) return t;
                    if (t.isInfinity()) return this;
                    if (this.x.equals(t.x)) return this.y.equals(t.y) ? this.twice() : this.curve.getInfinity();
                    var e = t.x.subtract(this.x),
                        r = t.y.subtract(this.y).divide(e),
                        n = r.square().subtract(this.x).subtract(t.x),
                        i = r.multiply(this.x.subtract(n)).subtract(this.y);
                    return new at(this.curve, n, i)
                }, at.prototype.twice2D = function() {
                    if (this.isInfinity()) return this;
                    if (0 == this.y.toBigInteger().signum()) return this.curve.getInfinity();
                    var t = this.curve.fromBigInteger(C.valueOf(2)),
                        e = this.curve.fromBigInteger(C.valueOf(3)),
                        r = this.x.square().multiply(e).add(this.curve.a).divide(this.y.multiply(t)),
                        n = r.square().subtract(this.x.multiply(t)),
                        i = r.multiply(this.x.subtract(n)).subtract(this.y);
                    return new at(this.curve, n, i)
                }, at.prototype.multiply2D = function(t) {
                    if (this.isInfinity()) return this;
                    if (0 == t.signum()) return this.curve.getInfinity();
                    var e, r = t,
                        n = r.multiply(new C("3")),
                        i = this.negate(),
                        s = this;
                    for (e = n.bitLength() - 2; e > 0; --e) {
                        s = s.twice();
                        var a = n.testBit(e);
                        a != r.testBit(e) && (s = s.add2D(a ? this : i))
                    }
                    return s
                }, at.prototype.isOnCurve = function() {
                    var t = this.getX().toBigInteger(),
                        e = this.getY().toBigInteger(),
                        r = this.curve.getA().toBigInteger(),
                        n = this.curve.getB().toBigInteger(),
                        i = this.curve.getQ(),
                        s = e.multiply(e).mod(i),
                        a = t.multiply(t).multiply(t).add(r.multiply(t)).add(n).mod(i);
                    return s.equals(a)
                }, at.prototype.toString = function() {
                    return "(" + this.getX().toBigInteger().toString() + "," + this.getY().toBigInteger().toString() + ")"
                }, at.prototype.validate = function() {
                    var t = this.curve.getQ();
                    if (this.isInfinity()) throw new Error("Point is at infinity.");
                    var e = this.getX().toBigInteger(),
                        r = this.getY().toBigInteger();
                    if (e.compareTo(C.ONE) < 0 || e.compareTo(t.subtract(C.ONE)) > 0) throw new Error("x coordinate out of bounds");
                    if (r.compareTo(C.ONE) < 0 || r.compareTo(t.subtract(C.ONE)) > 0) throw new Error("y coordinate out of bounds");
                    if (!this.isOnCurve()) throw new Error("Point is not on the curve.");
                    if (this.multiply(t).isInfinity()) throw new Error("Point is not a scalar multiple of G.");
                    return !0
                };
            /*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
             */
            var ut = function() {
                var t = new RegExp('(?:false|true|null|[\\{\\}\\[\\]]|(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)|(?:"(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))*"))', "g"),
                    e = new RegExp("\\\\(?:([^u])|u(.{4}))", "g"),
                    r = {
                        '"': '"',
                        "/": "/",
                        "\\": "\\",
                        b: "\b",
                        f: "\f",
                        n: "\n",
                        r: "\r",
                        t: "\t"
                    };

                function n(t, e, n) {
                    return e ? r[e] : String.fromCharCode(parseInt(n, 16))
                }
                var i = new String(""),
                    s = Object.hasOwnProperty;
                return function(r, a) {
                    var o, u, c = r.match(t),
                        h = c[0],
                        l = !1;
                    "{" === h ? o = {} : "[" === h ? o = [] : (o = [], l = !0);
                    for (var f = [o], p = 1 - l, d = c.length; p < d; ++p) {
                        var g;
                        switch ((h = c[p]).charCodeAt(0)) {
                            default: (g = f[0])[u || g.length] = +h,
                            u = void 0;
                            break;
                            case 34:
                                    if (-1 !== (h = h.substring(1, h.length - 1)).indexOf("\\") && (h = h.replace(e, n)), g = f[0], !u) {
                                    if (!(g instanceof Array)) {
                                        u = h || i;
                                        break
                                    }
                                    u = g.length
                                }g[u] = h,
                                u = void 0;
                                break;
                            case 91:
                                    g = f[0],
                                f.unshift(g[u || g.length] = []),
                                u = void 0;
                                break;
                            case 93:
                                    f.shift();
                                break;
                            case 102:
                                    (g = f[0])[u || g.length] = !1,
                                u = void 0;
                                break;
                            case 110:
                                    (g = f[0])[u || g.length] = null,
                                u = void 0;
                                break;
                            case 116:
                                    (g = f[0])[u || g.length] = !0,
                                u = void 0;
                                break;
                            case 123:
                                    g = f[0],
                                f.unshift(g[u || g.length] = {}),
                                u = void 0;
                                break;
                            case 125:
                                    f.shift()
                        }
                    }
                    if (l) {
                        if (1 !== f.length) throw new Error;
                        o = o[0]
                    } else if (f.length) throw new Error;
                    if (a) {
                        var y = function(t, e) {
                            var r = t[e];
                            if (r && "object" == typeof r) {
                                var n = null;
                                for (var i in r)
                                    if (s.call(r, i) && r !== t) {
                                        var o = y(r, i);
                                        void 0 !== o ? r[i] = o : (n || (n = []), n.push(i))
                                    }
                                if (n)
                                    for (var u = n.length; --u >= 0;) delete r[n[u]]
                            }
                            return a.call(t, e, r)
                        };
                        o = y({
                            "": o
                        }, "")
                    }
                    return o
                }
            }();
            void 0 !== ct && ct || (ct = {}), void 0 !== ct.asn1 && ct.asn1 || (ct.asn1 = {}), ct.asn1.ASN1Util = new function() {
                this.integerToByteHex = function(t) {
                    var e = t.toString(16);
                    return e.length % 2 == 1 && (e = "0" + e), e
                }, this.bigIntToMinTwosComplementsHex = function(t) {
                    var e = t.toString(16);
                    if ("-" != e.substr(0, 1)) e.length % 2 == 1 ? e = "0" + e : e.match(/^[0-7]/) || (e = "00" + e);
                    else {
                        var r = e.substr(1).length;
                        r % 2 == 1 ? r += 1 : e.match(/^[0-7]/) || (r += 2);
                        for (var n = "", i = 0; i < r; i++) n += "f";
                        e = new C(n, 16).xor(t).add(C.ONE).toString(16).replace(/^-/, "")
                    }
                    return e
                }, this.getPEMStringFromHex = function(t, e) {
                    return Bt(t, e)
                }, this.newObject = function(t) {
                    var e = ct.asn1,
                        r = e.DERBoolean,
                        n = e.DERInteger,
                        i = e.DERBitString,
                        s = e.DEROctetString,
                        a = e.DERNull,
                        o = e.DERObjectIdentifier,
                        u = e.DEREnumerated,
                        c = e.DERUTF8String,
                        h = e.DERNumericString,
                        l = e.DERPrintableString,
                        f = e.DERTeletexString,
                        p = e.DERIA5String,
                        d = e.DERUTCTime,
                        g = e.DERGeneralizedTime,
                        y = e.DERVisibleString,
                        v = e.DERBMPString,
                        m = e.DERSequence,
                        E = e.DERSet,
                        S = e.DERTaggedObject,
                        b = e.ASN1Util.newObject;
                    if (t instanceof e.ASN1Object) return t;
                    var C = Object.keys(t);
                    if (1 != C.length) throw new Error("key of param shall be only one.");
                    var A = C[0];
                    if (-1 == ":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:visstr:bmpstr:seq:set:tag:".indexOf(":" + A + ":")) throw new Error("undefined key: " + A);
                    if ("bool" == A) return new r(t[A]);
                    if ("int" == A) return new n(t[A]);
                    if ("bitstr" == A) return new i(t[A]);
                    if ("octstr" == A) return new s(t[A]);
                    if ("null" == A) return new a(t[A]);
                    if ("oid" == A) return new o(t[A]);
                    if ("enum" == A) return new u(t[A]);
                    if ("utf8str" == A) return new c(t[A]);
                    if ("numstr" == A) return new h(t[A]);
                    if ("prnstr" == A) return new l(t[A]);
                    if ("telstr" == A) return new f(t[A]);
                    if ("ia5str" == A) return new p(t[A]);
                    if ("utctime" == A) return new d(t[A]);
                    if ("gentime" == A) return new g(t[A]);
                    if ("visstr" == A) return new y(t[A]);
                    if ("bmpstr" == A) return new v(t[A]);
                    if ("seq" == A) {
                        for (var w = t[A], T = [], x = 0; x < w.length; x++) {
                            var I = b(w[x]);
                            T.push(I)
                        }
                        return new m({
                            array: T
                        })
                    }
                    if ("set" == A) {
                        for (w = t[A], T = [], x = 0; x < w.length; x++) {
                            I = b(w[x]);
                            T.push(I)
                        }
                        return new E({
                            array: T
                        })
                    }
                    if ("tag" == A) {
                        var B = t[A];
                        if ("[object Array]" === Object.prototype.toString.call(B) && 3 == B.length) {
                            var F = b(B[2]);
                            return new S({
                                tag: B[0],
                                explicit: B[1],
                                obj: F
                            })
                        }
                        var R = {};
                        if (void 0 !== B.explicit && (R.explicit = B.explicit), void 0 !== B.tag && (R.tag = B.tag), void 0 === B.obj) throw "obj shall be specified for 'tag'.";
                        return R.obj = b(B.obj), new S(R)
                    }
                }, this.jsonToASN1HEX = function(t) {
                    return this.newObject(t).getEncodedHex()
                }
            }, ct.asn1.ASN1Util.oidHexToInt = function(t) {
                for (var e = "", r = parseInt(t.substr(0, 2), 16), n = (e = Math.floor(r / 40) + "." + r % 40, ""), i = 2; i < t.length; i += 2) {
                    var s = ("00000000" + parseInt(t.substr(i, 2), 16).toString(2)).slice(-8);
                    if (n += s.substr(1, 7), "0" == s.substr(0, 1)) e = e + "." + new C(n, 2).toString(10), n = ""
                }
                return e
            }, ct.asn1.ASN1Util.oidIntToHex = function(t) {
                var e = function(t) {
                        var e = t.toString(16);
                        return 1 == e.length && (e = "0" + e), e
                    },
                    r = function(t) {
                        var r = "",
                            n = new C(t, 10).toString(2),
                            i = 7 - n.length % 7;
                        7 == i && (i = 0);
                        for (var s = "", a = 0; a < i; a++) s += "0";
                        n = s + n;
                        for (a = 0; a < n.length - 1; a += 7) {
                            var o = n.substr(a, 7);
                            a != n.length - 7 && (o = "1" + o), r += e(parseInt(o, 2))
                        }
                        return r
                    };
                if (!t.match(/^[0-9.]+$/)) throw "malformed oid string: " + t;
                var n = "",
                    i = t.split("."),
                    s = 40 * parseInt(i[0]) + parseInt(i[1]);
                n += e(s), i.splice(0, 2);
                for (var a = 0; a < i.length; a++) n += r(i[a]);
                return n
            }, ct.asn1.ASN1Object = function(t) {
                this.getLengthHexFromValue = function() {
                    if (void 0 === this.hV || null == this.hV) throw new Error("this.hV is null or undefined");
                    if (this.hV.length % 2 == 1) throw new Error("value hex must be even length: n=" + "".length + ",v=" + this.hV);
                    var t = this.hV.length / 2,
                        e = t.toString(16);
                    if (e.length % 2 == 1 && (e = "0" + e), t < 128) return e;
                    var r = e.length / 2;
                    if (r > 15) throw "ASN.1 length too long to represent by 8x: n = " + t.toString(16);
                    return (128 + r).toString(16) + e
                }, this.getEncodedHex = function() {
                    return (null == this.hTLV || this.isModified) && (this.hV = this.getFreshValueHex(), this.hL = this.getLengthHexFromValue(), this.hTLV = this.hT + this.hL + this.hV, this.isModified = !1), this.hTLV
                }, this.getValueHex = function() {
                    return this.getEncodedHex(), this.hV
                }, this.getFreshValueHex = function() {
                    return ""
                }, null != t && null != t.tlv && (this.hTLV = t.tlv, this.isModified = !1)
            }, ct.asn1.DERAbstractString = function(t) {
                ct.asn1.DERAbstractString.superclass.constructor.call(this);
                this.getString = function() {
                    return this.s
                }, this.setString = function(t) {
                    this.hTLV = null, this.isModified = !0, this.s = t, this.hV = bt(this.s).toLowerCase()
                }, this.setStringHex = function(t) {
                    this.hTLV = null, this.isModified = !0, this.s = null, this.hV = t
                }, this.getFreshValueHex = function() {
                    return this.hV
                }, void 0 !== t && ("string" == typeof t ? this.setString(t) : void 0 !== t.str ? this.setString(t.str) : void 0 !== t.hex && this.setStringHex(t.hex))
            }, i.lang.extend(ct.asn1.DERAbstractString, ct.asn1.ASN1Object), ct.asn1.DERAbstractTime = function(t) {
                ct.asn1.DERAbstractTime.superclass.constructor.call(this);
                this.localDateToUTC = function(t) {
                    var e = t.getTime() + 6e4 * t.getTimezoneOffset();
                    return new Date(e)
                }, this.formatDate = function(t, e, r) {
                    var n = this.zeroPadding,
                        i = this.localDateToUTC(t),
                        s = String(i.getFullYear());
                    "utc" == e && (s = s.substr(2, 2));
                    var a = s + n(String(i.getMonth() + 1), 2) + n(String(i.getDate()), 2) + n(String(i.getHours()), 2) + n(String(i.getMinutes()), 2) + n(String(i.getSeconds()), 2);
                    if (!0 === r) {
                        var o = i.getMilliseconds();
                        if (0 != o) {
                            var u = n(String(o), 3);
                            a = a + "." + (u = u.replace(/[0]+$/, ""))
                        }
                    }
                    return a + "Z"
                }, this.zeroPadding = function(t, e) {
                    return t.length >= e ? t : new Array(e - t.length + 1).join("0") + t
                }, this.getString = function() {
                    return this.s
                }, this.setString = function(t) {
                    this.hTLV = null, this.isModified = !0, this.s = t, this.hV = yt(t)
                }, this.setByDateValue = function(t, e, r, n, i, s) {
                    var a = new Date(Date.UTC(t, e - 1, r, n, i, s, 0));
                    this.setByDate(a)
                }, this.getFreshValueHex = function() {
                    return this.hV
                }
            }, i.lang.extend(ct.asn1.DERAbstractTime, ct.asn1.ASN1Object), ct.asn1.DERAbstractStructured = function(t) {
                ct.asn1.DERAbstractString.superclass.constructor.call(this);
                this.setByASN1ObjectArray = function(t) {
                    this.hTLV = null, this.isModified = !0, this.asn1Array = t
                }, this.appendASN1Object = function(t) {
                    this.hTLV = null, this.isModified = !0, this.asn1Array.push(t)
                }, this.asn1Array = new Array, void 0 !== t && void 0 !== t.array && (this.asn1Array = t.array)
            }, i.lang.extend(ct.asn1.DERAbstractStructured, ct.asn1.ASN1Object), ct.asn1.DERBoolean = function() {
                ct.asn1.DERBoolean.superclass.constructor.call(this), this.hT = "01", this.hTLV = "0101ff"
            }, i.lang.extend(ct.asn1.DERBoolean, ct.asn1.ASN1Object), ct.asn1.DERInteger = function(t) {
                ct.asn1.DERInteger.superclass.constructor.call(this), this.hT = "02", this.setByBigInteger = function(t) {
                    this.hTLV = null, this.isModified = !0, this.hV = ct.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t)
                }, this.setByInteger = function(t) {
                    var e = new C(String(t), 10);
                    this.setByBigInteger(e)
                }, this.setValueHex = function(t) {
                    this.hV = t
                }, this.getFreshValueHex = function() {
                    return this.hV
                }, void 0 !== t && (void 0 !== t.bigint ? this.setByBigInteger(t.bigint) : void 0 !== t.int ? this.setByInteger(t.int) : "number" == typeof t ? this.setByInteger(t) : void 0 !== t.hex && this.setValueHex(t.hex))
            }, i.lang.extend(ct.asn1.DERInteger, ct.asn1.ASN1Object), ct.asn1.DERBitString = function(t) {
                if (void 0 !== t && void 0 !== t.obj) {
                    var e = ct.asn1.ASN1Util.newObject(t.obj);
                    t.hex = "00" + e.getEncodedHex()
                }
                ct.asn1.DERBitString.superclass.constructor.call(this), this.hT = "03", this.setHexValueIncludingUnusedBits = function(t) {
                    this.hTLV = null, this.isModified = !0, this.hV = t
                }, this.setUnusedBitsAndHexValue = function(t, e) {
                    if (t < 0 || 7 < t) throw "unused bits shall be from 0 to 7: u = " + t;
                    var r = "0" + t;
                    this.hTLV = null, this.isModified = !0, this.hV = r + e
                }, this.setByBinaryString = function(t) {
                    var e = 8 - (t = t.replace(/0+$/, "")).length % 8;
                    8 == e && (e = 0);
                    for (var r = 0; r <= e; r++) t += "0";
                    var n = "";
                    for (r = 0; r < t.length - 1; r += 8) {
                        var i = t.substr(r, 8),
                            s = parseInt(i, 2).toString(16);
                        1 == s.length && (s = "0" + s), n += s
                    }
                    this.hTLV = null, this.isModified = !0, this.hV = "0" + e + n
                }, this.setByBooleanArray = function(t) {
                    for (var e = "", r = 0; r < t.length; r++) 1 == t[r] ? e += "1" : e += "0";
                    this.setByBinaryString(e)
                }, this.newFalseArray = function(t) {
                    for (var e = new Array(t), r = 0; r < t; r++) e[r] = !1;
                    return e
                }, this.getFreshValueHex = function() {
                    return this.hV
                }, void 0 !== t && ("string" == typeof t && t.toLowerCase().match(/^[0-9a-f]+$/) ? this.setHexValueIncludingUnusedBits(t) : void 0 !== t.hex ? this.setHexValueIncludingUnusedBits(t.hex) : void 0 !== t.bin ? this.setByBinaryString(t.bin) : void 0 !== t.array && this.setByBooleanArray(t.array))
            }, i.lang.extend(ct.asn1.DERBitString, ct.asn1.ASN1Object), ct.asn1.DEROctetString = function(t) {
                if (void 0 !== t && void 0 !== t.obj) {
                    var e = ct.asn1.ASN1Util.newObject(t.obj);
                    t.hex = e.getEncodedHex()
                }
                ct.asn1.DEROctetString.superclass.constructor.call(this, t), this.hT = "04"
            }, i.lang.extend(ct.asn1.DEROctetString, ct.asn1.DERAbstractString), ct.asn1.DERNull = function() {
                ct.asn1.DERNull.superclass.constructor.call(this), this.hT = "05", this.hTLV = "0500"
            }, i.lang.extend(ct.asn1.DERNull, ct.asn1.ASN1Object), ct.asn1.DERObjectIdentifier = function(t) {
                var e = function(t) {
                        var e = t.toString(16);
                        return 1 == e.length && (e = "0" + e), e
                    },
                    r = function(t) {
                        var r = "",
                            n = new C(t, 10).toString(2),
                            i = 7 - n.length % 7;
                        7 == i && (i = 0);
                        for (var s = "", a = 0; a < i; a++) s += "0";
                        n = s + n;
                        for (a = 0; a < n.length - 1; a += 7) {
                            var o = n.substr(a, 7);
                            a != n.length - 7 && (o = "1" + o), r += e(parseInt(o, 2))
                        }
                        return r
                    };
                ct.asn1.DERObjectIdentifier.superclass.constructor.call(this), this.hT = "06", this.setValueHex = function(t) {
                    this.hTLV = null, this.isModified = !0, this.s = null, this.hV = t
                }, this.setValueOidString = function(t) {
                    if (!t.match(/^[0-9.]+$/)) throw new Error("malformed oid string: " + t);
                    var n = "",
                        i = t.split("."),
                        s = 40 * parseInt(i[0]) + parseInt(i[1]);
                    n += e(s), i.splice(0, 2);
                    for (var a = 0; a < i.length; a++) n += r(i[a]);
                    this.hTLV = null, this.isModified = !0, this.s = null, this.hV = n
                }, this.setValueName = function(t) {
                    var e = ct.asn1.x509.OID.name2oid(t);
                    if ("" === e) throw new Error("DERObjectIdentifier oidName undefined: " + t);
                    this.setValueOidString(e)
                }, this.getFreshValueHex = function() {
                    return this.hV
                }, void 0 !== t && ("string" == typeof t ? t.match(/^[0-2].[0-9.]+$/) ? this.setValueOidString(t) : this.setValueName(t) : void 0 !== t.oid ? this.setValueOidString(t.oid) : void 0 !== t.hex ? this.setValueHex(t.hex) : void 0 !== t.name && this.setValueName(t.name))
            }, i.lang.extend(ct.asn1.DERObjectIdentifier, ct.asn1.ASN1Object), ct.asn1.DEREnumerated = function(t) {
                ct.asn1.DEREnumerated.superclass.constructor.call(this), this.hT = "0a", this.setByBigInteger = function(t) {
                    this.hTLV = null, this.isModified = !0, this.hV = ct.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t)
                }, this.setByInteger = function(t) {
                    var e = new C(String(t), 10);
                    this.setByBigInteger(e)
                }, this.setValueHex = function(t) {
                    this.hV = t
                }, this.getFreshValueHex = function() {
                    return this.hV
                }, void 0 !== t && (void 0 !== t.int ? this.setByInteger(t.int) : "number" == typeof t ? this.setByInteger(t) : void 0 !== t.hex && this.setValueHex(t.hex))
            }, i.lang.extend(ct.asn1.DEREnumerated, ct.asn1.ASN1Object), ct.asn1.DERUTF8String = function(t) {
                ct.asn1.DERUTF8String.superclass.constructor.call(this, t), this.hT = "0c"
            }, i.lang.extend(ct.asn1.DERUTF8String, ct.asn1.DERAbstractString), ct.asn1.DERNumericString = function(t) {
                ct.asn1.DERNumericString.superclass.constructor.call(this, t), this.hT = "12"
            }, i.lang.extend(ct.asn1.DERNumericString, ct.asn1.DERAbstractString), ct.asn1.DERPrintableString = function(t) {
                ct.asn1.DERPrintableString.superclass.constructor.call(this, t), this.hT = "13"
            }, i.lang.extend(ct.asn1.DERPrintableString, ct.asn1.DERAbstractString), ct.asn1.DERTeletexString = function(t) {
                ct.asn1.DERTeletexString.superclass.constructor.call(this, t), this.hT = "14"
            }, i.lang.extend(ct.asn1.DERTeletexString, ct.asn1.DERAbstractString), ct.asn1.DERIA5String = function(t) {
                ct.asn1.DERIA5String.superclass.constructor.call(this, t), this.hT = "16"
            }, i.lang.extend(ct.asn1.DERIA5String, ct.asn1.DERAbstractString), ct.asn1.DERVisibleString = function(t) {
                ct.asn1.DERIA5String.superclass.constructor.call(this, t), this.hT = "1a"
            }, i.lang.extend(ct.asn1.DERVisibleString, ct.asn1.DERAbstractString), ct.asn1.DERBMPString = function(t) {
                ct.asn1.DERBMPString.superclass.constructor.call(this, t), this.hT = "1e"
            }, i.lang.extend(ct.asn1.DERBMPString, ct.asn1.DERAbstractString), ct.asn1.DERUTCTime = function(t) {
                ct.asn1.DERUTCTime.superclass.constructor.call(this, t), this.hT = "17", this.setByDate = function(t) {
                    this.hTLV = null, this.isModified = !0, this.date = t, this.s = this.formatDate(this.date, "utc"), this.hV = yt(this.s)
                }, this.getFreshValueHex = function() {
                    return void 0 === this.date && void 0 === this.s && (this.date = new Date, this.s = this.formatDate(this.date, "utc"), this.hV = yt(this.s)), this.hV
                }, void 0 !== t && (void 0 !== t.str ? this.setString(t.str) : "string" == typeof t && t.match(/^[0-9]{12}Z$/) ? this.setString(t) : void 0 !== t.hex ? this.setStringHex(t.hex) : void 0 !== t.date && this.setByDate(t.date))
            }, i.lang.extend(ct.asn1.DERUTCTime, ct.asn1.DERAbstractTime), ct.asn1.DERGeneralizedTime = function(t) {
                ct.asn1.DERGeneralizedTime.superclass.constructor.call(this, t), this.hT = "18", this.withMillis = !1, this.setByDate = function(t) {
                    this.hTLV = null, this.isModified = !0, this.date = t, this.s = this.formatDate(this.date, "gen", this.withMillis), this.hV = yt(this.s)
                }, this.getFreshValueHex = function() {
                    return void 0 === this.date && void 0 === this.s && (this.date = new Date, this.s = this.formatDate(this.date, "gen", this.withMillis), this.hV = yt(this.s)), this.hV
                }, void 0 !== t && (void 0 !== t.str ? this.setString(t.str) : "string" == typeof t && t.match(/^[0-9]{14}Z$/) ? this.setString(t) : void 0 !== t.hex ? this.setStringHex(t.hex) : void 0 !== t.date && this.setByDate(t.date), !0 === t.millis && (this.withMillis = !0))
            }, i.lang.extend(ct.asn1.DERGeneralizedTime, ct.asn1.DERAbstractTime), ct.asn1.DERSequence = function(t) {
                ct.asn1.DERSequence.superclass.constructor.call(this, t), this.hT = "30", this.getFreshValueHex = function() {
                    for (var t = "", e = 0; e < this.asn1Array.length; e++) {
                        t += this.asn1Array[e].getEncodedHex()
                    }
                    return this.hV = t, this.hV
                }
            }, i.lang.extend(ct.asn1.DERSequence, ct.asn1.DERAbstractStructured), ct.asn1.DERSet = function(t) {
                ct.asn1.DERSet.superclass.constructor.call(this, t), this.hT = "31", this.sortFlag = !0, this.getFreshValueHex = function() {
                    for (var t = new Array, e = 0; e < this.asn1Array.length; e++) {
                        var r = this.asn1Array[e];
                        t.push(r.getEncodedHex())
                    }
                    return 1 == this.sortFlag && t.sort(), this.hV = t.join(""), this.hV
                }, void 0 !== t && void 0 !== t.sortflag && 0 == t.sortflag && (this.sortFlag = !1)
            }, i.lang.extend(ct.asn1.DERSet, ct.asn1.DERAbstractStructured), ct.asn1.DERTaggedObject = function(t) {
                ct.asn1.DERTaggedObject.superclass.constructor.call(this), this.hT = "a0", this.hV = "", this.isExplicit = !0, this.asn1Object = null, this.setASN1Object = function(t, e, r) {
                    this.hT = e, this.isExplicit = t, this.asn1Object = r, this.isExplicit ? (this.hV = this.asn1Object.getEncodedHex(), this.hTLV = null, this.isModified = !0) : (this.hV = null, this.hTLV = r.getEncodedHex(), this.hTLV = this.hTLV.replace(/^../, e), this.isModified = !1)
                }, this.getFreshValueHex = function() {
                    return this.hV
                }, void 0 !== t && (void 0 !== t.tag && (this.hT = t.tag), void 0 !== t.explicit && (this.isExplicit = t.explicit), void 0 !== t.obj && (this.asn1Object = t.obj, this.setASN1Object(this.isExplicit, this.hT, this.asn1Object)))
            }, i.lang.extend(ct.asn1.DERTaggedObject, ct.asn1.ASN1Object);
            var ct, ht, lt, ft = new function() {};

            function pt(t) {
                for (var e = new Array, r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
                return e
            }

            function dt(t) {
                for (var e = "", r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
                return e
            }

            function gt(t) {
                for (var e = "", r = 0; r < t.length; r++) {
                    var n = t[r].toString(16);
                    1 == n.length && (n = "0" + n), e += n
                }
                return e
            }

            function yt(t) {
                return gt(pt(t))
            }

            function vt(t) {
                return t = (t = (t = t.replace(/\=/g, "")).replace(/\+/g, "-")).replace(/\//g, "_")
            }

            function mt(t) {
                return t.length % 4 == 2 ? t += "==" : t.length % 4 == 3 && (t += "="), t = (t = t.replace(/-/g, "+")).replace(/_/g, "/")
            }

            function Et(t) {
                return t.length % 2 == 1 && (t = "0" + t), vt(E(t))
            }

            function St(t) {
                return S(mt(t))
            }

            function bt(t) {
                return Nt(Ot(t))
            }

            function Ct(t) {
                return decodeURIComponent(_t(t))
            }

            function At(t) {
                for (var e = "", r = 0; r < t.length - 1; r += 2) e += String.fromCharCode(parseInt(t.substr(r, 2), 16));
                return e
            }

            function wt(t) {
                for (var e = "", r = 0; r < t.length; r++) e += ("0" + t.charCodeAt(r).toString(16)).slice(-2);
                return e
            }

            function Tt(t) {
                return E(t)
            }

            function xt(t) {
                var e = Tt(t).replace(/(.{64})/g, "$1\r\n");
                return e = e.replace(/\r\n$/, "")
            }

            function It(t) {
                return S(t.replace(/[^0-9A-Za-z\/+=]*/g, ""))
            }

            function Bt(t, e) {
                return "-----BEGIN " + e + "-----\r\n" + xt(t) + "\r\n-----END " + e + "-----\r\n"
            }

            function Ft(t, e) {
                if (-1 == t.indexOf("-----BEGIN ")) throw "can't find PEM header: " + e;
                return It(t = void 0 !== e ? (t = t.replace(new RegExp("^[^]*-----BEGIN " + e + "-----"), "")).replace(new RegExp("-----END " + e + "-----[^]*$"), "") : (t = t.replace(/^[^]*-----BEGIN [^-]+-----/, "")).replace(/-----END [^-]+-----[^]*$/, ""))
            }

            function Rt(t) {
                var e, r, n, i, s, a, o, u, c, h, l;
                if (l = t.match(/^(\d{2}|\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(|\.\d+)Z$/)) return u = l[1], e = parseInt(u), 2 === u.length && (50 <= e && e < 100 ? e = 1900 + e : 0 <= e && e < 50 && (e = 2e3 + e)), r = parseInt(l[2]) - 1, n = parseInt(l[3]), i = parseInt(l[4]), s = parseInt(l[5]), a = parseInt(l[6]), o = 0, "" !== (c = l[7]) && (h = (c.substr(1) + "00").substr(0, 3), o = parseInt(h)), Date.UTC(e, r, n, i, s, a, o);
                throw "unsupported zulu format: " + t
            }

            function Dt(t) {
                return ~~(Rt(t) / 1e3)
            }

            function Nt(t) {
                return t.replace(/%/g, "")
            }

            function _t(t) {
                return t.replace(/(..)/g, "%$1")
            }

            function Pt(t) {
                var e = "malformed IPv6 address";
                if (!t.match(/^[0-9A-Fa-f:]+$/)) throw e;
                var r = (t = t.toLowerCase()).split(":").length - 1;
                if (r < 2) throw e;
                var n = ":".repeat(7 - r + 2),
                    i = (t = t.replace("::", n)).split(":");
                if (8 != i.length) throw e;
                for (var s = 0; s < 8; s++) i[s] = ("0000" + i[s]).slice(-4);
                return i.join("")
            }

            function kt(t) {
                if (!t.match(/^[0-9A-Fa-f]{32}$/)) throw "malformed IPv6 address octet";
                for (var e = (t = t.toLowerCase()).match(/.{1,4}/g), r = 0; r < 8; r++) e[r] = e[r].replace(/^0+/, ""), "" == e[r] && (e[r] = "0");
                var n = (t = ":" + e.join(":") + ":").match(/:(0:){2,}/g);
                if (null === n) return t.slice(1, -1);
                var i = "";
                for (r = 0; r < n.length; r++) n[r].length > i.length && (i = n[r]);
                return (t = t.replace(i, "::")).slice(1, -1)
            }

            function Lt(t) {
                var e = "malformed hex value";
                if (!t.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/)) throw e;
                if (8 != t.length) return 32 == t.length ? kt(t) : t;
                try {
                    return parseInt(t.substr(0, 2), 16) + "." + parseInt(t.substr(2, 2), 16) + "." + parseInt(t.substr(4, 2), 16) + "." + parseInt(t.substr(6, 2), 16)
                } catch (t) {
                    throw e
                }
            }

            function Ot(t) {
                for (var e = encodeURIComponent(t), r = "", n = 0; n < e.length; n++) "%" == e[n] ? (r += e.substr(n, 3), n += 2) : r = r + "%" + yt(e[n]);
                return r
            }

            function Ut(t) {
                return t.length % 2 == 1 ? "0" + t : t.substr(0, 1) > "7" ? "00" + t : t
            }

            function Vt(t) {
                t = (t = (t = t.replace(/^\s*\[\s*/, "")).replace(/\s*\]\s*$/, "")).replace(/\s*/g, "");
                try {
                    return t.split(/,/).map((function(t, e, r) {
                        var n = parseInt(t);
                        if (n < 0 || 255 < n) throw "integer not in range 0-255";
                        return ("00" + n.toString(16)).slice(-2)
                    })).join("")
                } catch (t) {
                    throw "malformed integer array string: " + t
                }
            }
            ft.getLblen = function(t, e) {
                if ("8" != t.substr(e + 2, 1)) return 1;
                var r = parseInt(t.substr(e + 3, 1));
                return 0 == r ? -1 : 0 < r && r < 10 ? r + 1 : -2
            }, ft.getL = function(t, e) {
                var r = ft.getLblen(t, e);
                return r < 1 ? "" : t.substr(e + 2, 2 * r)
            }, ft.getVblen = function(t, e) {
                var r;
                return "" == (r = ft.getL(t, e)) ? -1 : ("8" === r.substr(0, 1) ? new C(r.substr(2), 16) : new C(r, 16)).intValue()
            }, ft.getVidx = function(t, e) {
                var r = ft.getLblen(t, e);
                return r < 0 ? r : e + 2 * (r + 1)
            }, ft.getV = function(t, e) {
                var r = ft.getVidx(t, e),
                    n = ft.getVblen(t, e);
                return t.substr(r, 2 * n)
            }, ft.getTLV = function(t, e) {
                return t.substr(e, 2) + ft.getL(t, e) + ft.getV(t, e)
            }, ft.getTLVblen = function(t, e) {
                return 2 + 2 * ft.getLblen(t, e) + 2 * ft.getVblen(t, e)
            }, ft.getNextSiblingIdx = function(t, e) {
                return ft.getVidx(t, e) + 2 * ft.getVblen(t, e)
            }, ft.getChildIdx = function(t, e) {
                var r, n, i, s = ft,
                    a = [];
                r = s.getVidx(t, e), n = 2 * s.getVblen(t, e), "03" == t.substr(e, 2) && (r += 2, n -= 2), i = 0;
                for (var o = r; i <= n;) {
                    var u = s.getTLVblen(t, o);
                    if ((i += u) <= n && a.push(o), o += u, i >= n) break
                }
                return a
            }, ft.getNthChildIdx = function(t, e, r) {
                return ft.getChildIdx(t, e)[r]
            }, ft.getIdxbyList = function(t, e, r, n) {
                var i, s, a = ft;
                return 0 == r.length ? void 0 !== n && t.substr(e, 2) !== n ? -1 : e : (i = r.shift()) >= (s = a.getChildIdx(t, e)).length ? -1 : a.getIdxbyList(t, s[i], r, n)
            }, ft.getIdxbyListEx = function(t, e, r, n) {
                var i, s, a = ft;
                if (0 == r.length) return void 0 !== n && t.substr(e, 2) !== n ? -1 : e;
                i = r.shift(), s = a.getChildIdx(t, e);
                for (var o = 0, u = 0; u < s.length; u++) {
                    var c = t.substr(s[u], 2);
                    if ("number" == typeof i && !a.isContextTag(c) && o == i || "string" == typeof i && a.isContextTag(c, i)) return a.getIdxbyListEx(t, s[u], r, n);
                    a.isContextTag(c) || o++
                }
                return -1
            }, ft.getTLVbyList = function(t, e, r, n) {
                var i = ft,
                    s = i.getIdxbyList(t, e, r, n);
                return -1 == s || s >= t.length ? null : i.getTLV(t, s)
            }, ft.getTLVbyListEx = function(t, e, r, n) {
                var i = ft,
                    s = i.getIdxbyListEx(t, e, r, n);
                return -1 == s ? null : i.getTLV(t, s)
            }, ft.getVbyList = function(t, e, r, n, i) {
                var s, a, o = ft;
                return -1 == (s = o.getIdxbyList(t, e, r, n)) || s >= t.length ? null : (a = o.getV(t, s), !0 === i && (a = a.substr(2)), a)
            }, ft.getVbyListEx = function(t, e, r, n, i) {
                var s, a, o = ft;
                return -1 == (s = o.getIdxbyListEx(t, e, r, n)) ? null : (a = o.getV(t, s), "03" == t.substr(s, 2) && !1 !== i && (a = a.substr(2)), a)
            }, ft.hextooidstr = function(t) {
                var e = function(t, e) {
                        return t.length >= e ? t : new Array(e - t.length + 1).join("0") + t
                    },
                    r = [],
                    n = t.substr(0, 2),
                    i = parseInt(n, 16);
                r[0] = new String(Math.floor(i / 40)), r[1] = new String(i % 40);
                for (var s = t.substr(2), a = [], o = 0; o < s.length / 2; o++) a.push(parseInt(s.substr(2 * o, 2), 16));
                var u = [],
                    c = "";
                for (o = 0; o < a.length; o++) 128 & a[o] ? c += e((127 & a[o]).toString(2), 7) : (c += e((127 & a[o]).toString(2), 7), u.push(new String(parseInt(c, 2))), c = "");
                var h = r.join(".");
                return u.length > 0 && (h = h + "." + u.join(".")), h
            }, ft.dump = function(t, e, r, n) {
                var i = ft,
                    s = i.getV,
                    a = i.dump,
                    o = i.getChildIdx,
                    u = t;
                t instanceof ct.asn1.ASN1Object && (u = t.getEncodedHex());
                var c = function(t, e) {
                    return t.length <= 2 * e ? t : t.substr(0, e) + "..(total " + t.length / 2 + "bytes).." + t.substr(t.length - e, e)
                };
                void 0 === e && (e = {
                    ommit_long_octet: 32
                }), void 0 === r && (r = 0), void 0 === n && (n = "");
                var h, l = e.ommit_long_octet;
                if ("01" == (h = u.substr(r, 2))) return "00" == (f = s(u, r)) ? n + "BOOLEAN FALSE\n" : n + "BOOLEAN TRUE\n";
                if ("02" == h) return n + "INTEGER " + c(f = s(u, r), l) + "\n";
                if ("03" == h) {
                    var f = s(u, r);
                    if (i.isASN1HEX(f.substr(2))) {
                        var p = n + "BITSTRING, encapsulates\n";
                        return p += a(f.substr(2), e, 0, n + "  ")
                    }
                    return n + "BITSTRING " + c(f, l) + "\n"
                }
                if ("04" == h) {
                    f = s(u, r);
                    if (i.isASN1HEX(f)) {
                        p = n + "OCTETSTRING, encapsulates\n";
                        return p += a(f, e, 0, n + "  ")
                    }
                    return n + "OCTETSTRING " + c(f, l) + "\n"
                }
                if ("05" == h) return n + "NULL\n";
                if ("06" == h) {
                    var d = s(u, r),
                        g = ct.asn1.ASN1Util.oidHexToInt(d),
                        y = ct.asn1.x509.OID.oid2name(g),
                        v = g.replace(/\./g, " ");
                    return "" != y ? n + "ObjectIdentifier " + y + " (" + v + ")\n" : n + "ObjectIdentifier (" + v + ")\n"
                }
                if ("0a" == h) return n + "ENUMERATED " + parseInt(s(u, r)) + "\n";
                if ("0c" == h) return n + "UTF8String '" + Ct(s(u, r)) + "'\n";
                if ("13" == h) return n + "PrintableString '" + Ct(s(u, r)) + "'\n";
                if ("14" == h) return n + "TeletexString '" + Ct(s(u, r)) + "'\n";
                if ("16" == h) return n + "IA5String '" + Ct(s(u, r)) + "'\n";
                if ("17" == h) return n + "UTCTime " + Ct(s(u, r)) + "\n";
                if ("18" == h) return n + "GeneralizedTime " + Ct(s(u, r)) + "\n";
                if ("1a" == h) return n + "VisualString '" + Ct(s(u, r)) + "'\n";
                if ("1e" == h) return n + "BMPString '" + Ct(s(u, r)) + "'\n";
                if ("30" == h) {
                    if ("3000" == u.substr(r, 4)) return n + "SEQUENCE {}\n";
                    p = n + "SEQUENCE\n";
                    var m = e;
                    if ((2 == (b = o(u, r)).length || 3 == b.length) && "06" == u.substr(b[0], 2) && "04" == u.substr(b[b.length - 1], 2)) {
                        y = i.oidname(s(u, b[0]));
                        var E = JSON.parse(JSON.stringify(e));
                        E.x509ExtName = y, m = E
                    }
                    for (var S = 0; S < b.length; S++) p += a(u, m, b[S], n + "  ");
                    return p
                }
                if ("31" == h) {
                    p = n + "SET\n";
                    var b = o(u, r);
                    for (S = 0; S < b.length; S++) p += a(u, e, b[S], n + "  ");
                    return p
                }
                if (0 != (128 & (h = parseInt(h, 16)))) {
                    var C = 31 & h;
                    if (0 != (32 & h)) {
                        for (p = n + "[" + C + "]\n", b = o(u, r), S = 0; S < b.length; S++) p += a(u, e, b[S], n + "  ");
                        return p
                    }
                    f = s(u, r);
                    if (ft.isASN1HEX(f)) {
                        var p = n + "[" + C + "]\n";
                        return p += a(f, e, 0, n + "  ")
                    }
                    return ("68747470" == f.substr(0, 8) || "subjectAltName" === e.x509ExtName && 2 == C) && (f = Ct(f)), p = n + "[" + C + "] " + f + "\n"
                }
                return n + "UNKNOWN(" + h + ") " + s(u, r) + "\n"
            }, ft.isContextTag = function(t, e) {
                var r, n;
                t = t.toLowerCase();
                try {
                    r = parseInt(t, 16)
                } catch (t) {
                    return -1
                }
                if (void 0 === e) return 128 == (192 & r);
                try {
                    return null != e.match(/^\[[0-9]+\]$/) && (!((n = parseInt(e.substr(1, e.length - 1), 10)) > 31) && (128 == (192 & r) && (31 & r) == n))
                } catch (t) {
                    return !1
                }
            }, ft.isASN1HEX = function(t) {
                var e = ft;
                if (t.length % 2 == 1) return !1;
                var r = e.getVblen(t, 0),
                    n = t.substr(0, 2),
                    i = e.getL(t, 0);
                return t.length - n.length - i.length == 2 * r
            }, ft.checkStrictDER = function(t, e, r, n, i) {
                var s = ft;
                if (void 0 === r) {
                    if ("string" != typeof t) throw new Error("not hex string");
                    if (t = t.toLowerCase(), !ct.lang.String.isHex(t)) throw new Error("not hex string");
                    r = t.length, i = (n = t.length / 2) < 128 ? 1 : Math.ceil(n.toString(16)) + 1
                }
                if (s.getL(t, e).length > 2 * i) throw new Error("L of TLV too long: idx=" + e);
                var a = s.getVblen(t, e);
                if (a > n) throw new Error("value of L too long than hex: idx=" + e);
                var o = s.getTLV(t, e),
                    u = o.length - 2 - s.getL(t, e).length;
                if (u !== 2 * a) throw new Error("V string length and L's value not the same:" + u + "/" + 2 * a);
                if (0 === e && t.length != o.length) throw new Error("total length and TLV length unmatch:" + t.length + "!=" + o.length);
                var c = t.substr(e, 2);
                if ("02" === c) {
                    var h = s.getVidx(t, e);
                    if ("00" == t.substr(h, 2) && t.charCodeAt(h + 2) < 56) throw new Error("not least zeros for DER INTEGER")
                }
                if (32 & parseInt(c, 16)) {
                    for (var l = s.getVblen(t, e), f = 0, p = s.getChildIdx(t, e), d = 0; d < p.length; d++) {
                        f += s.getTLV(t, p[d]).length, s.checkStrictDER(t, p[d], r, n, i)
                    }
                    if (2 * l != f) throw new Error("sum of children's TLV length and L unmatch: " + 2 * l + "!=" + f)
                }
            }, ft.oidname = function(t) {
                var e = ct.asn1;
                ct.lang.String.isHex(t) && (t = e.ASN1Util.oidHexToInt(t));
                var r = e.x509.OID.oid2name(t);
                return "" === r && (r = t), r
            }, void 0 !== ct && ct || (ct = {}), void 0 !== ct.asn1 && ct.asn1 || (ct.asn1 = {}), void 0 !== ct.asn1.x509 && ct.asn1.x509 || (ct.asn1.x509 = {}), ct.asn1.x509.Certificate = function(t) {
                ct.asn1.x509.Certificate.superclass.constructor.call(this);
                var e = ct.asn1,
                    r = e.DERBitString,
                    n = e.DERSequence,
                    i = e.x509,
                    s = i.TBSCertificate,
                    a = i.AlgorithmIdentifier;
                this.params = void 0, this.setByParam = function(t) {
                    this.params = t
                }, this.sign = function() {
                    var t = this.params,
                        e = t.tbsobj.getEncodedHex(),
                        r = new ct.crypto.Signature({
                            alg: t.sigalg
                        });
                    r.init(t.cakey), r.updateHex(e), t.sighex = r.sign()
                }, this.getPEM = function() {
                    return Bt(this.getEncodedHex(), "CERTIFICATE")
                }, this.getEncodedHex = function() {
                    var t = this.params;
                    if (null != t.tbsobj && null != t.tbsobj || (t.tbsobj = new s(t)), null == t.sighex && null != t.cakey && this.sign(), null == t.sighex) throw new Error("sighex or cakey parameter not defined");
                    var e = [];
                    return e.push(t.tbsobj), e.push(new a({
                        name: t.sigalg
                    })), e.push(new r({
                        hex: "00" + t.sighex
                    })), new n({
                        array: e
                    }).getEncodedHex()
                }, null != t && (this.params = t)
            }, i.lang.extend(ct.asn1.x509.Certificate, ct.asn1.ASN1Object), ct.asn1.x509.TBSCertificate = function(t) {
                ct.asn1.x509.TBSCertificate.superclass.constructor.call(this);
                var e = ct.asn1,
                    r = e.x509,
                    n = e.DERTaggedObject,
                    i = e.DERInteger,
                    s = e.DERSequence,
                    a = r.AlgorithmIdentifier,
                    o = r.Time,
                    u = r.X500Name,
                    c = r.Extensions,
                    h = r.SubjectPublicKeyInfo;
                this.params = null, this.setByParam = function(t) {
                    this.params = t
                }, this.getEncodedHex = function() {
                    var t = [],
                        e = this.params;
                    if (null != e.version || 1 != e.version) {
                        var r = 2;
                        null != e.version && (r = e.version - 1);
                        var l = new n({
                            obj: new i({
                                int: r
                            })
                        });
                        t.push(l)
                    }
                    return t.push(new i(e.serial)), t.push(new a({
                        name: e.sigalg
                    })), t.push(new u(e.issuer)), t.push(new s({
                        array: [new o({
                            str: e.notbefore
                        }), new o({
                            str: e.notafter
                        })]
                    })), t.push(new u(e.subject)), t.push(new h(Ht.getKey(e.sbjpubkey))), void 0 !== e.ext && e.ext.length > 0 && t.push(new n({
                        tag: "a3",
                        obj: new c(e.ext)
                    })), new ct.asn1.DERSequence({
                        array: t
                    }).getEncodedHex()
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.x509.TBSCertificate, ct.asn1.ASN1Object), ct.asn1.x509.Extensions = function(t) {
                ct.asn1.x509.Extensions.superclass.constructor.call(this);
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.x509;
                this.aParam = [], this.setByParam = function(t) {
                    this.aParam = t
                }, this.getEncodedHex = function() {
                    for (var t = [], e = 0; e < this.aParam.length; e++) {
                        var i = this.aParam[e],
                            s = i.extname,
                            a = null;
                        if (null != i.extn) a = new n.PrivateExtension(i);
                        else if ("subjectKeyIdentifier" == s) a = new n.SubjectKeyIdentifier(i);
                        else if ("keyUsage" == s) a = new n.KeyUsage(i);
                        else if ("subjectAltName" == s) a = new n.SubjectAltName(i);
                        else if ("issuerAltName" == s) a = new n.IssuerAltName(i);
                        else if ("basicConstraints" == s) a = new n.BasicConstraints(i);
                        else if ("cRLDistributionPoints" == s) a = new n.CRLDistributionPoints(i);
                        else if ("certificatePolicies" == s) a = new n.CertificatePolicies(i);
                        else if ("authorityKeyIdentifier" == s) a = new n.AuthorityKeyIdentifier(i);
                        else if ("extKeyUsage" == s) a = new n.ExtKeyUsage(i);
                        else if ("authorityInfoAccess" == s) a = new n.AuthorityInfoAccess(i);
                        else if ("cRLNumber" == s) a = new n.CRLNumber(i);
                        else if ("cRLReason" == s) a = new n.CRLReason(i);
                        else if ("ocspNonce" == s) a = new n.OCSPNonce(i);
                        else {
                            if ("ocspNoCheck" != s) throw new Error("extension not supported:" + JSON.stringify(i));
                            a = new n.OCSPNoCheck(i)
                        }
                        null != a && t.push(a)
                    }
                    return new r({
                        array: t
                    }).getEncodedHex()
                }, null != t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.x509.Extensions, ct.asn1.ASN1Object), ct.asn1.x509.Extension = function(t) {
                ct.asn1.x509.Extension.superclass.constructor.call(this);
                var e = ct.asn1,
                    r = e.DERObjectIdentifier,
                    n = e.DEROctetString,
                    i = (e.DERBitString, e.DERBoolean),
                    s = e.DERSequence;
                this.getEncodedHex = function() {
                    var t = new r({
                            oid: this.oid
                        }),
                        e = new n({
                            hex: this.getExtnValueHex()
                        }),
                        a = new Array;
                    return a.push(t), this.critical && a.push(new i), a.push(e), new s({
                        array: a
                    }).getEncodedHex()
                }, this.critical = !1, void 0 !== t && void 0 !== t.critical && (this.critical = t.critical)
            }, i.lang.extend(ct.asn1.x509.Extension, ct.asn1.ASN1Object), ct.asn1.x509.KeyUsage = function(t) {
                ct.asn1.x509.KeyUsage.superclass.constructor.call(this, t);
                var e = zt.KEYUSAGE_NAME;
                if (this.getExtnValueHex = function() {
                        return this.asn1ExtnValue.getEncodedHex()
                    }, this.oid = "2.5.29.15", void 0 !== t && (void 0 !== t.bin && (this.asn1ExtnValue = new ct.asn1.DERBitString(t)), void 0 !== t.names && void 0 !== t.names.length)) {
                    for (var r = t.names, n = "000000000", i = 0; i < r.length; i++)
                        for (var s = 0; s < e.length; s++) r[i] === e[s] && (n = n.substring(0, s) + "1" + n.substring(s + 1, n.length));
                    this.asn1ExtnValue = new ct.asn1.DERBitString({
                        bin: n
                    })
                }
            }, i.lang.extend(ct.asn1.x509.KeyUsage, ct.asn1.x509.Extension), ct.asn1.x509.BasicConstraints = function(t) {
                ct.asn1.x509.BasicConstraints.superclass.constructor.call(this, t);
                var e = ct.asn1,
                    r = e.DERBoolean,
                    n = e.DERInteger,
                    i = e.DERSequence;
                this.getExtnValueHex = function() {
                    var t = new Array;
                    this.cA && t.push(new r), this.pathLen > -1 && t.push(new n({
                        int: this.pathLen
                    }));
                    var e = new i({
                        array: t
                    });
                    return this.asn1ExtnValue = e, this.asn1ExtnValue.getEncodedHex()
                }, this.oid = "2.5.29.19", this.cA = !1, this.pathLen = -1, void 0 !== t && (void 0 !== t.cA && (this.cA = t.cA), void 0 !== t.pathLen && (this.pathLen = t.pathLen))
            }, i.lang.extend(ct.asn1.x509.BasicConstraints, ct.asn1.x509.Extension), ct.asn1.x509.CRLDistributionPoints = function(t) {
                ct.asn1.x509.CRLDistributionPoints.superclass.constructor.call(this, t);
                var e = ct.asn1,
                    r = e.x509;
                this.getExtnValueHex = function() {
                    return this.asn1ExtnValue.getEncodedHex()
                }, this.setByDPArray = function(t) {
                    for (var n = [], i = 0; i < t.length; i++)
                        if (t[i] instanceof ct.asn1.ASN1Object) n.push(t[i]);
                        else {
                            var s = new r.DistributionPoint(t[i]);
                            n.push(s)
                        }
                    this.asn1ExtnValue = new e.DERSequence({
                        array: n
                    })
                }, this.setByOneURI = function(t) {
                    var e = new r.DistributionPoint({
                        fulluri: t
                    });
                    this.setByDPArray([e])
                }, this.oid = "2.5.29.31", void 0 !== t && (void 0 !== t.array ? this.setByDPArray(t.array) : void 0 !== t.uri && this.setByOneURI(t.uri))
            }, i.lang.extend(ct.asn1.x509.CRLDistributionPoints, ct.asn1.x509.Extension), ct.asn1.x509.DistributionPoint = function(t) {
                ct.asn1.x509.DistributionPoint.superclass.constructor.call(this);
                var e = ct.asn1,
                    r = e.x509.DistributionPointName;
                this.getEncodedHex = function() {
                    var t = new e.DERSequence;
                    if (null != this.asn1DP) {
                        var r = new e.DERTaggedObject({
                            explicit: !0,
                            tag: "a0",
                            obj: this.asn1DP
                        });
                        t.appendASN1Object(r)
                    }
                    return this.hTLV = t.getEncodedHex(), this.hTLV
                }, void 0 !== t && (void 0 !== t.dpobj ? this.asn1DP = t.dpobj : void 0 !== t.dpname ? this.asn1DP = new r(t.dpname) : void 0 !== t.fulluri && (this.asn1DP = new r({
                    full: [{
                        uri: t.fulluri
                    }]
                })))
            }, i.lang.extend(ct.asn1.x509.DistributionPoint, ct.asn1.ASN1Object), ct.asn1.x509.DistributionPointName = function(t) {
                ct.asn1.x509.DistributionPointName.superclass.constructor.call(this);
                var e = ct.asn1,
                    r = e.DERTaggedObject;
                if (this.getEncodedHex = function() {
                        if ("full" != this.type) throw new Error("currently type shall be 'full': " + this.type);
                        return this.asn1Obj = new r({
                            explicit: !1,
                            tag: this.tag,
                            obj: this.asn1V
                        }), this.hTLV = this.asn1Obj.getEncodedHex(), this.hTLV
                    }, void 0 !== t)
                    if (e.x509.GeneralNames.prototype.isPrototypeOf(t)) this.type = "full", this.tag = "a0", this.asn1V = t;
                    else {
                        if (void 0 === t.full) throw new Error("This class supports GeneralNames only as argument");
                        this.type = "full", this.tag = "a0", this.asn1V = new e.x509.GeneralNames(t.full)
                    }
            }, i.lang.extend(ct.asn1.x509.DistributionPointName, ct.asn1.ASN1Object), ct.asn1.x509.CertificatePolicies = function(t) {
                ct.asn1.x509.CertificatePolicies.superclass.constructor.call(this, t);
                var e = ct.asn1,
                    r = e.x509,
                    n = e.DERSequence,
                    i = r.PolicyInformation;
                this.params = null, this.getExtnValueHex = function() {
                    for (var t = [], e = 0; e < this.params.array.length; e++) t.push(new i(this.params.array[e]));
                    var r = new n({
                        array: t
                    });
                    return this.asn1ExtnValue = r, this.asn1ExtnValue.getEncodedHex()
                }, this.oid = "2.5.29.32", void 0 !== t && (this.params = t)
            }, i.lang.extend(ct.asn1.x509.CertificatePolicies, ct.asn1.x509.Extension), ct.asn1.x509.PolicyInformation = function(t) {
                ct.asn1.x509.PolicyInformation.superclass.constructor.call(this, t);
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.DERObjectIdentifier,
                    i = e.x509.PolicyQualifierInfo;
                this.params = null, this.getEncodedHex = function() {
                    if (void 0 === this.params.policyoid && void 0 === this.params.array) throw new Error("parameter oid and array missing");
                    var t = [new n(this.params.policyoid)];
                    if (void 0 !== this.params.array) {
                        for (var e = [], s = 0; s < this.params.array.length; s++) e.push(new i(this.params.array[s]));
                        e.length > 0 && t.push(new r({
                            array: e
                        }))
                    }
                    return new r({
                        array: t
                    }).getEncodedHex()
                }, void 0 !== t && (this.params = t)
            }, i.lang.extend(ct.asn1.x509.PolicyInformation, ct.asn1.ASN1Object), ct.asn1.x509.PolicyQualifierInfo = function(t) {
                ct.asn1.x509.PolicyQualifierInfo.superclass.constructor.call(this, t);
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.DERIA5String,
                    i = e.DERObjectIdentifier,
                    s = e.x509.UserNotice;
                this.params = null, this.getEncodedHex = function() {
                    return void 0 !== this.params.cps ? new r({
                        array: [new i({
                            oid: "1.3.6.1.5.5.7.2.1"
                        }), new n({
                            str: this.params.cps
                        })]
                    }).getEncodedHex() : null != this.params.unotice ? new r({
                        array: [new i({
                            oid: "1.3.6.1.5.5.7.2.2"
                        }), new s(this.params.unotice)]
                    }).getEncodedHex() : void 0
                }, void 0 !== t && (this.params = t)
            }, i.lang.extend(ct.asn1.x509.PolicyQualifierInfo, ct.asn1.ASN1Object), ct.asn1.x509.UserNotice = function(t) {
                ct.asn1.x509.UserNotice.superclass.constructor.call(this, t);
                var e = ct.asn1.DERSequence,
                    r = (ct.asn1.DERInteger, ct.asn1.x509.DisplayText),
                    n = ct.asn1.x509.NoticeReference;
                this.params = null, this.getEncodedHex = function() {
                    var t = [];
                    return void 0 !== this.params.noticeref && t.push(new n(this.params.noticeref)), void 0 !== this.params.exptext && t.push(new r(this.params.exptext)), new e({
                        array: t
                    }).getEncodedHex()
                }, void 0 !== t && (this.params = t)
            }, i.lang.extend(ct.asn1.x509.UserNotice, ct.asn1.ASN1Object), ct.asn1.x509.NoticeReference = function(t) {
                ct.asn1.x509.NoticeReference.superclass.constructor.call(this, t);
                var e = ct.asn1.DERSequence,
                    r = ct.asn1.DERInteger,
                    n = ct.asn1.x509.DisplayText;
                this.params = null, this.getEncodedHex = function() {
                    var t = [];
                    if (void 0 !== this.params.org && t.push(new n(this.params.org)), void 0 !== this.params.noticenum) {
                        for (var i = [], s = this.params.noticenum, a = 0; a < s.length; a++) i.push(new r(s[a]));
                        t.push(new e({
                            array: i
                        }))
                    }
                    if (0 == t.length) throw new Error("parameter is empty");
                    return new e({
                        array: t
                    }).getEncodedHex()
                }, void 0 !== t && (this.params = t)
            }, i.lang.extend(ct.asn1.x509.NoticeReference, ct.asn1.ASN1Object), ct.asn1.x509.DisplayText = function(t) {
                ct.asn1.x509.DisplayText.superclass.constructor.call(this, t), this.hT = "0c", void 0 !== t && ("ia5" === t.type ? this.hT = "16" : "vis" === t.type ? this.hT = "1a" : "bmp" === t.type && (this.hT = "1e"))
            }, i.lang.extend(ct.asn1.x509.DisplayText, ct.asn1.DERAbstractString), ct.asn1.x509.ExtKeyUsage = function(t) {
                ct.asn1.x509.ExtKeyUsage.superclass.constructor.call(this, t);
                var e = ct.asn1;
                this.setPurposeArray = function(t) {
                    this.asn1ExtnValue = new e.DERSequence;
                    for (var r = 0; r < t.length; r++) {
                        var n = new e.DERObjectIdentifier(t[r]);
                        this.asn1ExtnValue.appendASN1Object(n)
                    }
                }, this.getExtnValueHex = function() {
                    return this.asn1ExtnValue.getEncodedHex()
                }, this.oid = "2.5.29.37", void 0 !== t && void 0 !== t.array && this.setPurposeArray(t.array)
            }, i.lang.extend(ct.asn1.x509.ExtKeyUsage, ct.asn1.x509.Extension), ct.asn1.x509.AuthorityKeyIdentifier = function(t) {
                ct.asn1.x509.AuthorityKeyIdentifier.superclass.constructor.call(this, t);
                var e = ct,
                    r = e.asn1,
                    n = r.DERTaggedObject,
                    i = r.x509.GeneralNames;
                e.crypto.Util.isKey;
                this.asn1KID = null, this.asn1CertIssuer = null, this.asn1CertSN = null, this.getExtnValueHex = function() {
                    var t = new Array;
                    this.asn1KID && t.push(new n({
                        explicit: !1,
                        tag: "80",
                        obj: this.asn1KID
                    })), this.asn1CertIssuer && t.push(new n({
                        explicit: !1,
                        tag: "a1",
                        obj: new i([{
                            dn: this.asn1CertIssuer
                        }])
                    })), this.asn1CertSN && t.push(new n({
                        explicit: !1,
                        tag: "82",
                        obj: this.asn1CertSN
                    }));
                    var e = new r.DERSequence({
                        array: t
                    });
                    return this.asn1ExtnValue = e, this.asn1ExtnValue.getEncodedHex()
                }, this.setKIDByParam = function(t) {
                    if (void 0 !== t.str || void 0 !== t.hex) this.asn1KID = new ct.asn1.DEROctetString(t);
                    else if ("object" == typeof t && ct.crypto.Util.isKey(t) || "string" == typeof t && -1 != t.indexOf("BEGIN ")) {
                        var e = t;
                        "string" == typeof t && (e = Ht.getKey(t));
                        var r = Ht.getKeyID(e);
                        this.asn1KID = new ct.asn1.DEROctetString({
                            hex: r
                        })
                    }
                }, this.setCertIssuerByParam = function(t) {
                    void 0 !== t.str || void 0 !== t.ldapstr || void 0 !== t.hex || void 0 !== t.certsubject || void 0 !== t.certissuer ? this.asn1CertIssuer = new ct.asn1.x509.X500Name(t) : "string" == typeof t && -1 != t.indexOf("BEGIN ") && -1 != t.indexOf("CERTIFICATE") && (this.asn1CertIssuer = new ct.asn1.x509.X500Name({
                        certissuer: t
                    }))
                }, this.setCertSNByParam = function(t) {
                    if (void 0 !== t.str || void 0 !== t.bigint || void 0 !== t.hex) this.asn1CertSN = new ct.asn1.DERInteger(t);
                    else if ("string" == typeof t && -1 != t.indexOf("BEGIN ") && t.indexOf("CERTIFICATE")) {
                        var e = new zt;
                        e.readCertPEM(t);
                        var r = e.getSerialNumberHex();
                        this.asn1CertSN = new ct.asn1.DERInteger({
                            hex: r
                        })
                    }
                }, this.oid = "2.5.29.35", void 0 !== t && (void 0 !== t.kid && this.setKIDByParam(t.kid), void 0 !== t.issuer && this.setCertIssuerByParam(t.issuer), void 0 !== t.sn && this.setCertSNByParam(t.sn), void 0 !== t.issuersn && "string" == typeof t.issuersn && -1 != t.issuersn.indexOf("BEGIN ") && t.issuersn.indexOf("CERTIFICATE") && (this.setCertSNByParam(t.issuersn), this.setCertIssuerByParam(t.issuersn)))
            }, i.lang.extend(ct.asn1.x509.AuthorityKeyIdentifier, ct.asn1.x509.Extension), ct.asn1.x509.SubjectKeyIdentifier = function(t) {
                ct.asn1.x509.SubjectKeyIdentifier.superclass.constructor.call(this, t);
                var e = ct.asn1.DEROctetString;
                this.asn1KID = null, this.getExtnValueHex = function() {
                    return this.asn1ExtnValue = this.asn1KID, this.asn1ExtnValue.getEncodedHex()
                }, this.setKIDByParam = function(t) {
                    if (void 0 !== t.str || void 0 !== t.hex) this.asn1KID = new e(t);
                    else if ("object" == typeof t && ct.crypto.Util.isKey(t) || "string" == typeof t && -1 != t.indexOf("BEGIN")) {
                        var r = t;
                        "string" == typeof t && (r = Ht.getKey(t));
                        var n = Ht.getKeyID(r);
                        this.asn1KID = new ct.asn1.DEROctetString({
                            hex: n
                        })
                    }
                }, this.oid = "2.5.29.14", void 0 !== t && void 0 !== t.kid && this.setKIDByParam(t.kid)
            }, i.lang.extend(ct.asn1.x509.SubjectKeyIdentifier, ct.asn1.x509.Extension), ct.asn1.x509.AuthorityInfoAccess = function(t) {
                ct.asn1.x509.AuthorityInfoAccess.superclass.constructor.call(this, t), this.setAccessDescriptionArray = function(t) {
                    for (var e = new Array, r = ct.asn1, n = r.DERSequence, i = r.DERObjectIdentifier, s = r.x509.GeneralName, a = 0; a < t.length; a++) {
                        var o, u = t[a];
                        if (void 0 !== u.ocsp) o = new n({
                            array: [new i({
                                oid: "1.3.6.1.5.5.7.48.1"
                            }), new s({
                                uri: u.ocsp
                            })]
                        });
                        else {
                            if (void 0 === u.caissuer) throw new Error("unknown AccessMethod parameter: " + JSON.stringify(u));
                            o = new n({
                                array: [new i({
                                    oid: "1.3.6.1.5.5.7.48.2"
                                }), new s({
                                    uri: u.caissuer
                                })]
                            })
                        }
                        e.push(o)
                    }
                    this.asn1ExtnValue = new n({
                        array: e
                    })
                }, this.getExtnValueHex = function() {
                    return this.asn1ExtnValue.getEncodedHex()
                }, this.oid = "1.3.6.1.5.5.7.1.1", void 0 !== t && void 0 !== t.array && this.setAccessDescriptionArray(t.array)
            }, i.lang.extend(ct.asn1.x509.AuthorityInfoAccess, ct.asn1.x509.Extension), ct.asn1.x509.SubjectAltName = function(t) {
                ct.asn1.x509.SubjectAltName.superclass.constructor.call(this, t), this.setNameArray = function(t) {
                    this.asn1ExtnValue = new ct.asn1.x509.GeneralNames(t)
                }, this.getExtnValueHex = function() {
                    return this.asn1ExtnValue.getEncodedHex()
                }, this.oid = "2.5.29.17", void 0 !== t && void 0 !== t.array && this.setNameArray(t.array)
            }, i.lang.extend(ct.asn1.x509.SubjectAltName, ct.asn1.x509.Extension), ct.asn1.x509.IssuerAltName = function(t) {
                ct.asn1.x509.IssuerAltName.superclass.constructor.call(this, t), this.setNameArray = function(t) {
                    this.asn1ExtnValue = new ct.asn1.x509.GeneralNames(t)
                }, this.getExtnValueHex = function() {
                    return this.asn1ExtnValue.getEncodedHex()
                }, this.oid = "2.5.29.18", void 0 !== t && void 0 !== t.array && this.setNameArray(t.array)
            }, i.lang.extend(ct.asn1.x509.IssuerAltName, ct.asn1.x509.Extension), ct.asn1.x509.PrivateExtension = function(t) {
                ct.asn1.x509.PrivateExtension.superclass.constructor.call(this, t);
                var e = ct,
                    r = e.lang.String.isHex,
                    n = e.asn1,
                    i = n.x509.OID.name2oid,
                    s = n.ASN1Util.newObject;
                this.params = null, this.setByParam = function(t) {
                    this.oid = i(t.extname), this.params = t
                }, this.getExtnValueHex = function() {
                    if (null == this.params.extname || null == this.params.extn) throw new Error("extname or extnhex not specified");
                    var t = this.params.extn;
                    if ("string" == typeof t && r(t)) return t;
                    if ("object" == typeof t) try {
                        return s(t).getEncodedHex()
                    } catch (t) {}
                    throw new Error("unsupported extn value")
                }, null != t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.x509.PrivateExtension, ct.asn1.x509.Extension), ct.asn1.x509.CRL = function(t) {
                ct.asn1.x509.CRL.superclass.constructor.call(this);
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.DERBitString,
                    i = e.x509,
                    s = i.AlgorithmIdentifier,
                    a = i.TBSCertList;
                this.params = void 0, this.setByParam = function(t) {
                    this.params = t
                }, this.sign = function() {
                    var t = new a(this.params).getEncodedHex(),
                        e = new ct.crypto.Signature({
                            alg: this.params.sigalg
                        });
                    e.init(this.params.cakey), e.updateHex(t);
                    var r = e.sign();
                    this.params.sighex = r
                }, this.getPEM = function() {
                    return Bt(this.getEncodedHex(), "X509 CRL")
                }, this.getEncodedHex = function() {
                    var t = this.params;
                    if (null == t.tbsobj && (t.tbsobj = new a(t)), null == t.sighex && null != t.cakey && this.sign(), null == t.sighex) throw new Error("sighex or cakey parameter not defined");
                    var e = [];
                    return e.push(t.tbsobj), e.push(new s({
                        name: t.sigalg
                    })), e.push(new n({
                        hex: "00" + t.sighex
                    })), new r({
                        array: e
                    }).getEncodedHex()
                }, null != t && (this.params = t)
            }, i.lang.extend(ct.asn1.x509.CRL, ct.asn1.ASN1Object), ct.asn1.x509.TBSCertList = function(t) {
                ct.asn1.x509.TBSCertList.superclass.constructor.call(this);
                var e = ct.asn1,
                    r = e.DERInteger,
                    n = e.DERSequence,
                    i = e.DERTaggedObject,
                    s = (e.DERObjectIdentifier, e.x509),
                    a = s.AlgorithmIdentifier,
                    o = s.Time,
                    u = s.Extensions,
                    c = s.X500Name;
                this.params = null, this.setByParam = function(t) {
                    this.params = t
                }, this.getRevCertSequence = function() {
                    for (var t = [], e = this.params.revcert, i = 0; i < e.length; i++) {
                        var s = [new r(e[i].sn), new o(e[i].date)];
                        null != e[i].ext && s.push(new u(e[i].ext)), t.push(new n({
                            array: s
                        }))
                    }
                    return new n({
                        array: t
                    })
                }, this.getEncodedHex = function() {
                    var t = [],
                        e = this.params;
                    if (null != e.version) {
                        var s = e.version - 1,
                            h = new r({
                                int: s
                            });
                        t.push(h)
                    }
                    if (t.push(new a({
                            name: e.sigalg
                        })), t.push(new c(e.issuer)), t.push(new o(e.thisupdate)), null != e.nextupdate && t.push(new o(e.nextupdate)), null != e.revcert && t.push(this.getRevCertSequence()), null != e.ext) {
                        var l = new u(e.ext);
                        t.push(new i({
                            tag: "a0",
                            explicit: !0,
                            obj: l
                        }))
                    }
                    return new n({
                        array: t
                    }).getEncodedHex()
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.x509.TBSCertList, ct.asn1.ASN1Object), ct.asn1.x509.CRLEntry = function(t) {
                ct.asn1.x509.CRLEntry.superclass.constructor.call(this);
                var e = ct.asn1;
                this.setCertSerial = function(t) {
                    this.sn = new e.DERInteger(t)
                }, this.setRevocationDate = function(t) {
                    this.time = new e.x509.Time(t)
                }, this.getEncodedHex = function() {
                    var t = new e.DERSequence({
                        array: [this.sn, this.time]
                    });
                    return this.TLV = t.getEncodedHex(), this.TLV
                }, void 0 !== t && (void 0 !== t.time && this.setRevocationDate(t.time), void 0 !== t.sn && this.setCertSerial(t.sn))
            }, i.lang.extend(ct.asn1.x509.CRLEntry, ct.asn1.ASN1Object), ct.asn1.x509.CRLNumber = function(t) {
                ct.asn1.x509.CRLNumber.superclass.constructor.call(this, t), this.params = void 0, this.getExtnValueHex = function() {
                    return this.asn1ExtnValue = new ct.asn1.DERInteger(this.params.num), this.asn1ExtnValue.getEncodedHex()
                }, this.oid = "2.5.29.20", null != t && (this.params = t)
            }, i.lang.extend(ct.asn1.x509.CRLNumber, ct.asn1.x509.Extension), ct.asn1.x509.CRLReason = function(t) {
                ct.asn1.x509.CRLReason.superclass.constructor.call(this, t), this.params = void 0, this.getExtnValueHex = function() {
                    return this.asn1ExtnValue = new ct.asn1.DEREnumerated(this.params.code), this.asn1ExtnValue.getEncodedHex()
                }, this.oid = "2.5.29.21", null != t && (this.params = t)
            }, i.lang.extend(ct.asn1.x509.CRLReason, ct.asn1.x509.Extension), ct.asn1.x509.OCSPNonce = function(t) {
                ct.asn1.x509.OCSPNonce.superclass.constructor.call(this, t), this.params = void 0, this.getExtnValueHex = function() {
                    return this.asn1ExtnValue = new ct.asn1.DEROctetString(this.params), this.asn1ExtnValue.getEncodedHex()
                }, this.oid = "1.3.6.1.5.5.7.48.1.2", null != t && (this.params = t)
            }, i.lang.extend(ct.asn1.x509.OCSPNonce, ct.asn1.x509.Extension), ct.asn1.x509.OCSPNoCheck = function(t) {
                ct.asn1.x509.OCSPNoCheck.superclass.constructor.call(this, t), this.params = void 0, this.getExtnValueHex = function() {
                    return this.asn1ExtnValue = new ct.asn1.DERNull, this.asn1ExtnValue.getEncodedHex()
                }, this.oid = "1.3.6.1.5.5.7.48.1.5", null != t && (this.params = t)
            }, i.lang.extend(ct.asn1.x509.OCSPNoCheck, ct.asn1.x509.Extension), ct.asn1.x509.X500Name = function(t) {
                ct.asn1.x509.X500Name.superclass.constructor.call(this), this.asn1Array = [], this.paramArray = [], this.sRule = "utf8";
                var e = ct.asn1,
                    r = e.x509,
                    n = r.RDN;
                this.setByString = function(t, e) {
                    void 0 !== e && (this.sRule = e);
                    var r = t.split("/");
                    r.shift();
                    for (var i = [], s = 0; s < r.length; s++)
                        if (r[s].match(/^[^=]+=.+$/)) i.push(r[s]);
                        else {
                            var a = i.length - 1;
                            i[a] = i[a] + "/" + r[s]
                        }
                    for (s = 0; s < i.length; s++) this.asn1Array.push(new n({
                        str: i[s],
                        rule: this.sRule
                    }))
                }, this.setByLdapString = function(t, e) {
                    void 0 !== e && (this.sRule = e);
                    var n = r.X500Name.ldapToCompat(t);
                    this.setByString(n, e)
                }, this.setByObject = function(t, e) {
                    for (var r in void 0 !== e && (this.sRule = e), t)
                        if (t.hasOwnProperty(r)) {
                            var i = new n({
                                str: r + "=" + t[r],
                                rule: this.sRule
                            });
                            this.asn1Array ? this.asn1Array.push(i) : this.asn1Array = [i]
                        }
                }, this.setByParam = function(t) {
                    var e;
                    (void 0 !== t.rule && (this.sRule = t.rule), void 0 !== t.array) ? this.paramArray = t.array: void 0 !== t.str ? this.setByString(t.str) : void 0 !== t.ldapstr ? this.setByLdapString(t.ldapstr) : void 0 !== t.hex ? this.hTLV = t.hex : void 0 !== t.certissuer ? ((e = new zt).readCertPEM(t.certissuer), this.hTLV = e.getIssuerHex()) : void 0 !== t.certsubject ? ((e = new zt).readCertPEM(t.certsubject), this.hTLV = e.getSubjectHex()) : "object" == typeof t && void 0 === t.certsubject && void 0 === t.certissuer && this.setByObject(t)
                }, this.getEncodedHex = function() {
                    if ("string" == typeof this.hTLV) return this.hTLV;
                    if (0 == this.asn1Array.length && this.paramArray.length > 0)
                        for (var t = 0; t < this.paramArray.length; t++) {
                            var r = {
                                array: this.paramArray[t]
                            };
                            "utf8" != this.sRule && (r.rule = this.sRule);
                            var i = new n(r);
                            this.asn1Array.push(i)
                        }
                    var s = new e.DERSequence({
                        array: this.asn1Array
                    });
                    return this.hTLV = s.getEncodedHex(), this.hTLV
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.x509.X500Name, ct.asn1.ASN1Object), ct.asn1.x509.X500Name.compatToLDAP = function(t) {
                if ("/" !== t.substr(0, 1)) throw "malformed input";
                var e = (t = t.substr(1)).split("/");
                return e.reverse(), (e = e.map((function(t) {
                    return t.replace(/,/, "\\,")
                }))).join(",")
            }, ct.asn1.x509.X500Name.onelineToLDAP = function(t) {
                return ct.asn1.x509.X500Name.compatToLDAP(t)
            }, ct.asn1.x509.X500Name.ldapToCompat = function(t) {
                for (var e = t.split(","), r = !1, n = [], i = 0; e.length > 0; i++) {
                    var s = e.shift();
                    if (!0 === r) {
                        var a = (n.pop() + "," + s).replace(/\\,/g, ",");
                        n.push(a), r = !1
                    } else n.push(s);
                    "\\" === s.substr(-1, 1) && (r = !0)
                }
                return (n = n.map((function(t) {
                    return t.replace("/", "\\/")
                }))).reverse(), "/" + n.join("/")
            }, ct.asn1.x509.X500Name.ldapToOneline = function(t) {
                return ct.asn1.x509.X500Name.ldapToCompat(t)
            }, ct.asn1.x509.RDN = function(t) {
                ct.asn1.x509.RDN.superclass.constructor.call(this), this.asn1Array = [], this.paramArray = [], this.sRule = "utf8";
                var e = ct.asn1.x509.AttributeTypeAndValue;
                this.setByParam = function(t) {
                    void 0 !== t.rule && (this.sRule = t.rule), void 0 !== t.str && this.addByMultiValuedString(t.str), void 0 !== t.array && (this.paramArray = t.array)
                }, this.addByString = function(t) {
                    this.asn1Array.push(new ct.asn1.x509.AttributeTypeAndValue({
                        str: t,
                        rule: this.sRule
                    }))
                }, this.addByMultiValuedString = function(t) {
                    for (var e = ct.asn1.x509.RDN.parseString(t), r = 0; r < e.length; r++) this.addByString(e[r])
                }, this.getEncodedHex = function() {
                    if (0 == this.asn1Array.length && this.paramArray.length > 0)
                        for (var t = 0; t < this.paramArray.length; t++) {
                            var r = this.paramArray[t];
                            void 0 !== r.rule && "utf8" != this.sRule && (r.rule = this.sRule);
                            var n = new e(r);
                            this.asn1Array.push(n)
                        }
                    var i = new ct.asn1.DERSet({
                        array: this.asn1Array
                    });
                    return this.TLV = i.getEncodedHex(), this.TLV
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.x509.RDN, ct.asn1.ASN1Object), ct.asn1.x509.RDN.parseString = function(t) {
                for (var e = t.split(/\+/), r = !1, n = [], i = 0; e.length > 0; i++) {
                    var s = e.shift();
                    if (!0 === r) {
                        var a = (n.pop() + "+" + s).replace(/\\\+/g, "+");
                        n.push(a), r = !1
                    } else n.push(s);
                    "\\" === s.substr(-1, 1) && (r = !0)
                }
                var o = !1,
                    u = [];
                for (i = 0; n.length > 0; i++) {
                    s = n.shift();
                    if (!0 === o) {
                        var c = u.pop();
                        if (s.match(/"$/)) {
                            a = (c + "+" + s).replace(/^([^=]+)="(.*)"$/, "$1=$2");
                            u.push(a), o = !1
                        } else u.push(c + "+" + s)
                    } else u.push(s);
                    s.match(/^[^=]+="/) && (o = !0)
                }
                return u
            }, ct.asn1.x509.AttributeTypeAndValue = function(t) {
                ct.asn1.x509.AttributeTypeAndValue.superclass.constructor.call(this), this.sRule = "utf8", this.sType = null, this.sValue = null, this.dsType = null;
                var e = ct,
                    r = e.asn1,
                    n = r.DERSequence,
                    i = r.DERUTF8String,
                    s = r.DERPrintableString,
                    a = r.DERTeletexString,
                    o = r.DERIA5String,
                    u = r.DERVisibleString,
                    c = r.DERBMPString,
                    h = e.lang.String.isMail,
                    l = e.lang.String.isPrintable;
                this.setByParam = function(t) {
                    if (void 0 !== t.rule && (this.sRule = t.rule), void 0 !== t.ds && (this.dsType = t.ds), void 0 === t.value && void 0 !== t.str) {
                        var e = t.str.match(/^([^=]+)=(.+)$/);
                        if (!e) throw new Error("malformed attrTypeAndValueStr: " + attrTypeAndValueStr);
                        this.sType = e[1], this.sValue = e[2]
                    } else this.sType = t.type, this.sValue = t.value
                }, this.setByString = function(t, e) {
                    void 0 !== e && (this.sRule = e);
                    var r = t.match(/^([^=]+)=(.+)$/);
                    if (!r) throw new Error("malformed attrTypeAndValueStr: " + attrTypeAndValueStr);
                    this.setByAttrTypeAndValueStr(r[1], r[2])
                }, this._getDsType = function() {
                    var t = this.sType,
                        e = this.sValue,
                        r = this.sRule;
                    return "prn" === r ? "CN" == t && h(e) ? "ia5" : l(e) ? "prn" : "utf8" : "utf8" === r ? "CN" == t && h(e) ? "ia5" : "C" == t ? "prn" : "utf8" : "utf8"
                }, this.setByAttrTypeAndValueStr = function(t, e, r) {
                    void 0 !== r && (this.sRule = r), this.sType = t, this.sValue = e
                }, this.getValueObj = function(t, e) {
                    if ("utf8" == t) return new i({
                        str: e
                    });
                    if ("prn" == t) return new s({
                        str: e
                    });
                    if ("tel" == t) return new a({
                        str: e
                    });
                    if ("ia5" == t) return new o({
                        str: e
                    });
                    if ("vis" == t) return new u({
                        str: e
                    });
                    if ("bmp" == t) return new c({
                        str: e
                    });
                    throw new Error("unsupported directory string type: type=" + t + " value=" + e)
                }, this.getEncodedHex = function() {
                    null == this.dsType && (this.dsType = this._getDsType());
                    var t = ct.asn1.x509.OID.atype2obj(this.sType),
                        e = this.getValueObj(this.dsType, this.sValue),
                        r = new n({
                            array: [t, e]
                        });
                    return this.TLV = r.getEncodedHex(), this.TLV
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.x509.AttributeTypeAndValue, ct.asn1.ASN1Object), ct.asn1.x509.SubjectPublicKeyInfo = function(t) {
                ct.asn1.x509.SubjectPublicKeyInfo.superclass.constructor.call(this);
                var e = ct,
                    r = e.asn1,
                    n = r.DERInteger,
                    i = r.DERBitString,
                    s = r.DERObjectIdentifier,
                    a = r.DERSequence,
                    o = r.ASN1Util.newObject,
                    u = r.x509.AlgorithmIdentifier,
                    c = e.crypto;
                c.ECDSA, c.DSA;
                this.getASN1Object = function() {
                    if (null == this.asn1AlgId || null == this.asn1SubjPKey) throw "algId and/or subjPubKey not set";
                    return new a({
                        array: [this.asn1AlgId, this.asn1SubjPKey]
                    })
                }, this.getEncodedHex = function() {
                    var t = this.getASN1Object();
                    return this.hTLV = t.getEncodedHex(), this.hTLV
                }, this.setPubKey = function(t) {
                    try {
                        if (t instanceof nt) {
                            var e = o({
                                seq: [{
                                    int: {
                                        bigint: t.n
                                    }
                                }, {
                                    int: {
                                        int: t.e
                                    }
                                }]
                            }).getEncodedHex();
                            this.asn1AlgId = new u({
                                name: "rsaEncryption"
                            }), this.asn1SubjPKey = new i({
                                hex: "00" + e
                            })
                        }
                    } catch (t) {}
                    try {
                        if (t instanceof ct.crypto.ECDSA) {
                            var r = new s({
                                name: t.curveName
                            });
                            this.asn1AlgId = new u({
                                name: "ecPublicKey",
                                asn1params: r
                            }), this.asn1SubjPKey = new i({
                                hex: "00" + t.pubKeyHex
                            })
                        }
                    } catch (t) {}
                    try {
                        if (t instanceof ct.crypto.DSA) {
                            r = new o({
                                seq: [{
                                    int: {
                                        bigint: t.p
                                    }
                                }, {
                                    int: {
                                        bigint: t.q
                                    }
                                }, {
                                    int: {
                                        bigint: t.g
                                    }
                                }]
                            });
                            this.asn1AlgId = new u({
                                name: "dsa",
                                asn1params: r
                            });
                            var a = new n({
                                bigint: t.y
                            });
                            this.asn1SubjPKey = new i({
                                hex: "00" + a.getEncodedHex()
                            })
                        }
                    } catch (t) {}
                }, void 0 !== t && this.setPubKey(t)
            }, i.lang.extend(ct.asn1.x509.SubjectPublicKeyInfo, ct.asn1.ASN1Object), ct.asn1.x509.Time = function(t) {
                ct.asn1.x509.Time.superclass.constructor.call(this);
                var e = ct.asn1,
                    r = e.DERUTCTime,
                    n = e.DERGeneralizedTime;
                this.setTimeParams = function(t) {
                    this.timeParams = t
                }, this.getEncodedHex = function() {
                    var t = null;
                    return t = null != this.timeParams ? "utc" == this.type ? new r(this.timeParams) : new n(this.timeParams) : "utc" == this.type ? new r : new n, this.TLV = t.getEncodedHex(), this.TLV
                }, this.type = "utc", void 0 !== t && (void 0 !== t.type ? this.type = t.type : void 0 !== t.str && (t.str.match(/^[0-9]{12}Z$/) && (this.type = "utc"), t.str.match(/^[0-9]{14}Z$/) && (this.type = "gen")), this.timeParams = t)
            }, i.lang.extend(ct.asn1.x509.Time, ct.asn1.ASN1Object), ct.asn1.x509.AlgorithmIdentifier = function(t) {
                ct.asn1.x509.AlgorithmIdentifier.superclass.constructor.call(this), this.nameAlg = null, this.asn1Alg = null, this.asn1Params = null, this.paramEmpty = !1;
                var e = ct.asn1,
                    r = e.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;
                if (this.getEncodedHex = function() {
                        if (null === this.nameAlg && null === this.asn1Alg) throw new Error("algorithm not specified");
                        if (null !== this.nameAlg) {
                            var t = null;
                            for (var n in r) n === this.nameAlg && (t = r[n]);
                            if (null !== t) return this.hTLV = t, this.hTLV
                        }
                        null !== this.nameAlg && null === this.asn1Alg && (this.asn1Alg = e.x509.OID.name2obj(this.nameAlg));
                        var i = [this.asn1Alg];
                        null !== this.asn1Params && i.push(this.asn1Params);
                        var s = new e.DERSequence({
                            array: i
                        });
                        return this.hTLV = s.getEncodedHex(), this.hTLV
                    }, void 0 !== t && (void 0 !== t.name && (this.nameAlg = t.name), void 0 !== t.asn1params && (this.asn1Params = t.asn1params), void 0 !== t.paramempty && (this.paramEmpty = t.paramempty)), null === this.asn1Params && !1 === this.paramEmpty && null !== this.nameAlg) {
                    void 0 !== this.nameAlg.name && (this.nameAlg = this.nameAlg.name);
                    var n = this.nameAlg.toLowerCase();
                    "withdsa" !== n.substr(-7, 7) && "withecdsa" !== n.substr(-9, 9) && (this.asn1Params = new e.DERNull)
                }
            }, i.lang.extend(ct.asn1.x509.AlgorithmIdentifier, ct.asn1.ASN1Object), ct.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV = {
                SHAwithRSAandMGF1: "300d06092a864886f70d01010a3000",
                SHA256withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040201a11a301806092a864886f70d010108300b0609608648016503040201a203020120",
                SHA384withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040202a11a301806092a864886f70d010108300b0609608648016503040202a203020130",
                SHA512withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040203a11a301806092a864886f70d010108300b0609608648016503040203a203020140"
            }, ct.asn1.x509.GeneralName = function(t) {
                ct.asn1.x509.GeneralName.superclass.constructor.call(this);
                var e = {
                        rfc822: "81",
                        dns: "82",
                        dn: "a4",
                        uri: "86",
                        ip: "87"
                    },
                    r = ct.asn1,
                    n = (r.DERSequence, r.DEROctetString),
                    i = r.DERIA5String,
                    s = r.DERTaggedObject,
                    a = r.ASN1Object,
                    o = r.x509.X500Name,
                    u = Ft;
                this.explicit = !1, this.setByParam = function(t) {
                    var r = null;
                    if (void 0 !== t) {
                        if (void 0 !== t.rfc822 && (this.type = "rfc822", r = new i({
                                str: t[this.type]
                            })), void 0 !== t.dns && (this.type = "dns", r = new i({
                                str: t[this.type]
                            })), void 0 !== t.uri && (this.type = "uri", r = new i({
                                str: t[this.type]
                            })), void 0 !== t.dn && (this.type = "dn", this.explicit = !0, r = "string" == typeof t.dn ? new o({
                                str: t.dn
                            }) : t.dn instanceof ct.asn1.x509.X500Name ? t.dn : new o(t.dn)), void 0 !== t.ldapdn && (this.type = "dn", this.explicit = !0, r = new o({
                                ldapstr: t.ldapdn
                            })), void 0 !== t.certissuer) {
                            this.type = "dn", this.explicit = !0;
                            var c = null;
                            if ((l = t.certissuer).match(/^[0-9A-Fa-f]+$/), -1 != l.indexOf("-----BEGIN ") && (c = u(l)), null == c) throw "certissuer param not cert";
                            (f = new zt).hex = c;
                            var h = f.getIssuerHex();
                            (r = new a).hTLV = h
                        }
                        if (void 0 !== t.certsubj) {
                            this.type = "dn", this.explicit = !0;
                            var l, f;
                            c = null;
                            if ((l = t.certsubj).match(/^[0-9A-Fa-f]+$/), -1 != l.indexOf("-----BEGIN ") && (c = u(l)), null == c) throw "certsubj param not cert";
                            (f = new zt).hex = c;
                            h = f.getSubjectHex();
                            (r = new a).hTLV = h
                        }
                        if (void 0 !== t.ip) {
                            this.type = "ip", this.explicit = !1;
                            var p, d = t.ip,
                                g = "malformed IP address";
                            if (d.match(/^[0-9.]+[.][0-9.]+$/)) {
                                if (8 !== (p = Vt("[" + d.split(".").join(",") + "]")).length) throw g
                            } else if (d.match(/^[0-9A-Fa-f:]+:[0-9A-Fa-f:]+$/)) p = Pt(d);
                            else {
                                if (!d.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/)) throw g;
                                p = d
                            }
                            r = new n({
                                hex: p
                            })
                        }
                        if (null == this.type) throw "unsupported type in params=" + t;
                        this.asn1Obj = new s({
                            explicit: this.explicit,
                            tag: e[this.type],
                            obj: r
                        })
                    }
                }, this.getEncodedHex = function() {
                    return this.asn1Obj.getEncodedHex()
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.x509.GeneralName, ct.asn1.ASN1Object), ct.asn1.x509.GeneralNames = function(t) {
                ct.asn1.x509.GeneralNames.superclass.constructor.call(this);
                var e = ct.asn1;
                this.setByParamArray = function(t) {
                    for (var r = 0; r < t.length; r++) {
                        var n = new e.x509.GeneralName(t[r]);
                        this.asn1Array.push(n)
                    }
                }, this.getEncodedHex = function() {
                    return new e.DERSequence({
                        array: this.asn1Array
                    }).getEncodedHex()
                }, this.asn1Array = new Array, void 0 !== t && this.setByParamArray(t)
            }, i.lang.extend(ct.asn1.x509.GeneralNames, ct.asn1.ASN1Object), ct.asn1.x509.OID = new function(t) {
                this.atype2oidList = {
                    CN: "2.5.4.3",
                    L: "2.5.4.7",
                    ST: "2.5.4.8",
                    O: "2.5.4.10",
                    OU: "2.5.4.11",
                    C: "2.5.4.6",
                    STREET: "2.5.4.9",
                    DC: "0.9.2342.19200300.100.1.25",
                    UID: "0.9.2342.19200300.100.1.1",
                    SN: "2.5.4.4",
                    T: "2.5.4.12",
                    DN: "2.5.4.49",
                    E: "1.2.840.113549.1.9.1",
                    description: "2.5.4.13",
                    businessCategory: "2.5.4.15",
                    postalCode: "2.5.4.17",
                    serialNumber: "2.5.4.5",
                    uniqueIdentifier: "2.5.4.45",
                    organizationIdentifier: "2.5.4.97",
                    jurisdictionOfIncorporationL: "1.3.6.1.4.1.311.60.2.1.1",
                    jurisdictionOfIncorporationSP: "1.3.6.1.4.1.311.60.2.1.2",
                    jurisdictionOfIncorporationC: "1.3.6.1.4.1.311.60.2.1.3"
                }, this.name2oidList = {
                    sha1: "1.3.14.3.2.26",
                    sha256: "2.16.840.1.101.3.4.2.1",
                    sha384: "2.16.840.1.101.3.4.2.2",
                    sha512: "2.16.840.1.101.3.4.2.3",
                    sha224: "2.16.840.1.101.3.4.2.4",
                    md5: "1.2.840.113549.2.5",
                    md2: "1.3.14.7.2.2.1",
                    ripemd160: "1.3.36.3.2.1",
                    MD2withRSA: "1.2.840.113549.1.1.2",
                    MD4withRSA: "1.2.840.113549.1.1.3",
                    MD5withRSA: "1.2.840.113549.1.1.4",
                    SHA1withRSA: "1.2.840.113549.1.1.5",
                    "pkcs1-MGF": "1.2.840.113549.1.1.8",
                    rsaPSS: "1.2.840.113549.1.1.10",
                    SHA224withRSA: "1.2.840.113549.1.1.14",
                    SHA256withRSA: "1.2.840.113549.1.1.11",
                    SHA384withRSA: "1.2.840.113549.1.1.12",
                    SHA512withRSA: "1.2.840.113549.1.1.13",
                    SHA1withECDSA: "1.2.840.10045.4.1",
                    SHA224withECDSA: "1.2.840.10045.4.3.1",
                    SHA256withECDSA: "1.2.840.10045.4.3.2",
                    SHA384withECDSA: "1.2.840.10045.4.3.3",
                    SHA512withECDSA: "1.2.840.10045.4.3.4",
                    dsa: "1.2.840.10040.4.1",
                    SHA1withDSA: "1.2.840.10040.4.3",
                    SHA224withDSA: "2.16.840.1.101.3.4.3.1",
                    SHA256withDSA: "2.16.840.1.101.3.4.3.2",
                    rsaEncryption: "1.2.840.113549.1.1.1",
                    commonName: "2.5.4.3",
                    countryName: "2.5.4.6",
                    localityName: "2.5.4.7",
                    stateOrProvinceName: "2.5.4.8",
                    streetAddress: "2.5.4.9",
                    organizationName: "2.5.4.10",
                    organizationalUnitName: "2.5.4.11",
                    domainComponent: "0.9.2342.19200300.100.1.25",
                    userId: "0.9.2342.19200300.100.1.1",
                    surname: "2.5.4.4",
                    title: "2.5.4.12",
                    distinguishedName: "2.5.4.49",
                    emailAddress: "1.2.840.113549.1.9.1",
                    description: "2.5.4.13",
                    businessCategory: "2.5.4.15",
                    postalCode: "2.5.4.17",
                    uniqueIdentifier: "2.5.4.45",
                    organizationIdentifier: "2.5.4.97",
                    jurisdictionOfIncorporationL: "1.3.6.1.4.1.311.60.2.1.1",
                    jurisdictionOfIncorporationSP: "1.3.6.1.4.1.311.60.2.1.2",
                    jurisdictionOfIncorporationC: "1.3.6.1.4.1.311.60.2.1.3",
                    subjectKeyIdentifier: "2.5.29.14",
                    keyUsage: "2.5.29.15",
                    subjectAltName: "2.5.29.17",
                    issuerAltName: "2.5.29.18",
                    basicConstraints: "2.5.29.19",
                    cRLNumber: "2.5.29.20",
                    cRLReason: "2.5.29.21",
                    nameConstraints: "2.5.29.30",
                    cRLDistributionPoints: "2.5.29.31",
                    certificatePolicies: "2.5.29.32",
                    anyPolicy: "2.5.29.32.0",
                    authorityKeyIdentifier: "2.5.29.35",
                    policyConstraints: "2.5.29.36",
                    extKeyUsage: "2.5.29.37",
                    authorityInfoAccess: "1.3.6.1.5.5.7.1.1",
                    ocsp: "1.3.6.1.5.5.7.48.1",
                    ocspBasic: "1.3.6.1.5.5.7.48.1.1",
                    ocspNonce: "1.3.6.1.5.5.7.48.1.2",
                    ocspNoCheck: "1.3.6.1.5.5.7.48.1.5",
                    caIssuers: "1.3.6.1.5.5.7.48.2",
                    anyExtendedKeyUsage: "2.5.29.37.0",
                    serverAuth: "1.3.6.1.5.5.7.3.1",
                    clientAuth: "1.3.6.1.5.5.7.3.2",
                    codeSigning: "1.3.6.1.5.5.7.3.3",
                    emailProtection: "1.3.6.1.5.5.7.3.4",
                    timeStamping: "1.3.6.1.5.5.7.3.8",
                    ocspSigning: "1.3.6.1.5.5.7.3.9",
                    ecPublicKey: "1.2.840.10045.2.1",
                    secp256r1: "1.2.840.10045.3.1.7",
                    secp256k1: "1.3.132.0.10",
                    secp384r1: "1.3.132.0.34",
                    pkcs5PBES2: "1.2.840.113549.1.5.13",
                    pkcs5PBKDF2: "1.2.840.113549.1.5.12",
                    "des-EDE3-CBC": "1.2.840.113549.3.7",
                    data: "1.2.840.113549.1.7.1",
                    "signed-data": "1.2.840.113549.1.7.2",
                    "enveloped-data": "1.2.840.113549.1.7.3",
                    "digested-data": "1.2.840.113549.1.7.5",
                    "encrypted-data": "1.2.840.113549.1.7.6",
                    "authenticated-data": "1.2.840.113549.1.9.16.1.2",
                    tstinfo: "1.2.840.113549.1.9.16.1.4",
                    signingCertificate: "1.2.840.113549.1.9.16.2.12",
                    timeStampToken: "1.2.840.113549.1.9.16.2.14",
                    etsArchiveTimeStamp: "1.2.840.113549.1.9.16.2.27",
                    signingCertificateV2: "1.2.840.113549.1.9.16.2.47",
                    etsArchiveTimeStampV2: "1.2.840.113549.1.9.16.2.48",
                    extensionRequest: "1.2.840.113549.1.9.14",
                    contentType: "1.2.840.113549.1.9.3",
                    messageDigest: "1.2.840.113549.1.9.4",
                    signingTime: "1.2.840.113549.1.9.5",
                    counterSignature: "1.2.840.113549.1.9.6",
                    archiveTimeStampV3: "0.4.0.1733.2.4",
                    pdfRevocationInfoArchival: "1.2.840.113583.1.1.8"
                }, this.objCache = {}, this.name2obj = function(t) {
                    if (void 0 !== this.objCache[t]) return this.objCache[t];
                    if (void 0 === this.name2oidList[t]) throw "Name of ObjectIdentifier not defined: " + t;
                    var e = this.name2oidList[t],
                        r = new ct.asn1.DERObjectIdentifier({
                            oid: e
                        });
                    return this.objCache[t] = r, r
                }, this.atype2obj = function(t) {
                    if (void 0 !== this.objCache[t]) return this.objCache[t];
                    if (void 0 === this.atype2oidList[t]) throw "AttributeType name undefined: " + t;
                    var e = this.atype2oidList[t],
                        r = new ct.asn1.DERObjectIdentifier({
                            oid: e
                        });
                    return this.objCache[t] = r, r
                }
            }, ct.asn1.x509.OID.oid2name = function(t) {
                var e = ct.asn1.x509.OID.name2oidList;
                for (var r in e)
                    if (e[r] == t) return r;
                return ""
            }, ct.asn1.x509.OID.oid2atype = function(t) {
                var e = ct.asn1.x509.OID.atype2oidList;
                for (var r in e)
                    if (e[r] == t) return r;
                return t
            }, ct.asn1.x509.OID.name2oid = function(t) {
                if (t.match(/^[0-9.]+$/)) return t;
                var e = ct.asn1.x509.OID.name2oidList;
                return void 0 === e[t] ? "" : e[t]
            }, ct.asn1.x509.X509Util = {}, ct.asn1.x509.X509Util.newCertPEM = function(t) {
                var e = ct.asn1.x509;
                e.TBSCertificate;
                return new(0, e.Certificate)(t).getPEM()
            }, void 0 !== ct && ct || (ct = {}), void 0 !== ct.asn1 && ct.asn1 || (ct.asn1 = {}), void 0 !== ct.asn1.cms && ct.asn1.cms || (ct.asn1.cms = {}), ct.asn1.cms.Attribute = function(t) {
                var e = ct.asn1;
                e.cms.Attribute.superclass.constructor.call(this), this.getEncodedHex = function() {
                    var t, r, n;
                    t = new e.DERObjectIdentifier({
                        oid: this.attrTypeOid
                    }), r = new e.DERSet({
                        array: this.valueList
                    });
                    try {
                        r.getEncodedHex()
                    } catch (t) {
                        throw "fail valueSet.getEncodedHex in Attribute(1)/" + t
                    }
                    n = new e.DERSequence({
                        array: [t, r]
                    });
                    try {
                        this.hTLV = n.getEncodedHex()
                    } catch (t) {
                        throw "failed seq.getEncodedHex in Attribute(2)/" + t
                    }
                    return this.hTLV
                }
            }, i.lang.extend(ct.asn1.cms.Attribute, ct.asn1.ASN1Object), ct.asn1.cms.ContentType = function(t) {
                var e = ct.asn1;
                e.cms.ContentType.superclass.constructor.call(this), this.attrTypeOid = "1.2.840.113549.1.9.3";
                var r = null;
                if (void 0 !== t) {
                    r = new e.DERObjectIdentifier(t);
                    this.valueList = [r]
                }
            }, i.lang.extend(ct.asn1.cms.ContentType, ct.asn1.cms.Attribute), ct.asn1.cms.MessageDigest = function(t) {
                var e = ct,
                    r = e.asn1,
                    n = r.DEROctetString,
                    i = r.cms;
                if (i.MessageDigest.superclass.constructor.call(this), this.attrTypeOid = "1.2.840.113549.1.9.4", void 0 !== t)
                    if (t.eciObj instanceof i.EncapsulatedContentInfo && "string" == typeof t.hashAlg) {
                        var s = t.eciObj.eContentValueHex,
                            a = t.hashAlg;
                        (o = new n({
                            hex: e.crypto.Util.hashHex(s, a)
                        })).getEncodedHex(), this.valueList = [o]
                    } else {
                        var o;
                        (o = new n(t)).getEncodedHex(), this.valueList = [o]
                    }
            }, i.lang.extend(ct.asn1.cms.MessageDigest, ct.asn1.cms.Attribute), ct.asn1.cms.SigningTime = function(t) {
                var e = ct.asn1;
                if (e.cms.SigningTime.superclass.constructor.call(this), this.attrTypeOid = "1.2.840.113549.1.9.5", void 0 !== t) {
                    var r = new e.x509.Time(t);
                    try {
                        r.getEncodedHex()
                    } catch (t) {
                        throw "SigningTime.getEncodedHex() failed/" + t
                    }
                    this.valueList = [r]
                }
            }, i.lang.extend(ct.asn1.cms.SigningTime, ct.asn1.cms.Attribute), ct.asn1.cms.SigningCertificate = function(t) {
                var e = ct,
                    r = e.asn1,
                    n = r.DERSequence,
                    i = r.cms;
                e.crypto;
                i.SigningCertificate.superclass.constructor.call(this), this.attrTypeOid = "1.2.840.113549.1.9.16.2.12", this.setCerts = function(t) {
                    for (var s = [], a = 0; a < t.length; a++) {
                        var o = Ft(t[a]),
                            u = e.crypto.Util.hashHex(o, "sha1"),
                            c = new r.DEROctetString({
                                hex: u
                            });
                        c.getEncodedHex();
                        var h = new i.IssuerSerial({
                            cert: t[a]
                        });
                        h.getEncodedHex();
                        var l = new n({
                            array: [c, h]
                        });
                        l.getEncodedHex(), s.push(l)
                    }
                    var f = new n({
                        array: [new n({
                            array: s
                        })]
                    });
                    f.getEncodedHex(), this.valueList = [f]
                }, void 0 !== t && "object" == typeof t.array && this.setCerts(t.array)
            }, i.lang.extend(ct.asn1.cms.SigningCertificate, ct.asn1.cms.Attribute), ct.asn1.cms.SigningCertificateV2 = function(t) {
                var e = ct,
                    r = e.asn1,
                    n = r.DERSequence,
                    i = r.x509,
                    s = r.cms,
                    a = e.crypto;
                if (s.SigningCertificateV2.superclass.constructor.call(this), this.attrTypeOid = "1.2.840.113549.1.9.16.2.47", this.setCerts = function(t, e) {
                        for (var o = [], u = 0; u < t.length; u++) {
                            var c = Ft(t[u]),
                                h = [];
                            "sha256" !== e && h.push(new i.AlgorithmIdentifier({
                                name: e
                            }));
                            var l = a.Util.hashHex(c, e),
                                f = new r.DEROctetString({
                                    hex: l
                                });
                            f.getEncodedHex(), h.push(f);
                            var p = new s.IssuerSerial({
                                cert: t[u]
                            });
                            p.getEncodedHex(), h.push(p);
                            var d = new n({
                                array: h
                            });
                            d.getEncodedHex(), o.push(d)
                        }
                        var g = new n({
                            array: [new n({
                                array: o
                            })]
                        });
                        g.getEncodedHex(), this.valueList = [g]
                    }, void 0 !== t && "object" == typeof t.array) {
                    var o = "sha256";
                    "string" == typeof t.hashAlg && (o = t.hashAlg), this.setCerts(t.array, o)
                }
            }, i.lang.extend(ct.asn1.cms.SigningCertificateV2, ct.asn1.cms.Attribute), ct.asn1.cms.IssuerSerial = function(t) {
                var e = ct.asn1,
                    r = e.DERInteger,
                    n = e.cms,
                    i = e.x509,
                    s = i.X500Name,
                    a = i.GeneralNames,
                    o = zt;
                n.IssuerSerial.superclass.constructor.call(this);
                this.setByCertPEM = function(t) {
                    var e = Ft(t),
                        n = new o;
                    n.hex = e;
                    var i = n.getIssuerHex();
                    this.dIssuer = new s, this.dIssuer.hTLV = i;
                    var a = n.getSerialNumberHex();
                    this.dSerial = new r({
                        hex: a
                    })
                }, this.getEncodedHex = function() {
                    var t = new a([{
                            dn: this.dIssuer
                        }]),
                        r = new e.DERSequence({
                            array: [t, this.dSerial]
                        });
                    return this.hTLV = r.getEncodedHex(), this.hTLV
                }, void 0 !== t && ("string" == typeof t && -1 != t.indexOf("-----BEGIN ") && this.setByCertPEM(t), t.issuer && t.serial && (t.issuer instanceof s ? this.dIssuer = t.issuer : this.dIssuer = new s(t.issuer), t.serial instanceof r ? this.dSerial = t.serial : this.dSerial = new r(t.serial)), "string" == typeof t.cert && this.setByCertPEM(t.cert))
            }, i.lang.extend(ct.asn1.cms.IssuerSerial, ct.asn1.ASN1Object), ct.asn1.cms.IssuerAndSerialNumber = function(t) {
                var e = ct.asn1,
                    r = e.DERInteger,
                    n = e.cms,
                    i = e.x509.X500Name,
                    s = zt;
                n.IssuerAndSerialNumber.superclass.constructor.call(this);
                this.setByCertPEM = function(t) {
                    var e = Ft(t),
                        n = new s;
                    n.hex = e;
                    var a = n.getIssuerHex();
                    this.dIssuer = new i, this.dIssuer.hTLV = a;
                    var o = n.getSerialNumberHex();
                    this.dSerial = new r({
                        hex: o
                    })
                }, this.getEncodedHex = function() {
                    var t = new e.DERSequence({
                        array: [this.dIssuer, this.dSerial]
                    });
                    return this.hTLV = t.getEncodedHex(), this.hTLV
                }, void 0 !== t && ("string" == typeof t && -1 != t.indexOf("-----BEGIN ") && this.setByCertPEM(t), t.issuer && t.serial && (t.issuer instanceof i ? this.dIssuer = t.issuer : this.dIssuer = new i(t.issuer), t.serial instanceof r ? this.dSerial = t.serial : this.dSerial = new r(t.serial)), "string" == typeof t.cert && this.setByCertPEM(t.cert))
            }, i.lang.extend(ct.asn1.cms.IssuerAndSerialNumber, ct.asn1.ASN1Object), ct.asn1.cms.AttributeList = function(t) {
                var e = ct.asn1,
                    r = e.cms;
                r.AttributeList.superclass.constructor.call(this), this.list = new Array, this.sortFlag = !0, this.add = function(t) {
                    t instanceof r.Attribute && this.list.push(t)
                }, this.length = function() {
                    return this.list.length
                }, this.clear = function() {
                    this.list = new Array, this.hTLV = null, this.hV = null
                }, this.getEncodedHex = function() {
                    if ("string" == typeof this.hTLV) return this.hTLV;
                    var t = new e.DERSet({
                        array: this.list,
                        sortflag: this.sortFlag
                    });
                    return this.hTLV = t.getEncodedHex(), this.hTLV
                }, void 0 !== t && void 0 !== t.sortflag && 0 == t.sortflag && (this.sortFlag = !1)
            }, i.lang.extend(ct.asn1.cms.AttributeList, ct.asn1.ASN1Object), ct.asn1.cms.SignerInfo = function(t) {
                var e = ct,
                    r = e.asn1,
                    n = r.DERTaggedObject,
                    i = r.cms,
                    s = i.AttributeList,
                    a = i.ContentType,
                    o = i.EncapsulatedContentInfo,
                    u = i.MessageDigest,
                    c = i.SignedData,
                    h = r.x509.AlgorithmIdentifier,
                    l = e.crypto,
                    f = Ht;
                i.SignerInfo.superclass.constructor.call(this), this.dCMSVersion = new r.DERInteger({
                    int: 1
                }), this.dSignerIdentifier = null, this.dDigestAlgorithm = null, this.dSignedAttrs = new s, this.dSigAlg = null, this.dSig = null, this.dUnsignedAttrs = new s, this.setSignerIdentifier = function(t) {
                    if ("string" == typeof t && -1 != t.indexOf("CERTIFICATE") && -1 != t.indexOf("BEGIN") && -1 != t.indexOf("END")) {
                        this.dSignerIdentifier = new i.IssuerAndSerialNumber({
                            cert: t
                        })
                    }
                }, this.setForContentAndHash = function(t) {
                    var e = "data";
                    void 0 !== t.contentType && (e = t.contentType), void 0 !== t && (t.eciObj instanceof o && (this.dSignedAttrs.add(new a(e)), this.dSignedAttrs.add(new u({
                        eciObj: t.eciObj,
                        hashAlg: t.hashAlg
                    }))), void 0 !== t.sdObj && t.sdObj instanceof c && -1 == t.sdObj.digestAlgNameList.join(":").indexOf(t.hashAlg) && t.sdObj.digestAlgNameList.push(t.hashAlg), "string" == typeof t.hashAlg && (this.dDigestAlgorithm = new h({
                        name: t.hashAlg
                    })))
                }, this.sign = function(t, e) {
                    this.dSigAlg = new h({
                        name: e
                    });
                    var n = this.dSignedAttrs.getEncodedHex(),
                        i = f.getKey(t),
                        s = new l.Signature({
                            alg: e
                        });
                    s.init(i), s.updateHex(n);
                    var a = s.sign();
                    this.dSig = new r.DEROctetString({
                        hex: a
                    })
                }, this.addUnsigned = function(t) {
                    this.hTLV = null, this.dUnsignedAttrs.hTLV = null, this.dUnsignedAttrs.add(t)
                }, this.getEncodedHex = function() {
                    if (this.dSignedAttrs instanceof s && 0 == this.dSignedAttrs.length()) throw "SignedAttrs length = 0 (empty)";
                    var t = new n({
                            obj: this.dSignedAttrs,
                            tag: "a0",
                            explicit: !1
                        }),
                        e = null;
                    this.dUnsignedAttrs.length() > 0 && (e = new n({
                        obj: this.dUnsignedAttrs,
                        tag: "a1",
                        explicit: !1
                    }));
                    var i = [this.dCMSVersion, this.dSignerIdentifier, this.dDigestAlgorithm, t, this.dSigAlg, this.dSig];
                    null != e && i.push(e);
                    var a = new r.DERSequence({
                        array: i
                    });
                    return this.hTLV = a.getEncodedHex(), this.hTLV
                }
            }, i.lang.extend(ct.asn1.cms.SignerInfo, ct.asn1.ASN1Object), ct.asn1.cms.EncapsulatedContentInfo = function(t) {
                var e = ct.asn1,
                    r = e.DERTaggedObject,
                    n = e.DERSequence,
                    i = e.DERObjectIdentifier,
                    s = e.DEROctetString;
                e.cms.EncapsulatedContentInfo.superclass.constructor.call(this), this.dEContentType = new i({
                    name: "data"
                }), this.dEContent = null, this.isDetached = !1, this.eContentValueHex = null, this.setContentType = function(t) {
                    t.match(/^[0-2][.][0-9.]+$/) ? this.dEContentType = new i({
                        oid: t
                    }) : this.dEContentType = new i({
                        name: t
                    })
                }, this.setContentValue = function(t) {
                    void 0 !== t && ("string" == typeof t.hex ? this.eContentValueHex = t.hex : "string" == typeof t.str && (this.eContentValueHex = bt(t.str)))
                }, this.setContentValueHex = function(t) {
                    this.eContentValueHex = t
                }, this.setContentValueStr = function(t) {
                    this.eContentValueHex = bt(t)
                }, this.getEncodedHex = function() {
                    if ("string" != typeof this.eContentValueHex) throw "eContentValue not yet set";
                    var t = new s({
                        hex: this.eContentValueHex
                    });
                    this.dEContent = new r({
                        obj: t,
                        tag: "a0",
                        explicit: !0
                    });
                    var e = [this.dEContentType];
                    this.isDetached || e.push(this.dEContent);
                    var i = new n({
                        array: e
                    });
                    return this.hTLV = i.getEncodedHex(), this.hTLV
                }
            }, i.lang.extend(ct.asn1.cms.EncapsulatedContentInfo, ct.asn1.ASN1Object), ct.asn1.cms.ContentInfo = function(t) {
                var e = ct.asn1,
                    r = e.DERTaggedObject,
                    n = e.DERSequence,
                    i = e.x509;
                ct.asn1.cms.ContentInfo.superclass.constructor.call(this), this.dContentType = null, this.dContent = null, this.setContentType = function(t) {
                    "string" == typeof t && (this.dContentType = i.OID.name2obj(t))
                }, this.getEncodedHex = function() {
                    var t = new r({
                            obj: this.dContent,
                            tag: "a0",
                            explicit: !0
                        }),
                        e = new n({
                            array: [this.dContentType, t]
                        });
                    return this.hTLV = e.getEncodedHex(), this.hTLV
                }, void 0 !== t && (t.type && this.setContentType(t.type), t.obj && t.obj instanceof e.ASN1Object && (this.dContent = t.obj))
            }, i.lang.extend(ct.asn1.cms.ContentInfo, ct.asn1.ASN1Object), ct.asn1.cms.SignedData = function(t) {
                var e = ct.asn1,
                    r = e.ASN1Object,
                    n = e.DERInteger,
                    i = e.DERSet,
                    s = e.DERSequence,
                    a = e.DERTaggedObject,
                    o = e.cms,
                    u = o.EncapsulatedContentInfo,
                    c = o.SignerInfo,
                    h = o.ContentInfo,
                    l = e.x509.AlgorithmIdentifier;
                ct.asn1.cms.SignedData.superclass.constructor.call(this), this.dCMSVersion = new n({
                    int: 1
                }), this.dDigestAlgs = null, this.digestAlgNameList = [], this.dEncapContentInfo = new u, this.dCerts = null, this.certificateList = [], this.crlList = [], this.signerInfoList = [new c], this.addCertificatesByPEM = function(t) {
                    var e = Ft(t),
                        n = new r;
                    n.hTLV = e, this.certificateList.push(n)
                }, this.getEncodedHex = function() {
                    if ("string" == typeof this.hTLV) return this.hTLV;
                    if (null == this.dDigestAlgs) {
                        for (var t = [], e = 0; e < this.digestAlgNameList.length; e++) {
                            var r = this.digestAlgNameList[e],
                                n = new l({
                                    name: r
                                });
                            t.push(n)
                        }
                        this.dDigestAlgs = new i({
                            array: t
                        })
                    }
                    var o = [this.dCMSVersion, this.dDigestAlgs, this.dEncapContentInfo];
                    if (null == this.dCerts && this.certificateList.length > 0) {
                        var u = new i({
                            array: this.certificateList
                        });
                        this.dCerts = new a({
                            obj: u,
                            tag: "a0",
                            explicit: !1
                        })
                    }
                    null != this.dCerts && o.push(this.dCerts);
                    var c = new i({
                        array: this.signerInfoList
                    });
                    o.push(c);
                    var h = new s({
                        array: o
                    });
                    return this.hTLV = h.getEncodedHex(), this.hTLV
                }, this.getContentInfo = function() {
                    return this.getEncodedHex(), new h({
                        type: "signed-data",
                        obj: this
                    })
                }, this.getContentInfoEncodedHex = function() {
                    return this.getContentInfo().getEncodedHex()
                }, this.getPEM = function() {
                    return Bt(this.getContentInfoEncodedHex(), "CMS")
                }
            }, i.lang.extend(ct.asn1.cms.SignedData, ct.asn1.ASN1Object), ct.asn1.cms.CMSUtil = new function() {}, ct.asn1.cms.CMSUtil.newSignedData = function(t) {
                var e = ct.asn1,
                    r = e.cms,
                    n = r.SignerInfo,
                    i = r.SignedData,
                    s = r.SigningTime,
                    a = r.SigningCertificate,
                    o = r.SigningCertificateV2,
                    u = e.cades.SignaturePolicyIdentifier,
                    c = new i;
                if (c.dEncapContentInfo.setContentValue(t.content), "boolean" == typeof t.detached && (c.dEncapContentInfo.isDetached = t.detached), "object" == typeof t.certs)
                    for (var h = 0; h < t.certs.length; h++) c.addCertificatesByPEM(t.certs[h]);
                c.signerInfoList = [];
                for (h = 0; h < t.signerInfos.length; h++) {
                    var l = t.signerInfos[h],
                        f = new n;
                    for (attrName in f.setSignerIdentifier(l.signerCert), f.setForContentAndHash({
                            sdObj: c,
                            eciObj: c.dEncapContentInfo,
                            hashAlg: l.hashAlg
                        }), l.sAttr) {
                        var p = l.sAttr[attrName];
                        if ("SigningTime" == attrName) {
                            var d = new s(p);
                            f.dSignedAttrs.add(d)
                        }
                        if ("SigningCertificate" == attrName) {
                            d = new a(p);
                            f.dSignedAttrs.add(d)
                        }
                        if ("SigningCertificateV2" == attrName) {
                            d = new o(p);
                            f.dSignedAttrs.add(d)
                        }
                        if ("SignaturePolicyIdentifier" == attrName) {
                            d = new u(p);
                            f.dSignedAttrs.add(d)
                        }
                    }
                    f.sign(l.signerPrvKey, l.sigAlg), c.signerInfoList.push(f)
                }
                return c
            }, ct.asn1.cms.CMSUtil.verifySignedData = function(t) {
                var e = ct,
                    r = e.asn1,
                    n = r.cms,
                    i = (n.SignerInfo, n.SignedData, n.SigningTime, n.SigningCertificate, n.SigningCertificateV2, r.cades.SignaturePolicyIdentifier, e.lang.String.isHex),
                    s = ft,
                    a = s.getVbyList,
                    o = s.getTLVbyList,
                    u = s.getIdxbyList,
                    c = s.getChildIdx,
                    h = s.getTLV,
                    l = s.oidname,
                    f = e.crypto.Util.hashHex;
                void 0 === t.cms && i(t.cms);
                var p = t.cms,
                    d = function(t, e) {
                        var r = e.idx;
                        e.signerid_issuer1 = o(t, r, [1, 0], "30"), e.signerid_serial1 = a(t, r, [1, 1], "02"), e.hashalg = l(a(t, r, [2, 0], "06"));
                        var n = u(t, r, [3], "a0");
                        e.idxSignedAttrs = n, g(t, e, n);
                        var i = c(t, r).length;
                        if (i < 6) throw "malformed SignerInfo";
                        e.sigalg = l(a(t, r, [i - 2, 0], "06")), e.sigval = a(t, r, [i - 1], "04")
                    },
                    g = function(t, e, r) {
                        var n = c(t, r);
                        e.signedAttrIdxList = n;
                        for (var i = 0; i < n.length; i++) {
                            var s, o = n[i],
                                u = a(t, o, [0], "06");
                            "2a864886f70d010905" === u ? (s = Ct(a(t, o, [1, 0])), e.saSigningTime = s) : "2a864886f70d010904" === u && (s = a(t, o, [1, 0], "04"), e.saMessageDigest = s)
                        }
                    },
                    y = function(t, e, r, n) {
                        r.verifyDetail = {};
                        var i = r.verifyDetail,
                            s = e.parse.econtent,
                            a = r.hashalg,
                            o = r.saMessageDigest;
                        i.validMessageDigest = !1, f(s, a) === o && (i.validMessageDigest = !0),
                            function(t, e, r, n) {
                                var i, s = e.parse.certsIdx;
                                if (void 0 === e.certs) {
                                    i = [], e.certkeys = [];
                                    for (var a = c(t, s), o = 0; o < a.length; o++) {
                                        var u = h(t, a[o]),
                                            l = new zt;
                                        l.readCertHex(u), i[o] = l, e.certkeys[o] = l.getPublicKey()
                                    }
                                    e.certs = i
                                } else i = e.certs;
                                e.cccc = i.length, e.cccci = a.length;
                                for (o = 0; o < i.length; o++) {
                                    var f = l.getIssuerHex(),
                                        p = l.getSerialNumberHex();
                                    r.signerid_issuer1 === f && r.signerid_serial1 === p && (r.certkey_idx = o)
                                }
                            }(t, e, r), i.validSignatureValue = !1;
                        var u = r.sigalg,
                            l = "31" + h(t, r.idxSignedAttrs).substr(2);
                        r.signedattrshex = l;
                        var p = e.certs[r.certkey_idx].getPublicKey(),
                            d = new ct.crypto.Signature({
                                alg: u
                            });
                        d.init(p), d.updateHex(l);
                        var g = d.verify(r.sigval);
                        i.validSignatureValue_isValid = g, !0 === g && (i.validSignatureValue = !0), r.isValid = !1, i.validMessageDigest && i.validSignatureValue && (r.isValid = !0)
                    },
                    v = {
                        isValid: !1,
                        parse: {}
                    };
                return function(t, e) {
                        if ("2a864886f70d010702" !== a(t, 0, [0], "06")) return e;
                        e.cmsType = "signedData", e.econtent = a(t, 0, [1, 0, 2, 1, 0]),
                            function(t, e) {
                                for (var r, n = 3; n < 6; n++)
                                    if (void 0 !== (r = u(t, 0, [1, 0, n]))) {
                                        var i = t.substr(r, 2);
                                        "a0" === i && (e.certsIdx = r), "a1" === i && (e.revinfosIdx = r), "31" === i && (e.signerinfosIdx = r)
                                    }
                            }(t, e), e.signerInfos = [],
                            function(t, e) {
                                var r = e.signerinfosIdx;
                                if (void 0 !== r) {
                                    var n = c(t, r);
                                    e.signerInfoIdxList = n;
                                    for (var i = 0; i < n.length; i++) {
                                        var s = {
                                            idx: n[i]
                                        };
                                        d(t, s), e.signerInfos.push(s)
                                    }
                                }
                            }(t, e)
                    }(p, v.parse),
                    function(t, e) {
                        for (var r = e.parse.signerInfos, n = r.length, i = !0, s = 0; s < n; s++) {
                            var a = r[s];
                            y(t, e, a, s), a.isValid || (i = !1)
                        }
                        e.isValid = i
                    }(p, v), v
            }, void 0 !== ct && ct || (ct = {}), void 0 !== ct.asn1 && ct.asn1 || (ct.asn1 = {}), void 0 !== ct.asn1.tsp && ct.asn1.tsp || (ct.asn1.tsp = {}), ct.asn1.tsp.Accuracy = function(t) {
                var e = ct.asn1,
                    r = e.DERInteger,
                    n = e.DERSequence,
                    i = e.DERTaggedObject;
                e.tsp.Accuracy.superclass.constructor.call(this), this.seconds = null, this.millis = null, this.micros = null, this.getEncodedHex = function() {
                    var t = null,
                        e = null,
                        s = null,
                        a = [];
                    if (null != this.seconds && (t = new r({
                            int: this.seconds
                        }), a.push(t)), null != this.millis) {
                        var o = new r({
                            int: this.millis
                        });
                        e = new i({
                            obj: o,
                            tag: "80",
                            explicit: !1
                        }), a.push(e)
                    }
                    if (null != this.micros) {
                        var u = new r({
                            int: this.micros
                        });
                        s = new i({
                            obj: u,
                            tag: "81",
                            explicit: !1
                        }), a.push(s)
                    }
                    var c = new n({
                        array: a
                    });
                    return this.hTLV = c.getEncodedHex(), this.hTLV
                }, void 0 !== t && ("number" == typeof t.seconds && (this.seconds = t.seconds), "number" == typeof t.millis && (this.millis = t.millis), "number" == typeof t.micros && (this.micros = t.micros))
            }, i.lang.extend(ct.asn1.tsp.Accuracy, ct.asn1.ASN1Object), ct.asn1.tsp.MessageImprint = function(t) {
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.DEROctetString,
                    i = e.x509.AlgorithmIdentifier;
                e.tsp.MessageImprint.superclass.constructor.call(this), this.dHashAlg = null, this.dHashValue = null, this.getEncodedHex = function() {
                    return "string" == typeof this.hTLV ? this.hTLV : new r({
                        array: [this.dHashAlg, this.dHashValue]
                    }).getEncodedHex()
                }, void 0 !== t && ("string" == typeof t.hashAlg && (this.dHashAlg = new i({
                    name: t.hashAlg
                })), "string" == typeof t.hashValue && (this.dHashValue = new n({
                    hex: t.hashValue
                })))
            }, i.lang.extend(ct.asn1.tsp.MessageImprint, ct.asn1.ASN1Object), ct.asn1.tsp.TimeStampReq = function(t) {
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.DERInteger,
                    i = e.DERBoolean,
                    s = e.DERObjectIdentifier,
                    a = e.tsp,
                    o = a.MessageImprint;
                a.TimeStampReq.superclass.constructor.call(this), this.dVersion = new n({
                    int: 1
                }), this.dMessageImprint = null, this.dPolicy = null, this.dNonce = null, this.certReq = !0, this.setMessageImprint = function(t) {
                    t instanceof o ? this.dMessageImprint = t : "object" == typeof t && (this.dMessageImprint = new o(t))
                }, this.getEncodedHex = function() {
                    if (null == this.dMessageImprint) throw "messageImprint shall be specified";
                    var t = [this.dVersion, this.dMessageImprint];
                    null != this.dPolicy && t.push(this.dPolicy), null != this.dNonce && t.push(this.dNonce), this.certReq && t.push(new i);
                    var e = new r({
                        array: t
                    });
                    return this.hTLV = e.getEncodedHex(), this.hTLV
                }, void 0 !== t && ("object" == typeof t.mi && this.setMessageImprint(t.mi), "object" == typeof t.policy && (this.dPolicy = new s(t.policy)), "object" == typeof t.nonce && (this.dNonce = new n(t.nonce)), "boolean" == typeof t.certreq && (this.certReq = t.certreq))
            }, i.lang.extend(ct.asn1.tsp.TimeStampReq, ct.asn1.ASN1Object), ct.asn1.tsp.TSTInfo = function(t) {
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.DERInteger,
                    i = e.DERBoolean,
                    s = e.DERGeneralizedTime,
                    a = e.DERObjectIdentifier,
                    o = e.DERTaggedObject,
                    u = e.tsp,
                    c = u.MessageImprint,
                    h = u.Accuracy,
                    l = (e.x509.X500Name, e.x509.GeneralName);
                if (u.TSTInfo.superclass.constructor.call(this), this.dVersion = new n({
                        int: 1
                    }), this.dPolicy = null, this.dMessageImprint = null, this.dSerialNumber = null, this.dGenTime = null, this.dAccuracy = null, this.dOrdering = null, this.dNonce = null, this.dTsa = null, this.getEncodedHex = function() {
                        var t = [this.dVersion];
                        if (null == this.dPolicy) throw "policy shall be specified.";
                        if (t.push(this.dPolicy), null == this.dMessageImprint) throw "messageImprint shall be specified.";
                        if (t.push(this.dMessageImprint), null == this.dSerialNumber) throw "serialNumber shall be specified.";
                        if (t.push(this.dSerialNumber), null == this.dGenTime) throw "genTime shall be specified.";
                        t.push(this.dGenTime), null != this.dAccuracy && t.push(this.dAccuracy), null != this.dOrdering && t.push(this.dOrdering), null != this.dNonce && t.push(this.dNonce), null != this.dTsa && t.push(this.dTsa);
                        var e = new r({
                            array: t
                        });
                        return this.hTLV = e.getEncodedHex(), this.hTLV
                    }, void 0 !== t) {
                    if ("string" == typeof t.policy) {
                        if (!t.policy.match(/^[0-9.]+$/)) throw "policy shall be oid like 0.1.4.134";
                        this.dPolicy = new a({
                            oid: t.policy
                        })
                    }
                    void 0 !== t.messageImprint && (this.dMessageImprint = new c(t.messageImprint)), void 0 !== t.serialNumber && (this.dSerialNumber = new n(t.serialNumber)), void 0 !== t.genTime && (this.dGenTime = new s(t.genTime)), void 0 !== t.accuracy && (this.dAccuracy = new h(t.accuracy)), void 0 !== t.ordering && 1 == t.ordering && (this.dOrdering = new i), void 0 !== t.nonce && (this.dNonce = new n(t.nonce)), void 0 !== t.tsa && (this.dTsa = new o({
                        tag: "a0",
                        explicit: !0,
                        obj: new l({
                            dn: t.tsa
                        })
                    }))
                }
            }, i.lang.extend(ct.asn1.tsp.TSTInfo, ct.asn1.ASN1Object), ct.asn1.tsp.TimeStampResp = function(t) {
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.ASN1Object,
                    i = e.tsp,
                    s = i.PKIStatusInfo;
                i.TimeStampResp.superclass.constructor.call(this), this.dStatus = null, this.dTST = null, this.getEncodedHex = function() {
                    if (null == this.dStatus) throw "status shall be specified";
                    var t = [this.dStatus];
                    null != this.dTST && t.push(this.dTST);
                    var e = new r({
                        array: t
                    });
                    return this.hTLV = e.getEncodedHex(), this.hTLV
                }, void 0 !== t && ("object" == typeof t.status && (this.dStatus = new s(t.status)), void 0 !== t.tst && t.tst instanceof n && (this.dTST = t.tst.getContentInfo()))
            }, i.lang.extend(ct.asn1.tsp.TimeStampResp, ct.asn1.ASN1Object), ct.asn1.tsp.PKIStatusInfo = function(t) {
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.tsp,
                    i = n.PKIStatus,
                    s = n.PKIFreeText,
                    a = n.PKIFailureInfo;
                n.PKIStatusInfo.superclass.constructor.call(this), this.dStatus = null, this.dStatusString = null, this.dFailureInfo = null, this.getEncodedHex = function() {
                    if (null == this.dStatus) throw "status shall be specified";
                    var t = [this.dStatus];
                    null != this.dStatusString && t.push(this.dStatusString), null != this.dFailureInfo && t.push(this.dFailureInfo);
                    var e = new r({
                        array: t
                    });
                    return this.hTLV = e.getEncodedHex(), this.hTLV
                }, void 0 !== t && ("object" == typeof t.status && (this.dStatus = new i(t.status)), "object" == typeof t.statstr && (this.dStatusString = new s({
                    array: t.statstr
                })), "object" == typeof t.failinfo && (this.dFailureInfo = new a(t.failinfo)))
            }, i.lang.extend(ct.asn1.tsp.PKIStatusInfo, ct.asn1.ASN1Object), ct.asn1.tsp.PKIStatus = function(t) {
                var e = ct.asn1,
                    r = e.DERInteger,
                    n = e.tsp,
                    i = n.PKIStatus;
                n.PKIStatus.superclass.constructor.call(this);
                if (this.getEncodedHex = function() {
                        return this.hTLV = this.dStatus.getEncodedHex(), this.hTLV
                    }, void 0 !== t)
                    if (void 0 !== t.name) {
                        var s = i.valueList;
                        if (void 0 === s[t.name]) throw "name undefined: " + t.name;
                        this.dStatus = new r({
                            int: s[t.name]
                        })
                    } else this.dStatus = new r(t)
            }, i.lang.extend(ct.asn1.tsp.PKIStatus, ct.asn1.ASN1Object), ct.asn1.tsp.PKIStatus.valueList = {
                granted: 0,
                grantedWithMods: 1,
                rejection: 2,
                waiting: 3,
                revocationWarning: 4,
                revocationNotification: 5
            }, ct.asn1.tsp.PKIFreeText = function(t) {
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.DERUTF8String;
                e.tsp.PKIFreeText.superclass.constructor.call(this), this.textList = [], this.getEncodedHex = function() {
                    for (var t = [], e = 0; e < this.textList.length; e++) t.push(new n({
                        str: this.textList[e]
                    }));
                    var i = new r({
                        array: t
                    });
                    return this.hTLV = i.getEncodedHex(), this.hTLV
                }, void 0 !== t && "object" == typeof t.array && (this.textList = t.array)
            }, i.lang.extend(ct.asn1.tsp.PKIFreeText, ct.asn1.ASN1Object), ct.asn1.tsp.PKIFailureInfo = function(t) {
                var e = ct.asn1,
                    r = e.DERBitString,
                    n = e.tsp.PKIFailureInfo;
                if (n.superclass.constructor.call(this), this.value = null, this.getEncodedHex = function() {
                        if (null == this.value) throw "value shall be specified";
                        var t = new Number(this.value).toString(2),
                            e = new r;
                        return e.setByBinaryString(t), this.hTLV = e.getEncodedHex(), this.hTLV
                    }, void 0 !== t)
                    if ("string" == typeof t.name) {
                        var i = n.valueList;
                        if (void 0 === i[t.name]) throw "name undefined: " + t.name;
                        this.value = i[t.name]
                    } else "number" == typeof t.int && (this.value = t.int)
            }, i.lang.extend(ct.asn1.tsp.PKIFailureInfo, ct.asn1.ASN1Object), ct.asn1.tsp.PKIFailureInfo.valueList = {
                badAlg: 0,
                badRequest: 2,
                badDataFormat: 5,
                timeNotAvailable: 14,
                unacceptedPolicy: 15,
                unacceptedExtension: 16,
                addInfoNotAvailable: 17,
                systemFailure: 25
            }, ct.asn1.tsp.AbstractTSAAdapter = function(t) {
                this.getTSTHex = function(t, e) {
                    throw "not implemented yet"
                }
            }, ct.asn1.tsp.SimpleTSAAdapter = function(t) {
                var e = ct,
                    r = e.asn1.tsp,
                    n = e.crypto.Util.hashHex;
                r.SimpleTSAAdapter.superclass.constructor.call(this), this.params = null, this.serial = 0, this.getTSTHex = function(t, e) {
                    var i = n(t, e);
                    this.params.tstInfo.messageImprint = {
                        hashAlg: e,
                        hashValue: i
                    }, this.params.tstInfo.serialNumber = {
                        int: this.serial++
                    };
                    var s = Math.floor(1e9 * Math.random());
                    return this.params.tstInfo.nonce = {
                        int: s
                    }, r.TSPUtil.newTimeStampToken(this.params).getContentInfoEncodedHex()
                }, void 0 !== t && (this.params = t)
            }, i.lang.extend(ct.asn1.tsp.SimpleTSAAdapter, ct.asn1.tsp.AbstractTSAAdapter), ct.asn1.tsp.FixedTSAAdapter = function(t) {
                var e = ct,
                    r = e.asn1.tsp,
                    n = e.crypto.Util.hashHex;
                r.FixedTSAAdapter.superclass.constructor.call(this), this.params = null, this.getTSTHex = function(t, e) {
                    var i = n(t, e);
                    return this.params.tstInfo.messageImprint = {
                        hashAlg: e,
                        hashValue: i
                    }, r.TSPUtil.newTimeStampToken(this.params).getContentInfoEncodedHex()
                }, void 0 !== t && (this.params = t)
            }, i.lang.extend(ct.asn1.tsp.FixedTSAAdapter, ct.asn1.tsp.AbstractTSAAdapter), ct.asn1.tsp.TSPUtil = new function() {}, ct.asn1.tsp.TSPUtil.newTimeStampToken = function(t) {
                var e = ct,
                    r = e.asn1,
                    n = e.asn1.DERInteger,
                    i = r.cms,
                    s = (r.tsp, r.tsp.TSTInfo),
                    a = new i.SignedData,
                    o = new s(t.tstInfo).getEncodedHex();
                if (a.dCMSVersion = new n({
                        int: 3
                    }), a.dEncapContentInfo.setContentValue({
                        hex: o
                    }), a.dEncapContentInfo.setContentType("tstinfo"), "object" == typeof t.certs)
                    for (var u = 0; u < t.certs.length; u++) a.addCertificatesByPEM(t.certs[u]);
                var c = a.signerInfoList[0];
                c.setSignerIdentifier(t.signerCert), c.setForContentAndHash({
                    sdObj: a,
                    eciObj: a.dEncapContentInfo,
                    contentType: "tstinfo",
                    hashAlg: t.hashAlg
                });
                var h = new i.SigningCertificate({
                    array: [t.signerCert]
                });
                return c.dSignedAttrs.add(h), c.sign(t.signerPrvKey, t.sigAlg), a
            }, ct.asn1.tsp.TSPUtil.parseTimeStampReq = function(t) {
                var e = ft,
                    r = e.getChildIdx,
                    n = e.getV,
                    i = e.getTLV,
                    s = {
                        certreq: !1
                    },
                    a = r(t, 0);
                if (a.length < 2) throw "TimeStampReq must have at least 2 items";
                var o = i(t, a[1]);
                s.mi = ct.asn1.tsp.TSPUtil.parseMessageImprint(o);
                for (var u = 2; u < a.length; u++) {
                    var c = a[u],
                        h = t.substr(c, 2);
                    if ("06" == h) {
                        var l = n(t, c);
                        s.policy = e.hextooidstr(l)
                    }
                    "02" == h && (s.nonce = n(t, c)), "01" == h && (s.certreq = !0)
                }
                return s
            }, ct.asn1.tsp.TSPUtil.parseMessageImprint = function(t) {
                var e = ft,
                    r = e.getChildIdx,
                    n = e.getV,
                    i = e.getIdxbyList,
                    s = {};
                if ("30" != t.substr(0, 2)) throw "head of messageImprint hex shall be '30'";
                r(t, 0);
                var a = n(t, i(t, 0, [0, 0])),
                    o = e.hextooidstr(a),
                    u = ct.asn1.x509.OID.oid2name(o);
                if ("" == u) throw "hashAlg name undefined: " + o;
                var c = u,
                    h = i(t, 0, [1]);
                return s.hashAlg = c, s.hashValue = n(t, h), s
            }, void 0 !== ct && ct || (ct = {}), void 0 !== ct.asn1 && ct.asn1 || (ct.asn1 = {}), void 0 !== ct.asn1.cades && ct.asn1.cades || (ct.asn1.cades = {}), ct.asn1.cades.SignaturePolicyIdentifier = function(t) {
                var e = ct.asn1,
                    r = e.DERObjectIdentifier,
                    n = e.DERSequence,
                    i = e.cades,
                    s = i.OtherHashAlgAndValue;
                if (i.SignaturePolicyIdentifier.superclass.constructor.call(this), this.attrTypeOid = "1.2.840.113549.1.9.16.2.15", void 0 !== t && "string" == typeof t.oid && "object" == typeof t.hash) {
                    var a = new n({
                        array: [new r({
                            oid: t.oid
                        }), new s(t.hash)]
                    });
                    this.valueList = [a]
                }
            }, i.lang.extend(ct.asn1.cades.SignaturePolicyIdentifier, ct.asn1.cms.Attribute), ct.asn1.cades.OtherHashAlgAndValue = function(t) {
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.DEROctetString,
                    i = e.x509.AlgorithmIdentifier;
                e.cades.OtherHashAlgAndValue.superclass.constructor.call(this), this.dAlg = null, this.dHash = null, this.getEncodedHex = function() {
                    var t = new r({
                        array: [this.dAlg, this.dHash]
                    });
                    return this.hTLV = t.getEncodedHex(), this.hTLV
                }, void 0 !== t && "string" == typeof t.alg && "string" == typeof t.hash && (this.dAlg = new i({
                    name: t.alg
                }), this.dHash = new n({
                    hex: t.hash
                }))
            }, i.lang.extend(ct.asn1.cades.OtherHashAlgAndValue, ct.asn1.ASN1Object), ct.asn1.cades.SignatureTimeStamp = function(t) {
                var e = ct.asn1,
                    r = e.ASN1Object;
                e.x509;
                if (e.cades.SignatureTimeStamp.superclass.constructor.call(this), this.attrTypeOid = "1.2.840.113549.1.9.16.2.14", this.tstHex = null, void 0 !== t) {
                    if (void 0 !== t.res)
                        if ("string" == typeof t.res && t.res.match(/^[0-9A-Fa-f]+$/));
                        else if (!(t.res instanceof r)) throw "res param shall be ASN1Object or hex string";
                    if (void 0 !== t.tst)
                        if ("string" == typeof t.tst && t.tst.match(/^[0-9A-Fa-f]+$/)) {
                            var n = new r;
                            this.tstHex = t.tst, n.hTLV = this.tstHex, n.getEncodedHex(), this.valueList = [n]
                        } else if (!(t.tst instanceof r)) throw "tst param shall be ASN1Object or hex string"
                }
            }, i.lang.extend(ct.asn1.cades.SignatureTimeStamp, ct.asn1.cms.Attribute), ct.asn1.cades.CompleteCertificateRefs = function(t) {
                var e = ct.asn1.cades;
                e.CompleteCertificateRefs.superclass.constructor.call(this), this.attrTypeOid = "1.2.840.113549.1.9.16.2.21", this.setByArray = function(t) {
                    this.valueList = [];
                    for (var r = 0; r < t.length; r++) {
                        var n = new e.OtherCertID(t[r]);
                        this.valueList.push(n)
                    }
                }, void 0 !== t && "object" == typeof t && "number" == typeof t.length && this.setByArray(t)
            }, i.lang.extend(ct.asn1.cades.CompleteCertificateRefs, ct.asn1.cms.Attribute), ct.asn1.cades.OtherCertID = function(t) {
                var e = ct.asn1,
                    r = e.cms,
                    n = e.cades;
                n.OtherCertID.superclass.constructor.call(this), this.hasIssuerSerial = !0, this.dOtherCertHash = null, this.dIssuerSerial = null, this.setByCertPEM = function(t) {
                    this.dOtherCertHash = new n.OtherHash(t), this.hasIssuerSerial && (this.dIssuerSerial = new r.IssuerAndSerialNumber(t))
                }, this.getEncodedHex = function() {
                    if (null != this.hTLV) return this.hTLV;
                    if (null == this.dOtherCertHash) throw "otherCertHash not set";
                    var t = [this.dOtherCertHash];
                    null != this.dIssuerSerial && t.push(this.dIssuerSerial);
                    var r = new e.DERSequence({
                        array: t
                    });
                    return this.hTLV = r.getEncodedHex(), this.hTLV
                }, void 0 !== t && ("string" == typeof t && -1 != t.indexOf("-----BEGIN ") && this.setByCertPEM(t), "object" == typeof t && (!1 === t.hasis && (this.hasIssuerSerial = !1), "string" == typeof t.cert && this.setByCertPEM(t.cert)))
            }, i.lang.extend(ct.asn1.cades.OtherCertID, ct.asn1.ASN1Object), ct.asn1.cades.OtherHash = function(t) {
                var e = ct,
                    r = e.asn1,
                    n = (r.cms, r.cades),
                    i = n.OtherHashAlgAndValue,
                    s = e.crypto.Util.hashHex;
                if (n.OtherHash.superclass.constructor.call(this), this.alg = "sha256", this.dOtherHash = null, this.setByCertPEM = function(t) {
                        if (-1 == t.indexOf("-----BEGIN ")) throw "certPEM not to seem PEM format";
                        var e = Ft(t),
                            r = s(e, this.alg);
                        this.dOtherHash = new i({
                            alg: this.alg,
                            hash: r
                        })
                    }, this.getEncodedHex = function() {
                        if (null == this.dOtherHash) throw "OtherHash not set";
                        return this.dOtherHash.getEncodedHex()
                    }, void 0 !== t)
                    if ("string" == typeof t)
                        if (-1 != t.indexOf("-----BEGIN ")) this.setByCertPEM(t);
                        else {
                            if (!t.match(/^[0-9A-Fa-f]+$/)) throw "unsupported string value for params";
                            this.dOtherHash = new r.DEROctetString({
                                hex: t
                            })
                        }
                else "object" == typeof t && ("string" == typeof t.cert ? ("string" == typeof t.alg && (this.alg = t.alg), this.setByCertPEM(t.cert)) : this.dOtherHash = new i(t))
            }, i.lang.extend(ct.asn1.cades.OtherHash, ct.asn1.ASN1Object), ct.asn1.cades.CAdESUtil = new function() {}, ct.asn1.cades.CAdESUtil.addSigTS = function(t, e, r) {}, ct.asn1.cades.CAdESUtil.parseSignedDataForAddingUnsigned = function(t) {
                var e = ft,
                    r = e.getChildIdx,
                    n = e.getTLV,
                    i = e.getTLVbyList,
                    s = (e.getTLVbyListEx, e.getIdxbyList),
                    a = (e.getIdxbyListEx, ct.asn1),
                    o = a.ASN1Object,
                    u = a.cms.SignedData,
                    c = a.cades.CAdESUtil,
                    h = {};
                if ("06092a864886f70d010702" != i(t, 0, [0])) throw "hex is not CMS SignedData";
                var l = r(t, s(t, 0, [1, 0]));
                if (l.length < 4) throw "num of SignedData elem shall be 4 at least";
                var f = l.shift();
                h.version = n(t, f);
                var p = l.shift();
                h.algs = n(t, p);
                var d = l.shift();
                h.encapcontent = n(t, d), h.certs = null, h.revs = null, h.si = [];
                var g = l.shift();
                "a0" == t.substr(g, 2) && (h.certs = n(t, g), g = l.shift()), "a1" == t.substr(g, 2) && (h.revs = n(t, g), g = l.shift());
                var y = g;
                if ("31" != t.substr(y, 2)) throw "Can't find signerInfos";
                for (var v = r(t, y), m = 0; m < v.length; m++) {
                    var E = v[m],
                        S = c.parseSignerInfoForAddingUnsigned(t, E, m);
                    h.si[m] = S
                }
                var b = null;
                h.obj = new u, (b = new o).hTLV = h.version, h.obj.dCMSVersion = b, (b = new o).hTLV = h.algs, h.obj.dDigestAlgs = b, (b = new o).hTLV = h.encapcontent, h.obj.dEncapContentInfo = b, (b = new o).hTLV = h.certs, h.obj.dCerts = b, h.obj.signerInfoList = [];
                for (m = 0; m < h.si.length; m++) h.obj.signerInfoList.push(h.si[m].obj);
                return h
            }, ct.asn1.cades.CAdESUtil.parseSignerInfoForAddingUnsigned = function(t, e, r) {
                var n = ft,
                    i = n.getChildIdx,
                    s = n.getTLV,
                    a = n.getV,
                    o = ct.asn1,
                    u = o.ASN1Object,
                    c = o.cms,
                    h = c.AttributeList,
                    l = c.SignerInfo,
                    f = {},
                    p = i(t, e);
                if (6 != p.length) throw "not supported items for SignerInfo (!=6)";
                var d = p.shift();
                f.version = s(t, d);
                var g = p.shift();
                f.si = s(t, g);
                var y = p.shift();
                f.digalg = s(t, y);
                var v = p.shift();
                f.sattrs = s(t, v);
                var m = p.shift();
                f.sigalg = s(t, m);
                var E = p.shift();
                f.sig = s(t, E), f.sigval = a(t, E);
                var S = null;
                return f.obj = new l, (S = new u).hTLV = f.version, f.obj.dCMSVersion = S, (S = new u).hTLV = f.si, f.obj.dSignerIdentifier = S, (S = new u).hTLV = f.digalg, f.obj.dDigestAlgorithm = S, (S = new u).hTLV = f.sattrs, f.obj.dSignedAttrs = S, (S = new u).hTLV = f.sigalg, f.obj.dSigAlg = S, (S = new u).hTLV = f.sig, f.obj.dSig = S, f.obj.dUnsignedAttrs = new h, f
            }, void 0 !== ct.asn1.csr && ct.asn1.csr || (ct.asn1.csr = {}), ct.asn1.csr.CertificationRequest = function(t) {
                var e = ct.asn1,
                    r = e.DERBitString,
                    n = e.DERSequence,
                    i = e.csr,
                    s = (e.x509, i.CertificationRequestInfo);
                i.CertificationRequest.superclass.constructor.call(this), this.setByParam = function(t) {
                    this.params = t
                }, this.sign = function() {
                    var t = new s(this.params).getEncodedHex(),
                        e = new ct.crypto.Signature({
                            alg: this.params.sigalg
                        });
                    e.init(this.params.sbjprvkey), e.updateHex(t);
                    var r = e.sign();
                    this.params.sighex = r
                }, this.getPEM = function() {
                    return Bt(this.getEncodedHex(), "CERTIFICATE REQUEST")
                }, this.getEncodedHex = function() {
                    var t = this.params,
                        e = new ct.asn1.csr.CertificationRequestInfo(this.params),
                        i = new ct.asn1.x509.AlgorithmIdentifier({
                            name: t.sigalg
                        });
                    if (null == t.sighex && null != t.sbjprvkey && this.sign(), null == t.sighex) throw new Error("sighex or sbjprvkey parameter not defined");
                    var s = new r({
                        hex: "00" + t.sighex
                    });
                    return new n({
                        array: [e, i, s]
                    }).getEncodedHex()
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.csr.CertificationRequest, ct.asn1.ASN1Object), ct.asn1.csr.CertificationRequestInfo = function(t) {
                var e = ct.asn1,
                    r = (e.DERBitString, e.DERSequence),
                    n = e.DERInteger,
                    i = e.DERUTF8String,
                    s = e.DERTaggedObject,
                    a = e.ASN1Util.newObject,
                    o = e.csr,
                    u = e.x509,
                    c = u.X500Name,
                    h = u.Extensions,
                    l = u.SubjectPublicKeyInfo;
                o.CertificationRequestInfo.superclass.constructor.call(this), this.params = null, this.setByParam = function(t) {
                    null != t && (this.params = t)
                }, this.getEncodedHex = function() {
                    var t = this.params,
                        e = [];
                    if (e.push(new n({
                            int: 0
                        })), e.push(new c(t.subject)), e.push(new l(Ht.getKey(t.sbjpubkey))), null != t.extreq) {
                        var o = new h(t.extreq),
                            u = a({
                                tag: {
                                    tag: "a0",
                                    explict: !0,
                                    obj: {
                                        seq: [{
                                            oid: "1.2.840.113549.1.9.14"
                                        }, {
                                            set: [o]
                                        }]
                                    }
                                }
                            });
                        e.push(u)
                    } else e.push(new s({
                        tag: "a0",
                        explicit: !1,
                        obj: new i({
                            str: ""
                        })
                    }));
                    return new r({
                        array: e
                    }).getEncodedHex()
                }, null != t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.csr.CertificationRequestInfo, ct.asn1.ASN1Object), ct.asn1.csr.CSRUtil = new function() {}, ct.asn1.csr.CSRUtil.newCSRPEM = function(t) {
                return new ct.asn1.csr.CertificationRequest(t).getPEM()
            }, ct.asn1.csr.CSRUtil.getParam = function(t) {
                var e = ft,
                    r = e.getV;
                _getIdxbyList = e.getIdxbyList, _getTLVbyList = e.getTLVbyList, _getTLVbyListEx = e.getTLVbyListEx, _getVbyListEx = e.getVbyListEx;
                var n = {};
                if (-1 == t.indexOf("-----BEGIN CERTIFICATE REQUEST")) throw new Error("argument is not PEM file");
                var i = Ft(t, "CERTIFICATE REQUEST");
                try {
                    var s = _getTLVbyListEx(i, 0, [0, 1]),
                        a = new zt;
                    n.subject = {}, n.subject.array = a.getX500Name(s), n.subject.str = zt.hex2dn(s)
                } catch (t) {}
                var o = _getTLVbyListEx(i, 0, [0, 2]),
                    u = Ht.getKey(o, null, "pkcs8pub");
                n.sbjpubkey = Ht.getPEM(u, "PKCS8PUB");
                var c, h, l = (c = i, h = _getIdxbyList(c, 0, [0, 3, 0, 0], "06"), "2a864886f70d01090e" != r(c, h) ? null : _getTLVbyList(c, 0, [0, 3, 0, 1, 0], "30"));
                a = new zt;
                null != l && (n.extreq = a.getExtParamArray(l));
                try {
                    var f = _getTLVbyListEx(i, 0, [1], "30");
                    a = new zt;
                    n.sigalg = a.getAlgorithmIdentifierName(f)
                } catch (t) {}
                try {
                    var p = _getVbyListEx(i, 0, [2]);
                    n.sighex = p
                } catch (t) {}
                return n
            }, void 0 !== ct && ct || (ct = {}), void 0 !== ct.asn1 && ct.asn1 || (ct.asn1 = {}), void 0 !== ct.asn1.ocsp && ct.asn1.ocsp || (ct.asn1.ocsp = {}), ct.asn1.ocsp.DEFAULT_HASH = "sha1", ct.asn1.ocsp.OCSPResponse = function(t) {
                ct.asn1.ocsp.OCSPResponse.superclass.constructor.call(this);
                ct.asn1.DEREnumerated;
                var e = ct.asn1.ASN1Util.newObject,
                    r = ct.asn1.ocsp.ResponseBytes,
                    n = ["successful", "malformedRequest", "internalError", "tryLater", "_not_used_", "sigRequired", "unauthorized"];
                this.params = null, this._getStatusCode = function() {
                    var t = this.params.resstatus;
                    return "number" == typeof t ? t : "string" != typeof t ? -1 : n.indexOf(t)
                }, this.setByParam = function(t) {
                    this.params = t
                }, this.getEncodedHex = function() {
                    var t = this.params,
                        n = this._getStatusCode();
                    if (-1 == n) throw new Error("responseStatus not supported: " + t.resstatus);
                    if (0 != n) return e({
                        seq: [{
                            enum: {
                                int: n
                            }
                        }]
                    }).getEncodedHex();
                    var i = new r(t);
                    return e({
                        seq: [{
                            enum: {
                                int: 0
                            }
                        }, {
                            tag: {
                                tag: "a0",
                                explicit: !0,
                                obj: i
                            }
                        }]
                    }).getEncodedHex()
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.ocsp.OCSPResponse, ct.asn1.ASN1Object), ct.asn1.ocsp.ResponseBytes = function(t) {
                ct.asn1.ocsp.ResponseBytes.superclass.constructor.call(this);
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.DERObjectIdentifier,
                    i = e.DEROctetString,
                    s = e.ocsp.BasicOCSPResponse;
                this.params = null, this.setByParam = function(t) {
                    this.params = t
                }, this.getEncodedHex = function() {
                    var t = this.params;
                    if ("ocspBasic" != t.restype) throw new Error("not supported responseType: " + t.restype);
                    var e = new s(t),
                        a = [];
                    return a.push(new n({
                        name: "ocspBasic"
                    })), a.push(new i({
                        hex: e.getEncodedHex()
                    })), new r({
                        array: a
                    }).getEncodedHex()
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.ocsp.ResponseBytes, ct.asn1.ASN1Object), ct.asn1.ocsp.BasicOCSPResponse = function(t) {
                ct.asn1.ocsp.BasicOCSPResponse.superclass.constructor.call(this);
                var e = Error,
                    r = ct.asn1,
                    n = r.ASN1Object,
                    i = r.DERSequence,
                    s = (r.DERGeneralizedTime, r.DERTaggedObject),
                    a = r.DERBitString,
                    o = (r.x509.Extensions, r.x509.AlgorithmIdentifier),
                    u = r.ocsp;
                u.ResponderID;
                _SingleResponseList = u.SingleResponseList, _ResponseData = u.ResponseData, this.params = null, this.setByParam = function(t) {
                    this.params = t
                }, this.sign = function() {
                    var t = this.params,
                        e = t.tbsresp.getEncodedHex(),
                        r = new ct.crypto.Signature({
                            alg: t.sigalg
                        });
                    r.init(t.reskey), r.updateHex(e), t.sighex = r.sign()
                }, this.getEncodedHex = function() {
                    var t = this.params;
                    null == t.tbsresp && (t.tbsresp = new _ResponseData(t)), null == t.sighex && null != t.reskey && this.sign();
                    var r = [];
                    if (r.push(t.tbsresp), r.push(new o({
                            name: t.sigalg
                        })), r.push(new a({
                            hex: "00" + t.sighex
                        })), null != t.certs && null != t.certs.length) {
                        for (var u = [], c = 0; c < t.certs.length; c++) {
                            var h = t.certs[c],
                                l = null;
                            if (ft.isASN1HEX(h)) l = h;
                            else {
                                if (!h.match(/-----BEGIN/)) throw new e("certs[" + c + "] not hex or PEM");
                                l = Ft(h)
                            }
                            u.push(new n({
                                tlv: l
                            }))
                        }
                        var f = new i({
                            array: u
                        });
                        r.push(new s({
                            tag: "a0",
                            explicit: !0,
                            obj: f
                        }))
                    }
                    return new i({
                        array: r
                    }).getEncodedHex()
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.ocsp.BasicOCSPResponse, ct.asn1.ASN1Object), ct.asn1.ocsp.ResponseData = function(t) {
                ct.asn1.ocsp.ResponseData.superclass.constructor.call(this);
                var e = Error,
                    r = ct.asn1,
                    n = r.DERSequence,
                    i = r.DERGeneralizedTime,
                    s = r.DERTaggedObject,
                    a = r.x509.Extensions,
                    o = r.ocsp,
                    u = o.ResponderID;
                _SingleResponseList = o.SingleResponseList, this.params = null, this.getEncodedHex = function() {
                    var t = this.params;
                    null != t.respid && new e("respid not specified"), null != t.prodat && new e("prodat not specified"), null != t.array && new e("array not specified");
                    var r = [];
                    if (r.push(new u(t.respid)), r.push(new i(t.prodat)), r.push(new _SingleResponseList(t.array)), null != t.ext) {
                        var o = new a(t.ext);
                        r.push(new s({
                            tag: "a1",
                            explicit: !0,
                            obj: o
                        }))
                    }
                    return new n({
                        array: r
                    }).getEncodedHex()
                }, this.setByParam = function(t) {
                    this.params = t
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.ocsp.ResponseData, ct.asn1.ASN1Object), ct.asn1.ocsp.ResponderID = function(t) {
                ct.asn1.ocsp.ResponderID.superclass.constructor.call(this);
                var e = ct.asn1,
                    r = e.ASN1Util.newObject,
                    n = e.x509.X500Name;
                this.params = null, this.getEncodedHex = function() {
                    var t = this.params;
                    if (null != t.key) return r({
                        tag: {
                            tag: "a2",
                            explicit: !0,
                            obj: {
                                octstr: {
                                    hex: t.key
                                }
                            }
                        }
                    }).getEncodedHex();
                    if (null != t.name) return r({
                        tag: {
                            tag: "a1",
                            explicit: !0,
                            obj: new n(t.name)
                        }
                    }).getEncodedHex();
                    throw new Error("key or name not specified")
                }, this.setByParam = function(t) {
                    this.params = t
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.ocsp.ResponderID, ct.asn1.ASN1Object), ct.asn1.ocsp.SingleResponseList = function(t) {
                ct.asn1.ocsp.SingleResponseList.superclass.constructor.call(this);
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.ocsp.SingleResponse;
                this.params = null, this.getEncodedHex = function() {
                    var t = this.params;
                    if ("object" != typeof t || null == t.length) throw new Error("params not specified properly");
                    for (var e = [], i = 0; i < t.length; i++) e.push(new n(t[i]));
                    return new r({
                        array: e
                    }).getEncodedHex()
                }, this.setByParam = function(t) {
                    this.params = t
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.ocsp.SingleResponseList, ct.asn1.ASN1Object), ct.asn1.ocsp.SingleResponse = function(t) {
                var e = Error,
                    r = ct.asn1,
                    n = r.DERSequence,
                    i = r.DERGeneralizedTime,
                    s = r.DERTaggedObject,
                    a = r.ocsp,
                    o = a.CertID,
                    u = a.CertStatus,
                    c = r.x509.Extensions;
                a.SingleResponse.superclass.constructor.call(this), this.params = null, this.getEncodedHex = function() {
                    var t = this.params,
                        r = [];
                    if (null == t.certid) throw new e("certid unspecified");
                    if (null == t.status) throw new e("status unspecified");
                    if (null == t.thisupdate) throw new e("thisupdate unspecified");
                    if (r.push(new o(t.certid)), r.push(new u(t.status)), r.push(new i(t.thisupdate)), null != t.nextupdate) {
                        var a = new i(t.nextupdate);
                        r.push(new s({
                            tag: "a0",
                            explicit: !0,
                            obj: a
                        }))
                    }
                    if (null != t.ext) {
                        var h = new c(t.ext);
                        r.push(new s({
                            tag: "a1",
                            explicit: !0,
                            obj: h
                        }))
                    }
                    return new n({
                        array: r
                    }).getEncodedHex()
                }, this.setByParam = function(t) {
                    this.params = t
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.ocsp.SingleResponse, ct.asn1.ASN1Object), ct.asn1.ocsp.CertID = function(t) {
                var e = ct,
                    r = e.asn1,
                    n = r.DEROctetString,
                    i = r.DERInteger,
                    s = r.DERSequence,
                    a = r.x509.AlgorithmIdentifier,
                    o = r.ocsp,
                    u = o.DEFAULT_HASH,
                    c = e.crypto.Util.hashHex,
                    h = zt,
                    l = ft;
                if (o.CertID.superclass.constructor.call(this), this.dHashAlg = null, this.dIssuerNameHash = null, this.dIssuerKeyHash = null, this.dSerialNumber = null, this.setByValue = function(t, e, r, s) {
                        void 0 === s && (s = u), this.dHashAlg = new a({
                            name: s
                        }), this.dIssuerNameHash = new n({
                            hex: t
                        }), this.dIssuerKeyHash = new n({
                            hex: e
                        }), this.dSerialNumber = new i({
                            hex: r
                        })
                    }, this.setByCert = function(t, e, r) {
                        void 0 === r && (r = u);
                        var n = new h;
                        n.readCertPEM(e);
                        var i = new h;
                        i.readCertPEM(t);
                        var s = i.getPublicKeyHex(),
                            a = l.getTLVbyList(s, 0, [1, 0], "30"),
                            o = n.getSerialNumberHex(),
                            f = c(i.getSubjectHex(), r),
                            p = c(a, r);
                        this.setByValue(f, p, o, r), this.hoge = n.getSerialNumberHex()
                    }, this.getEncodedHex = function() {
                        if (null === this.dHashAlg && null === this.dIssuerNameHash && null === this.dIssuerKeyHash && null === this.dSerialNumber) throw "not yet set values";
                        var t = [this.dHashAlg, this.dIssuerNameHash, this.dIssuerKeyHash, this.dSerialNumber],
                            e = new s({
                                array: t
                            });
                        return this.hTLV = e.getEncodedHex(), this.hTLV
                    }, void 0 !== t) {
                    var f = t;
                    if (void 0 !== f.issuerCert && void 0 !== f.subjectCert) {
                        var p = u;
                        void 0 === f.alg && (p = void 0), this.setByCert(f.issuerCert, f.subjectCert, p)
                    } else {
                        if (void 0 === f.issname || void 0 === f.isskey || void 0 === f.sbjsn) throw new Error("invalid constructor arguments");
                        p = u;
                        void 0 === f.alg && (p = void 0), this.setByValue(f.issname, f.isskey, f.sbjsn, p)
                    }
                }
            }, i.lang.extend(ct.asn1.ocsp.CertID, ct.asn1.ASN1Object), ct.asn1.ocsp.CertStatus = function(t) {
                ct.asn1.ocsp.CertStatus.superclass.constructor.call(this), this.params = null, this.getEncodedHex = function() {
                    var t = this.params;
                    if ("good" == t.status) return "8000";
                    if ("unknown" == t.status) return "8200";
                    if ("revoked" == t.status) {
                        var e = [{
                            gentime: {
                                str: t.time
                            }
                        }];
                        null != t.reason && e.push({
                            tag: {
                                tag: "a0",
                                explicit: !0,
                                obj: {
                                    enum: {
                                        int: t.reason
                                    }
                                }
                            }
                        });
                        var r = {
                            tag: "a1",
                            explicit: !1,
                            obj: {
                                seq: e
                            }
                        };
                        return ct.asn1.ASN1Util.newObject({
                            tag: r
                        }).getEncodedHex()
                    }
                    throw new Error("bad status")
                }, this.setByParam = function(t) {
                    this.params = t
                }, void 0 !== t && this.setByParam(t)
            }, i.lang.extend(ct.asn1.ocsp.CertStatus, ct.asn1.ASN1Object), ct.asn1.ocsp.Request = function(t) {
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.ocsp;
                if (n.Request.superclass.constructor.call(this), this.dReqCert = null, this.dExt = null, this.getEncodedHex = function() {
                        var t = [];
                        if (null === this.dReqCert) throw "reqCert not set";
                        t.push(this.dReqCert);
                        var e = new r({
                            array: t
                        });
                        return this.hTLV = e.getEncodedHex(), this.hTLV
                    }, void 0 !== t) {
                    var i = new n.CertID(t);
                    this.dReqCert = i
                }
            }, i.lang.extend(ct.asn1.ocsp.Request, ct.asn1.ASN1Object), ct.asn1.ocsp.TBSRequest = function(t) {
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.ocsp;
                n.TBSRequest.superclass.constructor.call(this), this.version = 0, this.dRequestorName = null, this.dRequestList = [], this.dRequestExt = null, this.setRequestListByParam = function(t) {
                    for (var e = [], r = 0; r < t.length; r++) {
                        var i = new n.Request(t[0]);
                        e.push(i)
                    }
                    this.dRequestList = e
                }, this.getEncodedHex = function() {
                    var t = [];
                    if (0 !== this.version) throw "not supported version: " + this.version;
                    if (null !== this.dRequestorName) throw "requestorName not supported";
                    var e = new r({
                        array: this.dRequestList
                    });
                    if (t.push(e), null !== this.dRequestExt) throw "requestExtensions not supported";
                    var n = new r({
                        array: t
                    });
                    return this.hTLV = n.getEncodedHex(), this.hTLV
                }, void 0 !== t && void 0 !== t.reqList && this.setRequestListByParam(t.reqList)
            }, i.lang.extend(ct.asn1.ocsp.TBSRequest, ct.asn1.ASN1Object), ct.asn1.ocsp.OCSPRequest = function(t) {
                var e = ct.asn1,
                    r = e.DERSequence,
                    n = e.ocsp;
                if (n.OCSPRequest.superclass.constructor.call(this), this.dTbsRequest = null, this.dOptionalSignature = null, this.getEncodedHex = function() {
                        var t = [];
                        if (null === this.dTbsRequest) throw "tbsRequest not set";
                        if (t.push(this.dTbsRequest), null !== this.dOptionalSignature) throw "optionalSignature not supported";
                        var e = new r({
                            array: t
                        });
                        return this.hTLV = e.getEncodedHex(), this.hTLV
                    }, void 0 !== t && void 0 !== t.reqList) {
                    var i = new n.TBSRequest(t);
                    this.dTbsRequest = i
                }
            }, i.lang.extend(ct.asn1.ocsp.OCSPRequest, ct.asn1.ASN1Object), ct.asn1.ocsp.OCSPUtil = {}, ct.asn1.ocsp.OCSPUtil.getRequestHex = function(t, e, r) {
                var n = ct.asn1.ocsp;
                void 0 === r && (r = n.DEFAULT_HASH);
                var i = {
                    alg: r,
                    issuerCert: t,
                    subjectCert: e
                };
                return new n.OCSPRequest({
                    reqList: [i]
                }).getEncodedHex()
            }, ct.asn1.ocsp.OCSPUtil.getOCSPResponseInfo = function(t) {
                var e = ft,
                    r = e.getVbyList,
                    n = e.getVbyListEx,
                    i = e.getIdxbyList,
                    s = (e.getIdxbyListEx, e.getV),
                    a = {};
                try {
                    var o = n(t, 0, [0], "0a");
                    a.responseStatus = parseInt(o, 16)
                } catch (t) {}
                if (0 !== a.responseStatus) return a;
                try {
                    var u = i(t, 0, [1, 0, 1, 0, 0, 2, 0, 1]);
                    "80" === t.substr(u, 2) ? a.certStatus = "good" : "a1" === t.substr(u, 2) ? (a.certStatus = "revoked", a.revocationTime = Ct(r(t, u, [0]))) : "82" === t.substr(u, 2) && (a.certStatus = "unknown")
                } catch (t) {}
                try {
                    var c = i(t, 0, [1, 0, 1, 0, 0, 2, 0, 2]);
                    a.thisUpdate = Ct(s(t, c))
                } catch (t) {}
                try {
                    var h = i(t, 0, [1, 0, 1, 0, 0, 2, 0, 3]);
                    "a0" === t.substr(h, 2) && (a.nextUpdate = Ct(r(t, h, [0])))
                } catch (t) {}
                return a
            }, ct.asn1.ocsp.OCSPParser = function() {
                var t = Error,
                    e = zt,
                    r = new e,
                    n = ft,
                    i = n.getV,
                    s = n.getTLV,
                    a = n.getIdxbyList,
                    o = n.getTLVbyListEx,
                    u = n.getChildIdx;
                this.getOCSPRequest = function(e) {
                    var r = u(e, 0);
                    if (1 != r.length && 2 != r.length) throw new t("wrong number elements: " + r.length);
                    return this.getTBSRequest(s(e, r[0]))
                }, this.getTBSRequest = function(t) {
                    var e = {},
                        n = o(t, 0, [0], "30");
                    e.array = this.getRequestList(n);
                    var i = o(t, 0, ["[2]", 0], "30");
                    return null != i && (e.ext = r.getExtParamArray(i)), e
                }, this.getRequestList = function(t) {
                    for (var e = [], r = u(t, 0), n = 0; n < r.length; n++) {
                        t = s(t, r[n]);
                        e.push(this.getRequest(t))
                    }
                    return e
                }, this.getRequest = function(e) {
                    var n = u(e, 0);
                    if (1 != n.length && 2 != n.length) throw new t("wrong number elements: " + n.length);
                    var i = this.getCertID(s(e, n[0]));
                    if (2 == n.length) {
                        var o = a(e, 0, [1, 0]);
                        i.ext = r.getExtParamArray(s(e, o))
                    }
                    return i
                }, this.getCertID = function(r) {
                    var n = u(r, 0);
                    if (4 != n.length) throw new t("wrong number elements: " + n.length);
                    var a = new e,
                        o = {};
                    return o.alg = a.getAlgorithmIdentifierName(s(r, n[0])), o.issname = i(r, n[1]), o.isskey = i(r, n[2]), o.sbjsn = i(r, n[3]), o
                }
            }, void 0 !== ct && ct || (ct = {}), void 0 !== ct.lang && ct.lang || (ct.lang = {}), ct.lang.String = function() {}, "function" == typeof t ? (ht = function(e) {
                return vt(new t(e, "utf8").toString("base64"))
            }, lt = function(e) {
                return new t(mt(e), "base64").toString("utf8")
            }) : (ht = function(t) {
                return Et(Nt(Ot(t)))
            }, lt = function(t) {
                return decodeURIComponent(_t(St(t)))
            }), ct.lang.String.isInteger = function(t) {
                return !!t.match(/^[0-9]+$/) || !!t.match(/^-[0-9]+$/)
            }, ct.lang.String.isHex = function(t) {
                return !(t.length % 2 != 0 || !t.match(/^[0-9a-f]+$/) && !t.match(/^[0-9A-F]+$/))
            }, ct.lang.String.isBase64 = function(t) {
                return !(!(t = t.replace(/\s+/g, "")).match(/^[0-9A-Za-z+\/]+={0,3}$/) || t.length % 4 != 0)
            }, ct.lang.String.isBase64URL = function(t) {
                return !t.match(/[+/=]/) && (t = mt(t), ct.lang.String.isBase64(t))
            }, ct.lang.String.isIntegerArray = function(t) {
                return !!(t = t.replace(/\s+/g, "")).match(/^\[[0-9,]+\]$/)
            }, ct.lang.String.isPrintable = function(t) {
                return null !== t.match(/^[0-9A-Za-z '()+,-./:=?]*$/)
            }, ct.lang.String.isIA5 = function(t) {
                return null !== t.match(/^[\x20-\x21\x23-\x7f]*$/)
            }, ct.lang.String.isMail = function(t) {
                return null !== t.match(/^[A-Za-z0-9]{1}[A-Za-z0-9_.-]*@{1}[A-Za-z0-9_.-]{1,}\.[A-Za-z0-9]{1,}$/)
            };
            void 0 !== ct && ct || (ct = {}), void 0 !== ct.crypto && ct.crypto || (ct.crypto = {}), ct.crypto.Util = new function() {
                this.DIGESTINFOHEAD = {
                    sha1: "3021300906052b0e03021a05000414",
                    sha224: "302d300d06096086480165030402040500041c",
                    sha256: "3031300d060960864801650304020105000420",
                    sha384: "3041300d060960864801650304020205000430",
                    sha512: "3051300d060960864801650304020305000440",
                    md2: "3020300c06082a864886f70d020205000410",
                    md5: "3020300c06082a864886f70d020505000410",
                    ripemd160: "3021300906052b2403020105000414"
                }, this.DEFAULTPROVIDER = {
                    md5: "cryptojs",
                    sha1: "cryptojs",
                    sha224: "cryptojs",
                    sha256: "cryptojs",
                    sha384: "cryptojs",
                    sha512: "cryptojs",
                    ripemd160: "cryptojs",
                    hmacmd5: "cryptojs",
                    hmacsha1: "cryptojs",
                    hmacsha224: "cryptojs",
                    hmacsha256: "cryptojs",
                    hmacsha384: "cryptojs",
                    hmacsha512: "cryptojs",
                    hmacripemd160: "cryptojs",
                    MD5withRSA: "cryptojs/jsrsa",
                    SHA1withRSA: "cryptojs/jsrsa",
                    SHA224withRSA: "cryptojs/jsrsa",
                    SHA256withRSA: "cryptojs/jsrsa",
                    SHA384withRSA: "cryptojs/jsrsa",
                    SHA512withRSA: "cryptojs/jsrsa",
                    RIPEMD160withRSA: "cryptojs/jsrsa",
                    MD5withECDSA: "cryptojs/jsrsa",
                    SHA1withECDSA: "cryptojs/jsrsa",
                    SHA224withECDSA: "cryptojs/jsrsa",
                    SHA256withECDSA: "cryptojs/jsrsa",
                    SHA384withECDSA: "cryptojs/jsrsa",
                    SHA512withECDSA: "cryptojs/jsrsa",
                    RIPEMD160withECDSA: "cryptojs/jsrsa",
                    SHA1withDSA: "cryptojs/jsrsa",
                    SHA224withDSA: "cryptojs/jsrsa",
                    SHA256withDSA: "cryptojs/jsrsa",
                    MD5withRSAandMGF1: "cryptojs/jsrsa",
                    SHAwithRSAandMGF1: "cryptojs/jsrsa",
                    SHA1withRSAandMGF1: "cryptojs/jsrsa",
                    SHA224withRSAandMGF1: "cryptojs/jsrsa",
                    SHA256withRSAandMGF1: "cryptojs/jsrsa",
                    SHA384withRSAandMGF1: "cryptojs/jsrsa",
                    SHA512withRSAandMGF1: "cryptojs/jsrsa",
                    RIPEMD160withRSAandMGF1: "cryptojs/jsrsa"
                }, this.CRYPTOJSMESSAGEDIGESTNAME = {
                    md5: y.algo.MD5,
                    sha1: y.algo.SHA1,
                    sha224: y.algo.SHA224,
                    sha256: y.algo.SHA256,
                    sha384: y.algo.SHA384,
                    sha512: y.algo.SHA512,
                    ripemd160: y.algo.RIPEMD160
                }, this.getDigestInfoHex = function(t, e) {
                    if (void 0 === this.DIGESTINFOHEAD[e]) throw "alg not supported in Util.DIGESTINFOHEAD: " + e;
                    return this.DIGESTINFOHEAD[e] + t
                }, this.getPaddedDigestInfoHex = function(t, e, r) {
                    var n = this.getDigestInfoHex(t, e),
                        i = r / 4;
                    if (n.length + 22 > i) throw "key is too short for SigAlg: keylen=" + r + "," + e;
                    for (var s = "0001", a = "00" + n, o = "", u = i - s.length - a.length, c = 0; c < u; c += 2) o += "ff";
                    return s + o + a
                }, this.hashString = function(t, e) {
                    return new ct.crypto.MessageDigest({
                        alg: e
                    }).digestString(t)
                }, this.hashHex = function(t, e) {
                    return new ct.crypto.MessageDigest({
                        alg: e
                    }).digestHex(t)
                }, this.sha1 = function(t) {
                    return this.hashString(t, "sha1")
                }, this.sha256 = function(t) {
                    return this.hashString(t, "sha256")
                }, this.sha256Hex = function(t) {
                    return this.hashHex(t, "sha256")
                }, this.sha512 = function(t) {
                    return this.hashString(t, "sha512")
                }, this.sha512Hex = function(t) {
                    return this.hashHex(t, "sha512")
                }, this.isKey = function(t) {
                    return t instanceof nt || t instanceof ct.crypto.DSA || t instanceof ct.crypto.ECDSA
                }
            }, ct.crypto.Util.md5 = function(t) {
                return new ct.crypto.MessageDigest({
                    alg: "md5",
                    prov: "cryptojs"
                }).digestString(t)
            }, ct.crypto.Util.ripemd160 = function(t) {
                return new ct.crypto.MessageDigest({
                    alg: "ripemd160",
                    prov: "cryptojs"
                }).digestString(t)
            }, ct.crypto.Util.SECURERANDOMGEN = new tt, ct.crypto.Util.getRandomHexOfNbytes = function(t) {
                var e = new Array(t);
                return ct.crypto.Util.SECURERANDOMGEN.nextBytes(e), gt(e)
            }, ct.crypto.Util.getRandomBigIntegerOfNbytes = function(t) {
                return new C(ct.crypto.Util.getRandomHexOfNbytes(t), 16)
            }, ct.crypto.Util.getRandomHexOfNbits = function(t) {
                var e = t % 8,
                    r = new Array((t - e) / 8 + 1);
                return ct.crypto.Util.SECURERANDOMGEN.nextBytes(r), r[0] = (255 << e & 255 ^ 255) & r[0], gt(r)
            }, ct.crypto.Util.getRandomBigIntegerOfNbits = function(t) {
                return new C(ct.crypto.Util.getRandomHexOfNbits(t), 16)
            }, ct.crypto.Util.getRandomBigIntegerZeroToMax = function(t) {
                for (var e = t.bitLength();;) {
                    var r = ct.crypto.Util.getRandomBigIntegerOfNbits(e);
                    if (-1 != t.compareTo(r)) return r
                }
            }, ct.crypto.Util.getRandomBigIntegerMinToMax = function(t, e) {
                var r = t.compareTo(e);
                if (1 == r) throw "biMin is greater than biMax";
                if (0 == r) return t;
                var n = e.subtract(t);
                return ct.crypto.Util.getRandomBigIntegerZeroToMax(n).add(t)
            }, ct.crypto.MessageDigest = function(t) {
                this.setAlgAndProvider = function(t, e) {
                    if (null !== (t = ct.crypto.MessageDigest.getCanonicalAlgName(t)) && void 0 === e && (e = ct.crypto.Util.DEFAULTPROVIDER[t]), -1 != ":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(t) && "cryptojs" == e) {
                        try {
                            this.md = ct.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[t].create()
                        } catch (e) {
                            throw "setAlgAndProvider hash alg set fail alg=" + t + "/" + e
                        }
                        this.updateString = function(t) {
                            this.md.update(t)
                        }, this.updateHex = function(t) {
                            var e = y.enc.Hex.parse(t);
                            this.md.update(e)
                        }, this.digest = function() {
                            return this.md.finalize().toString(y.enc.Hex)
                        }, this.digestString = function(t) {
                            return this.updateString(t), this.digest()
                        }, this.digestHex = function(t) {
                            return this.updateHex(t), this.digest()
                        }
                    }
                    if (-1 != ":sha256:".indexOf(t) && "sjcl" == e) {
                        try {
                            this.md = new sjcl.hash.sha256
                        } catch (e) {
                            throw "setAlgAndProvider hash alg set fail alg=" + t + "/" + e
                        }
                        this.updateString = function(t) {
                            this.md.update(t)
                        }, this.updateHex = function(t) {
                            var e = sjcl.codec.hex.toBits(t);
                            this.md.update(e)
                        }, this.digest = function() {
                            var t = this.md.finalize();
                            return sjcl.codec.hex.fromBits(t)
                        }, this.digestString = function(t) {
                            return this.updateString(t), this.digest()
                        }, this.digestHex = function(t) {
                            return this.updateHex(t), this.digest()
                        }
                    }
                }, this.updateString = function(t) {
                    throw "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName
                }, this.updateHex = function(t) {
                    throw "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName
                }, this.digest = function() {
                    throw "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName
                }, this.digestString = function(t) {
                    throw "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName
                }, this.digestHex = function(t) {
                    throw "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName
                }, void 0 !== t && void 0 !== t.alg && (this.algName = t.alg, void 0 === t.prov && (this.provName = ct.crypto.Util.DEFAULTPROVIDER[this.algName]), this.setAlgAndProvider(this.algName, this.provName))
            }, ct.crypto.MessageDigest.getCanonicalAlgName = function(t) {
                return "string" == typeof t && (t = (t = t.toLowerCase()).replace(/-/, "")), t
            }, ct.crypto.MessageDigest.getHashLength = function(t) {
                var e = ct.crypto.MessageDigest,
                    r = e.getCanonicalAlgName(t);
                if (void 0 === e.HASHLENGTH[r]) throw "not supported algorithm: " + t;
                return e.HASHLENGTH[r]
            }, ct.crypto.MessageDigest.HASHLENGTH = {
                md5: 16,
                sha1: 20,
                sha224: 28,
                sha256: 32,
                sha384: 48,
                sha512: 64,
                ripemd160: 20
            }, ct.crypto.Mac = function(t) {
                this.setAlgAndProvider = function(t, e) {
                    if (null == (t = t.toLowerCase()) && (t = "hmacsha1"), "hmac" != (t = t.toLowerCase()).substr(0, 4)) throw "setAlgAndProvider unsupported HMAC alg: " + t;
                    void 0 === e && (e = ct.crypto.Util.DEFAULTPROVIDER[t]), this.algProv = t + "/" + e;
                    var r = t.substr(4);
                    if (-1 != ":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(r) && "cryptojs" == e) {
                        try {
                            var n = ct.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[r];
                            this.mac = y.algo.HMAC.create(n, this.pass)
                        } catch (t) {
                            throw "setAlgAndProvider hash alg set fail hashAlg=" + r + "/" + t
                        }
                        this.updateString = function(t) {
                            this.mac.update(t)
                        }, this.updateHex = function(t) {
                            var e = y.enc.Hex.parse(t);
                            this.mac.update(e)
                        }, this.doFinal = function() {
                            return this.mac.finalize().toString(y.enc.Hex)
                        }, this.doFinalString = function(t) {
                            return this.updateString(t), this.doFinal()
                        }, this.doFinalHex = function(t) {
                            return this.updateHex(t), this.doFinal()
                        }
                    }
                }, this.updateString = function(t) {
                    throw "updateString(str) not supported for this alg/prov: " + this.algProv
                }, this.updateHex = function(t) {
                    throw "updateHex(hex) not supported for this alg/prov: " + this.algProv
                }, this.doFinal = function() {
                    throw "digest() not supported for this alg/prov: " + this.algProv
                }, this.doFinalString = function(t) {
                    throw "digestString(str) not supported for this alg/prov: " + this.algProv
                }, this.doFinalHex = function(t) {
                    throw "digestHex(hex) not supported for this alg/prov: " + this.algProv
                }, this.setPassword = function(t) {
                    if ("string" == typeof t) {
                        var e = t;
                        return t.length % 2 != 1 && t.match(/^[0-9A-Fa-f]+$/) || (e = wt(t)), void(this.pass = y.enc.Hex.parse(e))
                    }
                    if ("object" != typeof t) throw "KJUR.crypto.Mac unsupported password type: " + t;
                    e = null;
                    if (void 0 !== t.hex) {
                        if (t.hex.length % 2 != 0 || !t.hex.match(/^[0-9A-Fa-f]+$/)) throw "Mac: wrong hex password: " + t.hex;
                        e = t.hex
                    }
                    if (void 0 !== t.utf8 && (e = bt(t.utf8)), void 0 !== t.rstr && (e = wt(t.rstr)), void 0 !== t.b64 && (e = S(t.b64)), void 0 !== t.b64u && (e = St(t.b64u)), null == e) throw "KJUR.crypto.Mac unsupported password type: " + t;
                    this.pass = y.enc.Hex.parse(e)
                }, void 0 !== t && (void 0 !== t.pass && this.setPassword(t.pass), void 0 !== t.alg && (this.algName = t.alg, void 0 === t.prov && (this.provName = ct.crypto.Util.DEFAULTPROVIDER[this.algName]), this.setAlgAndProvider(this.algName, this.provName)))
            }, ct.crypto.Signature = function(t) {
                var e = null;
                if (this._setAlgNames = function() {
                        var t = this.algName.match(/^(.+)with(.+)$/);
                        t && (this.mdAlgName = t[1].toLowerCase(), this.pubkeyAlgName = t[2].toLowerCase(), "rsaandmgf1" == this.pubkeyAlgName && "sha" == this.mdAlgName && (this.mdAlgName = "sha1"))
                    }, this._zeroPaddingOfSignature = function(t, e) {
                        for (var r = "", n = e / 4 - t.length, i = 0; i < n; i++) r += "0";
                        return r + t
                    }, this.setAlgAndProvider = function(t, e) {
                        if (this._setAlgNames(), "cryptojs/jsrsa" != e) throw new Error("provider not supported: " + e);
                        if (-1 != ":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName)) {
                            try {
                                this.md = new ct.crypto.MessageDigest({
                                    alg: this.mdAlgName
                                })
                            } catch (t) {
                                throw new Error("setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + t)
                            }
                            this.init = function(t, e) {
                                var r = null;
                                try {
                                    r = void 0 === e ? Ht.getKey(t) : Ht.getKey(t, e)
                                } catch (t) {
                                    throw "init failed:" + t
                                }
                                if (!0 === r.isPrivate) this.prvKey = r, this.state = "SIGN";
                                else {
                                    if (!0 !== r.isPublic) throw "init failed.:" + r;
                                    this.pubKey = r, this.state = "VERIFY"
                                }
                            }, this.updateString = function(t) {
                                this.md.updateString(t)
                            }, this.updateHex = function(t) {
                                this.md.updateHex(t)
                            }, this.sign = function() {
                                if (this.sHashHex = this.md.digest(), void 0 === this.prvKey && void 0 !== this.ecprvhex && void 0 !== this.eccurvename && void 0 !== ct.crypto.ECDSA && (this.prvKey = new ct.crypto.ECDSA({
                                        curve: this.eccurvename,
                                        prv: this.ecprvhex
                                    })), this.prvKey instanceof nt && "rsaandmgf1" === this.pubkeyAlgName) this.hSign = this.prvKey.signWithMessageHashPSS(this.sHashHex, this.mdAlgName, this.pssSaltLen);
                                else if (this.prvKey instanceof nt && "rsa" === this.pubkeyAlgName) this.hSign = this.prvKey.signWithMessageHash(this.sHashHex, this.mdAlgName);
                                else if (this.prvKey instanceof ct.crypto.ECDSA) this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);
                                else {
                                    if (!(this.prvKey instanceof ct.crypto.DSA)) throw "Signature: unsupported private key alg: " + this.pubkeyAlgName;
                                    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex)
                                }
                                return this.hSign
                            }, this.signString = function(t) {
                                return this.updateString(t), this.sign()
                            }, this.signHex = function(t) {
                                return this.updateHex(t), this.sign()
                            }, this.verify = function(t) {
                                if (this.sHashHex = this.md.digest(), void 0 === this.pubKey && void 0 !== this.ecpubhex && void 0 !== this.eccurvename && void 0 !== ct.crypto.ECDSA && (this.pubKey = new ct.crypto.ECDSA({
                                        curve: this.eccurvename,
                                        pub: this.ecpubhex
                                    })), this.pubKey instanceof nt && "rsaandmgf1" === this.pubkeyAlgName) return this.pubKey.verifyWithMessageHashPSS(this.sHashHex, t, this.mdAlgName, this.pssSaltLen);
                                if (this.pubKey instanceof nt && "rsa" === this.pubkeyAlgName) return this.pubKey.verifyWithMessageHash(this.sHashHex, t);
                                if (void 0 !== ct.crypto.ECDSA && this.pubKey instanceof ct.crypto.ECDSA) return this.pubKey.verifyWithMessageHash(this.sHashHex, t);
                                if (void 0 !== ct.crypto.DSA && this.pubKey instanceof ct.crypto.DSA) return this.pubKey.verifyWithMessageHash(this.sHashHex, t);
                                throw "Signature: unsupported public key alg: " + this.pubkeyAlgName
                            }
                        }
                    }, this.init = function(t, e) {
                        throw "init(key, pass) not supported for this alg:prov=" + this.algProvName
                    }, this.updateString = function(t) {
                        throw "updateString(str) not supported for this alg:prov=" + this.algProvName
                    }, this.updateHex = function(t) {
                        throw "updateHex(hex) not supported for this alg:prov=" + this.algProvName
                    }, this.sign = function() {
                        throw "sign() not supported for this alg:prov=" + this.algProvName
                    }, this.signString = function(t) {
                        throw "digestString(str) not supported for this alg:prov=" + this.algProvName
                    }, this.signHex = function(t) {
                        throw "digestHex(hex) not supported for this alg:prov=" + this.algProvName
                    }, this.verify = function(t) {
                        throw "verify(hSigVal) not supported for this alg:prov=" + this.algProvName
                    }, this.initParams = t, void 0 !== t && (void 0 !== t.alg && (this.algName = t.alg, void 0 === t.prov ? this.provName = ct.crypto.Util.DEFAULTPROVIDER[this.algName] : this.provName = t.prov, this.algProvName = this.algName + ":" + this.provName, this.setAlgAndProvider(this.algName, this.provName), this._setAlgNames()), void 0 !== t.psssaltlen && (this.pssSaltLen = t.psssaltlen), void 0 !== t.prvkeypem)) {
                    if (void 0 !== t.prvkeypas) throw "both prvkeypem and prvkeypas parameters not supported";
                    try {
                        e = Ht.getKey(t.prvkeypem);
                        this.init(e)
                    } catch (t) {
                        throw "fatal error to load pem private key: " + t
                    }
                }
            }, ct.crypto.Cipher = function(t) {}, ct.crypto.Cipher.encrypt = function(t, e, r) {
                if (e instanceof nt && e.isPublic) {
                    var n = ct.crypto.Cipher.getAlgByKeyAndName(e, r);
                    if ("RSA" === n) return e.encrypt(t);
                    if ("RSAOAEP" === n) return e.encryptOAEP(t, "sha1");
                    var i = n.match(/^RSAOAEP(\d+)$/);
                    if (null !== i) return e.encryptOAEP(t, "sha" + i[1]);
                    throw "Cipher.encrypt: unsupported algorithm for RSAKey: " + r
                }
                throw "Cipher.encrypt: unsupported key or algorithm"
            }, ct.crypto.Cipher.decrypt = function(t, e, r) {
                if (e instanceof nt && e.isPrivate) {
                    var n = ct.crypto.Cipher.getAlgByKeyAndName(e, r);
                    if ("RSA" === n) return e.decrypt(t);
                    if ("RSAOAEP" === n) return e.decryptOAEP(t, "sha1");
                    var i = n.match(/^RSAOAEP(\d+)$/);
                    if (null !== i) return e.decryptOAEP(t, "sha" + i[1]);
                    throw "Cipher.decrypt: unsupported algorithm for RSAKey: " + r
                }
                throw "Cipher.decrypt: unsupported key or algorithm"
            }, ct.crypto.Cipher.getAlgByKeyAndName = function(t, e) {
                if (t instanceof nt) {
                    if (-1 != ":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:".indexOf(e)) return e;
                    if (null == e) return "RSA";
                    throw "getAlgByKeyAndName: not supported algorithm name for RSAKey: " + e
                }
                throw "getAlgByKeyAndName: not supported algorithm name: " + e
            }, ct.crypto.OID = new function() {
                this.oidhex2name = {
                    "2a864886f70d010101": "rsaEncryption",
                    "2a8648ce3d0201": "ecPublicKey",
                    "2a8648ce380401": "dsa",
                    "2a8648ce3d030107": "secp256r1",
                    "2b8104001f": "secp192k1",
                    "2b81040021": "secp224r1",
                    "2b8104000a": "secp256k1",
                    "2b81040023": "secp521r1",
                    "2b81040022": "secp384r1",
                    "2a8648ce380403": "SHA1withDSA",
                    "608648016503040301": "SHA224withDSA",
                    "608648016503040302": "SHA256withDSA"
                }
            }, void 0 !== ct && ct || (ct = {}), void 0 !== ct.crypto && ct.crypto || (ct.crypto = {}), ct.crypto.ECDSA = function(t) {
                var e = Error,
                    r = C,
                    n = at,
                    i = ct.crypto.ECDSA,
                    s = ct.crypto.ECParameterDB,
                    a = i.getName,
                    o = ft,
                    u = o.getVbyListEx,
                    c = o.isASN1HEX,
                    h = new tt;
                this.type = "EC", this.isPrivate = !1, this.isPublic = !1, this.getBigRandom = function(t) {
                    return new r(t.bitLength(), h).mod(t.subtract(r.ONE)).add(r.ONE)
                }, this.setNamedCurve = function(t) {
                    this.ecparams = s.getByName(t), this.prvKeyHex = null, this.pubKeyHex = null, this.curveName = t
                }, this.setPrivateKeyHex = function(t) {
                    this.isPrivate = !0, this.prvKeyHex = t
                }, this.setPublicKeyHex = function(t) {
                    this.isPublic = !0, this.pubKeyHex = t
                }, this.getPublicKeyXYHex = function() {
                    var t = this.pubKeyHex;
                    if ("04" !== t.substr(0, 2)) throw "this method supports uncompressed format(04) only";
                    var e = this.ecparams.keylen / 4;
                    if (t.length !== 2 + 2 * e) throw "malformed public key hex length";
                    var r = {};
                    return r.x = t.substr(2, e), r.y = t.substr(2 + e), r
                }, this.getShortNISTPCurveName = function() {
                    var t = this.curveName;
                    return "secp256r1" === t || "NIST P-256" === t || "P-256" === t || "prime256v1" === t ? "P-256" : "secp384r1" === t || "NIST P-384" === t || "P-384" === t ? "P-384" : null
                }, this.generateKeyPairHex = function() {
                    var t = this.ecparams.n,
                        e = this.getBigRandom(t),
                        r = this.ecparams.G.multiply(e),
                        n = r.getX().toBigInteger(),
                        i = r.getY().toBigInteger(),
                        s = this.ecparams.keylen / 4,
                        a = ("0000000000" + e.toString(16)).slice(-s),
                        o = "04" + ("0000000000" + n.toString(16)).slice(-s) + ("0000000000" + i.toString(16)).slice(-s);
                    return this.setPrivateKeyHex(a), this.setPublicKeyHex(o), {
                        ecprvhex: a,
                        ecpubhex: o
                    }
                }, this.signWithMessageHash = function(t) {
                    return this.signHex(t, this.prvKeyHex)
                }, this.signHex = function(t, e) {
                    var n = new r(e, 16),
                        s = this.ecparams.n,
                        a = new r(t.substring(0, this.ecparams.keylen / 4), 16);
                    do {
                        var o = this.getBigRandom(s),
                            u = this.ecparams.G.multiply(o).getX().toBigInteger().mod(s)
                    } while (u.compareTo(r.ZERO) <= 0);
                    var c = o.modInverse(s).multiply(a.add(n.multiply(u))).mod(s);
                    return i.biRSSigToASN1Sig(u, c)
                }, this.sign = function(t, e) {
                    var n = e,
                        i = this.ecparams.n,
                        s = r.fromByteArrayUnsigned(t);
                    do {
                        var a = this.getBigRandom(i),
                            o = this.ecparams.G.multiply(a).getX().toBigInteger().mod(i)
                    } while (o.compareTo(C.ZERO) <= 0);
                    var u = a.modInverse(i).multiply(s.add(n.multiply(o))).mod(i);
                    return this.serializeSig(o, u)
                }, this.verifyWithMessageHash = function(t, e) {
                    return this.verifyHex(t, e, this.pubKeyHex)
                }, this.verifyHex = function(t, e, s) {
                    try {
                        var a, o, u = i.parseSigHex(e);
                        a = u.r, o = u.s;
                        var c = n.decodeFromHex(this.ecparams.curve, s),
                            h = new r(t.substring(0, this.ecparams.keylen / 4), 16);
                        return this.verifyRaw(h, a, o, c)
                    } catch (t) {
                        return !1
                    }
                }, this.verify = function(t, e, i) {
                    var s, a, o;
                    if (Bitcoin.Util.isArray(e)) {
                        var u = this.parseSig(e);
                        s = u.r, a = u.s
                    } else {
                        if ("object" != typeof e || !e.r || !e.s) throw "Invalid value for signature";
                        s = e.r, a = e.s
                    }
                    if (i instanceof at) o = i;
                    else {
                        if (!Bitcoin.Util.isArray(i)) throw "Invalid format for pubkey value, must be byte array or ECPointFp";
                        o = n.decodeFrom(this.ecparams.curve, i)
                    }
                    var c = r.fromByteArrayUnsigned(t);
                    return this.verifyRaw(c, s, a, o)
                }, this.verifyRaw = function(t, e, n, i) {
                    var s = this.ecparams.n,
                        a = this.ecparams.G;
                    if (e.compareTo(r.ONE) < 0 || e.compareTo(s) >= 0) return !1;
                    if (n.compareTo(r.ONE) < 0 || n.compareTo(s) >= 0) return !1;
                    var o = n.modInverse(s),
                        u = t.multiply(o).mod(s),
                        c = e.multiply(o).mod(s);
                    return a.multiply(u).add(i.multiply(c)).getX().toBigInteger().mod(s).equals(e)
                }, this.serializeSig = function(t, e) {
                    var r = t.toByteArraySigned(),
                        n = e.toByteArraySigned(),
                        i = [];
                    return i.push(2), i.push(r.length), (i = i.concat(r)).push(2), i.push(n.length), (i = i.concat(n)).unshift(i.length), i.unshift(48), i
                }, this.parseSig = function(t) {
                    var e;
                    if (48 != t[0]) throw new Error("Signature not a valid DERSequence");
                    if (2 != t[e = 2]) throw new Error("First element in signature must be a DERInteger");
                    var n = t.slice(e + 2, e + 2 + t[e + 1]);
                    if (2 != t[e += 2 + t[e + 1]]) throw new Error("Second element in signature must be a DERInteger");
                    var i = t.slice(e + 2, e + 2 + t[e + 1]);
                    return e += 2 + t[e + 1], {
                        r: r.fromByteArrayUnsigned(n),
                        s: r.fromByteArrayUnsigned(i)
                    }
                }, this.parseSigCompact = function(t) {
                    if (65 !== t.length) throw "Signature has the wrong length";
                    var e = t[0] - 27;
                    if (e < 0 || e > 7) throw "Invalid signature type";
                    var n = this.ecparams.n;
                    return {
                        r: r.fromByteArrayUnsigned(t.slice(1, 33)).mod(n),
                        s: r.fromByteArrayUnsigned(t.slice(33, 65)).mod(n),
                        i: e
                    }
                }, this.readPKCS5PrvKeyHex = function(t) {
                    if (!1 === c(t)) throw new Error("not ASN.1 hex string");
                    var e, r, n;
                    try {
                        e = u(t, 0, ["[0]", 0], "06"), r = u(t, 0, [1], "04");
                        try {
                            n = u(t, 0, ["[1]", 0], "03")
                        } catch (t) {}
                    } catch (t) {
                        throw new Error("malformed PKCS#1/5 plain ECC private key")
                    }
                    if (this.curveName = a(e), void 0 === this.curveName) throw "unsupported curve name";
                    this.setNamedCurve(this.curveName), this.setPublicKeyHex(n), this.setPrivateKeyHex(r), this.isPublic = !1
                }, this.readPKCS8PrvKeyHex = function(t) {
                    if (!1 === c(t)) throw new e("not ASN.1 hex string");
                    var r, n, i;
                    try {
                        u(t, 0, [1, 0], "06"), r = u(t, 0, [1, 1], "06"), n = u(t, 0, [2, 0, 1], "04");
                        try {
                            i = u(t, 0, [2, 0, "[1]", 0], "03")
                        } catch (t) {}
                    } catch (t) {
                        throw new e("malformed PKCS#8 plain ECC private key")
                    }
                    if (this.curveName = a(r), void 0 === this.curveName) throw new e("unsupported curve name");
                    this.setNamedCurve(this.curveName), this.setPublicKeyHex(i), this.setPrivateKeyHex(n), this.isPublic = !1
                }, this.readPKCS8PubKeyHex = function(t) {
                    if (!1 === c(t)) throw new e("not ASN.1 hex string");
                    var r, n;
                    try {
                        u(t, 0, [0, 0], "06"), r = u(t, 0, [0, 1], "06"), n = u(t, 0, [1], "03")
                    } catch (t) {
                        throw new e("malformed PKCS#8 ECC public key")
                    }
                    if (this.curveName = a(r), null === this.curveName) throw new e("unsupported curve name");
                    this.setNamedCurve(this.curveName), this.setPublicKeyHex(n)
                }, this.readCertPubKeyHex = function(t, r) {
                    if (!1 === c(t)) throw new e("not ASN.1 hex string");
                    var n, i;
                    try {
                        n = u(t, 0, [0, 5, 0, 1], "06"), i = u(t, 0, [0, 5, 1], "03")
                    } catch (t) {
                        throw new e("malformed X.509 certificate ECC public key")
                    }
                    if (this.curveName = a(n), null === this.curveName) throw new e("unsupported curve name");
                    this.setNamedCurve(this.curveName), this.setPublicKeyHex(i)
                }, void 0 !== t && void 0 !== t.curve && (this.curveName = t.curve), void 0 === this.curveName && (this.curveName = "secp256r1"), this.setNamedCurve(this.curveName), void 0 !== t && (void 0 !== t.prv && this.setPrivateKeyHex(t.prv), void 0 !== t.pub && this.setPublicKeyHex(t.pub))
            }, ct.crypto.ECDSA.parseSigHex = function(t) {
                var e = ct.crypto.ECDSA.parseSigHexInHexRS(t);
                return {
                    r: new C(e.r, 16),
                    s: new C(e.s, 16)
                }
            }, ct.crypto.ECDSA.parseSigHexInHexRS = function(t) {
                var e = ft,
                    r = e.getChildIdx,
                    n = e.getV;
                if (e.checkStrictDER(t, 0), "30" != t.substr(0, 2)) throw new Error("signature is not a ASN.1 sequence");
                var i = r(t, 0);
                if (2 != i.length) throw new Error("signature shall have two elements");
                var s = i[0],
                    a = i[1];
                if ("02" != t.substr(s, 2)) throw new Error("1st item not ASN.1 integer");
                if ("02" != t.substr(a, 2)) throw new Error("2nd item not ASN.1 integer");
                return {
                    r: n(t, s),
                    s: n(t, a)
                }
            }, ct.crypto.ECDSA.asn1SigToConcatSig = function(t) {
                var e = ct.crypto.ECDSA.parseSigHexInHexRS(t),
                    r = e.r,
                    n = e.s;
                if ("00" == r.substr(0, 2) && r.length % 32 == 2 && (r = r.substr(2)), "00" == n.substr(0, 2) && n.length % 32 == 2 && (n = n.substr(2)), r.length % 32 == 30 && (r = "00" + r), n.length % 32 == 30 && (n = "00" + n), r.length % 32 != 0) throw "unknown ECDSA sig r length error";
                if (n.length % 32 != 0) throw "unknown ECDSA sig s length error";
                return r + n
            }, ct.crypto.ECDSA.concatSigToASN1Sig = function(t) {
                if (t.length / 2 * 8 % 128 != 0) throw "unknown ECDSA concatinated r-s sig  length error";
                var e = t.substr(0, t.length / 2),
                    r = t.substr(t.length / 2);
                return ct.crypto.ECDSA.hexRSSigToASN1Sig(e, r)
            }, ct.crypto.ECDSA.hexRSSigToASN1Sig = function(t, e) {
                var r = new C(t, 16),
                    n = new C(e, 16);
                return ct.crypto.ECDSA.biRSSigToASN1Sig(r, n)
            }, ct.crypto.ECDSA.biRSSigToASN1Sig = function(t, e) {
                var r = ct.asn1,
                    n = new r.DERInteger({
                        bigint: t
                    }),
                    i = new r.DERInteger({
                        bigint: e
                    });
                return new r.DERSequence({
                    array: [n, i]
                }).getEncodedHex()
            }, ct.crypto.ECDSA.getName = function(t) {
                return "2b8104001f" === t ? "secp192k1" : "2a8648ce3d030107" === t ? "secp256r1" : "2b8104000a" === t ? "secp256k1" : "2b81040021" === t ? "secp224r1" : "2b81040022" === t ? "secp384r1" : -1 !== "|secp256r1|NIST P-256|P-256|prime256v1|".indexOf(t) ? "secp256r1" : -1 !== "|secp256k1|".indexOf(t) ? "secp256k1" : -1 !== "|secp224r1|NIST P-224|P-224|".indexOf(t) ? "secp224r1" : -1 !== "|secp384r1|NIST P-384|P-384|".indexOf(t) ? "secp384r1" : null
            }, void 0 !== ct && ct || (ct = {}), void 0 !== ct.crypto && ct.crypto || (ct.crypto = {}), ct.crypto.ECParameterDB = new function() {
                var t = {},
                    e = {};

                function r(t) {
                    return new C(t, 16)
                }
                this.getByName = function(r) {
                    var n = r;
                    if (void 0 !== e[n] && (n = e[r]), void 0 !== t[n]) return t[n];
                    throw "unregistered EC curve name: " + n
                }, this.regist = function(n, i, s, a, o, u, c, h, l, f, p, d) {
                    t[n] = {};
                    var g = r(s),
                        y = r(a),
                        v = r(o),
                        m = r(u),
                        E = r(c),
                        S = new ot(g, y, v),
                        b = S.decodePointHex("04" + h + l);
                    t[n].name = n, t[n].keylen = i, t[n].curve = S, t[n].G = b, t[n].n = m, t[n].h = E, t[n].oid = p, t[n].info = d;
                    for (var C = 0; C < f.length; C++) e[f[C]] = n
                }
            }, ct.crypto.ECParameterDB.regist("secp128r1", 128, "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC", "E87579C11079F43DD824993C2CEE5ED3", "FFFFFFFE0000000075A30D1B9038A115", "1", "161FF7528B899B2D0C28607CA52C5B86", "CF5AC8395BAFEB13C02DA292DDED7A83", [], "", "secp128r1 : SECG curve over a 128 bit prime field"), ct.crypto.ECParameterDB.regist("secp160k1", 160, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73", "0", "7", "0100000000000000000001B8FA16DFAB9ACA16B6B3", "1", "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB", "938CF935318FDCED6BC28286531733C3F03C4FEE", [], "", "secp160k1 : SECG curve over a 160 bit prime field"), ct.crypto.ECParameterDB.regist("secp160r1", 160, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC", "1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45", "0100000000000000000001F4C8F927AED3CA752257", "1", "4A96B5688EF573284664698968C38BB913CBFC82", "23A628553168947D59DCC912042351377AC5FB32", [], "", "secp160r1 : SECG curve over a 160 bit prime field"), ct.crypto.ECParameterDB.regist("secp192k1", 192, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37", "0", "3", "FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D", "1", "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D", "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D", []), ct.crypto.ECParameterDB.regist("secp192r1", 192, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC", "64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1", "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831", "1", "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012", "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811", []), ct.crypto.ECParameterDB.regist("secp224r1", 224, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE", "B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4", "FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D", "1", "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21", "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34", []), ct.crypto.ECParameterDB.regist("secp256k1", 256, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", "0", "7", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", "1", "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", []), ct.crypto.ECParameterDB.regist("secp256r1", 256, "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC", "5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B", "FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551", "1", "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296", "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5", ["NIST P-256", "P-256", "prime256v1"]), ct.crypto.ECParameterDB.regist("secp384r1", 384, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC", "B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973", "1", "AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7", "3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f", ["NIST P-384", "P-384"]), ct.crypto.ECParameterDB.regist("secp521r1", 521, "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC", "051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00", "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409", "1", "C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66", "011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650", ["NIST P-521", "P-521"]), void 0 !== ct && ct || (ct = {}), void 0 !== ct.crypto && ct.crypto || (ct.crypto = {}), ct.crypto.DSA = function() {
                var t = ft,
                    e = (t.getVbyList, t.getVbyListEx),
                    r = t.isASN1HEX,
                    n = C;
                this.p = null, this.q = null, this.g = null, this.y = null, this.x = null, this.type = "DSA", this.isPrivate = !1, this.isPublic = !1, this.setPrivate = function(t, e, r, n, i) {
                    this.isPrivate = !0, this.p = t, this.q = e, this.g = r, this.y = n, this.x = i
                }, this.setPrivateHex = function(t, e, r, n, i) {
                    var s, a, o, u, c;
                    s = new C(t, 16), a = new C(e, 16), o = new C(r, 16), u = "string" == typeof n && n.length > 1 ? new C(n, 16) : null, c = new C(i, 16), this.setPrivate(s, a, o, u, c)
                }, this.setPublic = function(t, e, r, n) {
                    this.isPublic = !0, this.p = t, this.q = e, this.g = r, this.y = n, this.x = null
                }, this.setPublicHex = function(t, e, r, n) {
                    var i, s, a, o;
                    i = new C(t, 16), s = new C(e, 16), a = new C(r, 16), o = new C(n, 16), this.setPublic(i, s, a, o)
                }, this.signWithMessageHash = function(t) {
                    var e = this.p,
                        r = this.q,
                        n = this.g,
                        i = (this.y, this.x),
                        s = ct.crypto.Util.getRandomBigIntegerMinToMax(C.ONE.add(C.ONE), r.subtract(C.ONE)),
                        a = new C(t.substr(0, r.bitLength() / 4), 16),
                        o = n.modPow(s, e).mod(r),
                        u = s.modInverse(r).multiply(a.add(i.multiply(o))).mod(r);
                    return ct.asn1.ASN1Util.jsonToASN1HEX({
                        seq: [{
                            int: {
                                bigint: o
                            }
                        }, {
                            int: {
                                bigint: u
                            }
                        }]
                    })
                }, this.verifyWithMessageHash = function(t, e) {
                    var r = this.p,
                        n = this.q,
                        i = this.g,
                        s = this.y,
                        a = this.parseASN1Signature(e),
                        o = a[0],
                        u = a[1],
                        c = new C(t.substr(0, n.bitLength() / 4), 16);
                    if (C.ZERO.compareTo(o) > 0 || o.compareTo(n) > 0) throw "invalid DSA signature";
                    if (C.ZERO.compareTo(u) >= 0 || u.compareTo(n) > 0) throw "invalid DSA signature";
                    var h = u.modInverse(n),
                        l = c.multiply(h).mod(n),
                        f = o.multiply(h).mod(n);
                    return 0 == i.modPow(l, r).multiply(s.modPow(f, r)).mod(r).mod(n).compareTo(o)
                }, this.parseASN1Signature = function(t) {
                    try {
                        return [new n(e(t, 0, [0], "02"), 16), new n(e(t, 0, [1], "02"), 16)]
                    } catch (t) {
                        throw new Error("malformed ASN.1 DSA signature")
                    }
                }, this.readPKCS5PrvKeyHex = function(t) {
                    var n, i, s, a, o;
                    if (!1 === r(t)) throw new Error("not ASN.1 hex string");
                    try {
                        n = e(t, 0, [1], "02"), i = e(t, 0, [2], "02"), s = e(t, 0, [3], "02"), a = e(t, 0, [4], "02"), o = e(t, 0, [5], "02")
                    } catch (t) {
                        throw new Error("malformed PKCS#1/5 plain DSA private key")
                    }
                    this.setPrivateHex(n, i, s, a, o)
                }, this.readPKCS8PrvKeyHex = function(t) {
                    var n, i, s, a;
                    if (!1 === r(t)) throw new Error("not ASN.1 hex string");
                    try {
                        n = e(t, 0, [1, 1, 0], "02"), i = e(t, 0, [1, 1, 1], "02"), s = e(t, 0, [1, 1, 2], "02"), a = e(t, 0, [2, 0], "02")
                    } catch (t) {
                        throw new Error("malformed PKCS#8 plain DSA private key")
                    }
                    this.setPrivateHex(n, i, s, null, a)
                }, this.readPKCS8PubKeyHex = function(t) {
                    var n, i, s, a;
                    if (!1 === r(t)) throw new Error("not ASN.1 hex string");
                    try {
                        n = e(t, 0, [0, 1, 0], "02"), i = e(t, 0, [0, 1, 1], "02"), s = e(t, 0, [0, 1, 2], "02"), a = e(t, 0, [1, 0], "02")
                    } catch (t) {
                        throw new Error("malformed PKCS#8 DSA public key")
                    }
                    this.setPublicHex(n, i, s, a)
                }, this.readCertPubKeyHex = function(t, n) {
                    var i, s, a, o;
                    if (!1 === r(t)) throw new Error("not ASN.1 hex string");
                    try {
                        i = e(t, 0, [0, 5, 0, 1, 0], "02"), s = e(t, 0, [0, 5, 0, 1, 1], "02"), a = e(t, 0, [0, 5, 0, 1, 2], "02"), o = e(t, 0, [0, 5, 1, 0], "02")
                    } catch (t) {
                        throw new Error("malformed X.509 certificate DSA public key")
                    }
                    this.setPublicHex(i, s, a, o)
                }
            };
            var Ht = function() {
                var t = function(t, r, n) {
                        return e(y.AES, t, r, n)
                    },
                    e = function(t, e, r, n) {
                        var i = y.enc.Hex.parse(e),
                            s = y.enc.Hex.parse(r),
                            a = y.enc.Hex.parse(n),
                            o = {};
                        o.key = s, o.iv = a, o.ciphertext = i;
                        var u = t.decrypt(o, s, {
                            iv: a
                        });
                        return y.enc.Hex.stringify(u)
                    },
                    r = function(t, e, r) {
                        return n(y.AES, t, e, r)
                    },
                    n = function(t, e, r, n) {
                        var i = y.enc.Hex.parse(e),
                            s = y.enc.Hex.parse(r),
                            a = y.enc.Hex.parse(n),
                            o = t.encrypt(i, s, {
                                iv: a
                            }),
                            u = y.enc.Hex.parse(o.toString());
                        return y.enc.Base64.stringify(u)
                    },
                    i = {
                        "AES-256-CBC": {
                            proc: t,
                            eproc: r,
                            keylen: 32,
                            ivlen: 16
                        },
                        "AES-192-CBC": {
                            proc: t,
                            eproc: r,
                            keylen: 24,
                            ivlen: 16
                        },
                        "AES-128-CBC": {
                            proc: t,
                            eproc: r,
                            keylen: 16,
                            ivlen: 16
                        },
                        "DES-EDE3-CBC": {
                            proc: function(t, r, n) {
                                return e(y.TripleDES, t, r, n)
                            },
                            eproc: function(t, e, r) {
                                return n(y.TripleDES, t, e, r)
                            },
                            keylen: 24,
                            ivlen: 8
                        },
                        "DES-CBC": {
                            proc: function(t, r, n) {
                                return e(y.DES, t, r, n)
                            },
                            eproc: function(t, e, r) {
                                return n(y.DES, t, e, r)
                            },
                            keylen: 8,
                            ivlen: 8
                        }
                    },
                    s = function(t) {
                        var e = {},
                            r = t.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)", "m"));
                        r && (e.cipher = r[1], e.ivsalt = r[2]);
                        var n = t.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));
                        n && (e.type = n[1]);
                        var i = -1,
                            s = 0; - 1 != t.indexOf("\r\n\r\n") && (i = t.indexOf("\r\n\r\n"), s = 2), -1 != t.indexOf("\n\n") && (i = t.indexOf("\n\n"), s = 1);
                        var a = t.indexOf("-----END");
                        if (-1 != i && -1 != a) {
                            var o = t.substring(i + 2 * s, a - s);
                            o = o.replace(/\s+/g, ""), e.data = o
                        }
                        return e
                    },
                    a = function(t, e, r) {
                        for (var n = r.substring(0, 16), s = y.enc.Hex.parse(n), a = y.enc.Utf8.parse(e), o = i[t].keylen + i[t].ivlen, u = "", c = null;;) {
                            var h = y.algo.MD5.create();
                            if (null != c && h.update(c), h.update(a), h.update(s), c = h.finalize(), (u += y.enc.Hex.stringify(c)).length >= 2 * o) break
                        }
                        var l = {};
                        return l.keyhex = u.substr(0, 2 * i[t].keylen), l.ivhex = u.substr(2 * i[t].keylen, 2 * i[t].ivlen), l
                    },
                    o = function(t, e, r, n) {
                        var s = y.enc.Base64.parse(t),
                            a = y.enc.Hex.stringify(s);
                        return (0, i[e].proc)(a, r, n)
                    };
                return {
                    version: "1.0.0",
                    parsePKCS5PEM: function(t) {
                        return s(t)
                    },
                    getKeyAndUnusedIvByPasscodeAndIvsalt: function(t, e, r) {
                        return a(t, e, r)
                    },
                    decryptKeyB64: function(t, e, r, n) {
                        return o(t, e, r, n)
                    },
                    getDecryptedKeyHex: function(t, e) {
                        var r = s(t),
                            n = (r.type, r.cipher),
                            i = r.ivsalt,
                            u = r.data,
                            c = a(n, e, i).keyhex;
                        return o(u, n, c, i)
                    },
                    getEncryptedPKCS5PEMFromPrvKeyHex: function(t, e, r, n, s) {
                        var o = "";
                        if (void 0 !== n && null != n || (n = "AES-256-CBC"), void 0 === i[n]) throw "KEYUTIL unsupported algorithm: " + n;
                        void 0 !== s && null != s || (s = function(t) {
                            var e = y.lib.WordArray.random(t);
                            return y.enc.Hex.stringify(e)
                        }(i[n].ivlen).toUpperCase());
                        var u = function(t, e, r, n) {
                            return (0, i[e].eproc)(t, r, n)
                        }(e, n, a(n, r, s).keyhex, s);
                        o = "-----BEGIN " + t + " PRIVATE KEY-----\r\n";
                        return o += "Proc-Type: 4,ENCRYPTED\r\n", o += "DEK-Info: " + n + "," + s + "\r\n", o += "\r\n", o += u.replace(/(.{64})/g, "$1\r\n"), o += "\r\n-----END " + t + " PRIVATE KEY-----\r\n"
                    },
                    parseHexOfEncryptedPKCS8: function(t) {
                        var e = ft,
                            r = e.getChildIdx,
                            n = e.getV,
                            i = {},
                            s = r(t, 0);
                        if (2 != s.length) throw "malformed format: SEQUENCE(0).items != 2: " + s.length;
                        i.ciphertext = n(t, s[1]);
                        var a = r(t, s[0]);
                        if (2 != a.length) throw "malformed format: SEQUENCE(0.0).items != 2: " + a.length;
                        if ("2a864886f70d01050d" != n(t, a[0])) throw "this only supports pkcs5PBES2";
                        var o = r(t, a[1]);
                        if (2 != a.length) throw "malformed format: SEQUENCE(0.0.1).items != 2: " + o.length;
                        var u = r(t, o[1]);
                        if (2 != u.length) throw "malformed format: SEQUENCE(0.0.1.1).items != 2: " + u.length;
                        if ("2a864886f70d0307" != n(t, u[0])) throw "this only supports TripleDES";
                        i.encryptionSchemeAlg = "TripleDES", i.encryptionSchemeIV = n(t, u[1]);
                        var c = r(t, o[0]);
                        if (2 != c.length) throw "malformed format: SEQUENCE(0.0.1.0).items != 2: " + c.length;
                        if ("2a864886f70d01050c" != n(t, c[0])) throw "this only supports pkcs5PBKDF2";
                        var h = r(t, c[1]);
                        if (h.length < 2) throw "malformed format: SEQUENCE(0.0.1.0.1).items < 2: " + h.length;
                        i.pbkdf2Salt = n(t, h[0]);
                        var l = n(t, h[1]);
                        try {
                            i.pbkdf2Iter = parseInt(l, 16)
                        } catch (t) {
                            throw "malformed format pbkdf2Iter: " + l
                        }
                        return i
                    },
                    getPBKDF2KeyHexFromParam: function(t, e) {
                        var r = y.enc.Hex.parse(t.pbkdf2Salt),
                            n = t.pbkdf2Iter,
                            i = y.PBKDF2(e, r, {
                                keySize: 6,
                                iterations: n
                            });
                        return y.enc.Hex.stringify(i)
                    },
                    _getPlainPKCS8HexFromEncryptedPKCS8PEM: function(t, e) {
                        var r = Ft(t, "ENCRYPTED PRIVATE KEY"),
                            n = this.parseHexOfEncryptedPKCS8(r),
                            i = Ht.getPBKDF2KeyHexFromParam(n, e),
                            s = {};
                        s.ciphertext = y.enc.Hex.parse(n.ciphertext);
                        var a = y.enc.Hex.parse(i),
                            o = y.enc.Hex.parse(n.encryptionSchemeIV),
                            u = y.TripleDES.decrypt(s, a, {
                                iv: o
                            });
                        return y.enc.Hex.stringify(u)
                    },
                    getKeyFromEncryptedPKCS8PEM: function(t, e) {
                        var r = this._getPlainPKCS8HexFromEncryptedPKCS8PEM(t, e);
                        return this.getKeyFromPlainPrivatePKCS8Hex(r)
                    },
                    parsePlainPrivatePKCS8Hex: function(t) {
                        var e = ft,
                            r = e.getChildIdx,
                            n = e.getV,
                            i = {
                                algparam: null
                            };
                        if ("30" != t.substr(0, 2)) throw "malformed plain PKCS8 private key(code:001)";
                        var s = r(t, 0);
                        if (3 != s.length) throw "malformed plain PKCS8 private key(code:002)";
                        if ("30" != t.substr(s[1], 2)) throw "malformed PKCS8 private key(code:003)";
                        var a = r(t, s[1]);
                        if (2 != a.length) throw "malformed PKCS8 private key(code:004)";
                        if ("06" != t.substr(a[0], 2)) throw "malformed PKCS8 private key(code:005)";
                        if (i.algoid = n(t, a[0]), "06" == t.substr(a[1], 2) && (i.algparam = n(t, a[1])), "04" != t.substr(s[2], 2)) throw "malformed PKCS8 private key(code:006)";
                        return i.keyidx = e.getVidx(t, s[2]), i
                    },
                    getKeyFromPlainPrivatePKCS8PEM: function(t) {
                        var e = Ft(t, "PRIVATE KEY");
                        return this.getKeyFromPlainPrivatePKCS8Hex(e)
                    },
                    getKeyFromPlainPrivatePKCS8Hex: function(t) {
                        var e, r = this.parsePlainPrivatePKCS8Hex(t);
                        if ("2a864886f70d010101" == r.algoid) e = new nt;
                        else if ("2a8648ce380401" == r.algoid) e = new ct.crypto.DSA;
                        else {
                            if ("2a8648ce3d0201" != r.algoid) throw "unsupported private key algorithm";
                            e = new ct.crypto.ECDSA
                        }
                        return e.readPKCS8PrvKeyHex(t), e
                    },
                    _getKeyFromPublicPKCS8Hex: function(t) {
                        var e, r = ft.getVbyList(t, 0, [0, 0], "06");
                        if ("2a864886f70d010101" === r) e = new nt;
                        else if ("2a8648ce380401" === r) e = new ct.crypto.DSA;
                        else {
                            if ("2a8648ce3d0201" !== r) throw "unsupported PKCS#8 public key hex";
                            e = new ct.crypto.ECDSA
                        }
                        return e.readPKCS8PubKeyHex(t), e
                    },
                    parsePublicRawRSAKeyHex: function(t) {
                        var e = ft,
                            r = e.getChildIdx,
                            n = e.getV,
                            i = {};
                        if ("30" != t.substr(0, 2)) throw "malformed RSA key(code:001)";
                        var s = r(t, 0);
                        if (2 != s.length) throw "malformed RSA key(code:002)";
                        if ("02" != t.substr(s[0], 2)) throw "malformed RSA key(code:003)";
                        if (i.n = n(t, s[0]), "02" != t.substr(s[1], 2)) throw "malformed RSA key(code:004)";
                        return i.e = n(t, s[1]), i
                    },
                    parsePublicPKCS8Hex: function(t) {
                        var e = ft,
                            r = e.getChildIdx,
                            n = e.getV,
                            i = {
                                algparam: null
                            },
                            s = r(t, 0);
                        if (2 != s.length) throw "outer DERSequence shall have 2 elements: " + s.length;
                        var a = s[0];
                        if ("30" != t.substr(a, 2)) throw "malformed PKCS8 public key(code:001)";
                        var o = r(t, a);
                        if (2 != o.length) throw "malformed PKCS8 public key(code:002)";
                        if ("06" != t.substr(o[0], 2)) throw "malformed PKCS8 public key(code:003)";
                        if (i.algoid = n(t, o[0]), "06" == t.substr(o[1], 2) ? i.algparam = n(t, o[1]) : "30" == t.substr(o[1], 2) && (i.algparam = {}, i.algparam.p = e.getVbyList(t, o[1], [0], "02"), i.algparam.q = e.getVbyList(t, o[1], [1], "02"), i.algparam.g = e.getVbyList(t, o[1], [2], "02")), "03" != t.substr(s[1], 2)) throw "malformed PKCS8 public key(code:004)";
                        return i.key = n(t, s[1]).substr(2), i
                    }
                }
            }();
            Ht.getKey = function(t, e, r) {
                var n = (y = ft).getChildIdx,
                    i = (y.getV, y.getVbyList),
                    s = ct.crypto,
                    a = s.ECDSA,
                    o = s.DSA,
                    u = nt,
                    c = Ft,
                    h = Ht;
                if (void 0 !== u && t instanceof u) return t;
                if (void 0 !== a && t instanceof a) return t;
                if (void 0 !== o && t instanceof o) return t;
                if (void 0 !== t.curve && void 0 !== t.xy && void 0 === t.d) return new a({
                    pub: t.xy,
                    curve: t.curve
                });
                if (void 0 !== t.curve && void 0 !== t.d) return new a({
                    prv: t.d,
                    curve: t.curve
                });
                if (void 0 === t.kty && void 0 !== t.n && void 0 !== t.e && void 0 === t.d) return (B = new u).setPublic(t.n, t.e), B;
                if (void 0 === t.kty && void 0 !== t.n && void 0 !== t.e && void 0 !== t.d && void 0 !== t.p && void 0 !== t.q && void 0 !== t.dp && void 0 !== t.dq && void 0 !== t.co && void 0 === t.qi) return (B = new u).setPrivateEx(t.n, t.e, t.d, t.p, t.q, t.dp, t.dq, t.co), B;
                if (void 0 === t.kty && void 0 !== t.n && void 0 !== t.e && void 0 !== t.d && void 0 === t.p) return (B = new u).setPrivate(t.n, t.e, t.d), B;
                if (void 0 !== t.p && void 0 !== t.q && void 0 !== t.g && void 0 !== t.y && void 0 === t.x) return (B = new o).setPublic(t.p, t.q, t.g, t.y), B;
                if (void 0 !== t.p && void 0 !== t.q && void 0 !== t.g && void 0 !== t.y && void 0 !== t.x) return (B = new o).setPrivate(t.p, t.q, t.g, t.y, t.x), B;
                if ("RSA" === t.kty && void 0 !== t.n && void 0 !== t.e && void 0 === t.d) return (B = new u).setPublic(St(t.n), St(t.e)), B;
                if ("RSA" === t.kty && void 0 !== t.n && void 0 !== t.e && void 0 !== t.d && void 0 !== t.p && void 0 !== t.q && void 0 !== t.dp && void 0 !== t.dq && void 0 !== t.qi) return (B = new u).setPrivateEx(St(t.n), St(t.e), St(t.d), St(t.p), St(t.q), St(t.dp), St(t.dq), St(t.qi)), B;
                if ("RSA" === t.kty && void 0 !== t.n && void 0 !== t.e && void 0 !== t.d) return (B = new u).setPrivate(St(t.n), St(t.e), St(t.d)), B;
                if ("EC" === t.kty && void 0 !== t.crv && void 0 !== t.x && void 0 !== t.y && void 0 === t.d) {
                    var l = (I = new a({
                            curve: t.crv
                        })).ecparams.keylen / 4,
                        f = "04" + ("0000000000" + St(t.x)).slice(-l) + ("0000000000" + St(t.y)).slice(-l);
                    return I.setPublicKeyHex(f), I
                }
                if ("EC" === t.kty && void 0 !== t.crv && void 0 !== t.x && void 0 !== t.y && void 0 !== t.d) {
                    l = (I = new a({
                        curve: t.crv
                    })).ecparams.keylen / 4, f = "04" + ("0000000000" + St(t.x)).slice(-l) + ("0000000000" + St(t.y)).slice(-l);
                    var p = ("0000000000" + St(t.d)).slice(-l);
                    return I.setPublicKeyHex(f), I.setPrivateKeyHex(p), I
                }
                if ("pkcs5prv" === r) {
                    var d, g = t,
                        y = ft;
                    if (9 === (d = n(g, 0)).length)(B = new u).readPKCS5PrvKeyHex(g);
                    else if (6 === d.length)(B = new o).readPKCS5PrvKeyHex(g);
                    else {
                        if (!(d.length > 2 && "04" === g.substr(d[1], 2))) throw "unsupported PKCS#1/5 hexadecimal key";
                        (B = new a).readPKCS5PrvKeyHex(g)
                    }
                    return B
                }
                if ("pkcs8prv" === r) return B = h.getKeyFromPlainPrivatePKCS8Hex(t);
                if ("pkcs8pub" === r) return h._getKeyFromPublicPKCS8Hex(t);
                if ("x509pub" === r) return zt.getPublicKeyFromCertHex(t);
                if (-1 != t.indexOf("-END CERTIFICATE-", 0) || -1 != t.indexOf("-END X509 CERTIFICATE-", 0) || -1 != t.indexOf("-END TRUSTED CERTIFICATE-", 0)) return zt.getPublicKeyFromCertPEM(t);
                if (-1 != t.indexOf("-END PUBLIC KEY-")) {
                    var v = Ft(t, "PUBLIC KEY");
                    return h._getKeyFromPublicPKCS8Hex(v)
                }
                if (-1 != t.indexOf("-END RSA PRIVATE KEY-") && -1 == t.indexOf("4,ENCRYPTED")) {
                    var m = c(t, "RSA PRIVATE KEY");
                    return h.getKey(m, null, "pkcs5prv")
                }
                if (-1 != t.indexOf("-END DSA PRIVATE KEY-") && -1 == t.indexOf("4,ENCRYPTED")) {
                    var E = i(D = c(t, "DSA PRIVATE KEY"), 0, [1], "02"),
                        S = i(D, 0, [2], "02"),
                        b = i(D, 0, [3], "02"),
                        A = i(D, 0, [4], "02"),
                        w = i(D, 0, [5], "02");
                    return (B = new o).setPrivate(new C(E, 16), new C(S, 16), new C(b, 16), new C(A, 16), new C(w, 16)), B
                }
                if (-1 != t.indexOf("-END EC PRIVATE KEY-") && -1 == t.indexOf("4,ENCRYPTED")) {
                    m = c(t, "EC PRIVATE KEY");
                    return h.getKey(m, null, "pkcs5prv")
                }
                if (-1 != t.indexOf("-END PRIVATE KEY-")) return h.getKeyFromPlainPrivatePKCS8PEM(t);
                if (-1 != t.indexOf("-END RSA PRIVATE KEY-") && -1 != t.indexOf("4,ENCRYPTED")) {
                    var T = h.getDecryptedKeyHex(t, e),
                        x = new nt;
                    return x.readPKCS5PrvKeyHex(T), x
                }
                if (-1 != t.indexOf("-END EC PRIVATE KEY-") && -1 != t.indexOf("4,ENCRYPTED")) {
                    var I, B = i(D = h.getDecryptedKeyHex(t, e), 0, [1], "04"),
                        F = i(D, 0, [2, 0], "06"),
                        R = i(D, 0, [3, 0], "03").substr(2);
                    if (void 0 === ct.crypto.OID.oidhex2name[F]) throw "undefined OID(hex) in KJUR.crypto.OID: " + F;
                    return (I = new a({
                        curve: ct.crypto.OID.oidhex2name[F]
                    })).setPublicKeyHex(R), I.setPrivateKeyHex(B), I.isPublic = !1, I
                }
                if (-1 != t.indexOf("-END DSA PRIVATE KEY-") && -1 != t.indexOf("4,ENCRYPTED")) {
                    var D;
                    E = i(D = h.getDecryptedKeyHex(t, e), 0, [1], "02"), S = i(D, 0, [2], "02"), b = i(D, 0, [3], "02"), A = i(D, 0, [4], "02"), w = i(D, 0, [5], "02");
                    return (B = new o).setPrivate(new C(E, 16), new C(S, 16), new C(b, 16), new C(A, 16), new C(w, 16)), B
                }
                if (-1 != t.indexOf("-END ENCRYPTED PRIVATE KEY-")) return h.getKeyFromEncryptedPKCS8PEM(t, e);
                throw new Error("not supported argument")
            }, Ht.generateKeypair = function(t, e) {
                if ("RSA" == t) {
                    var r = e;
                    (a = new nt).generate(r, "10001"), a.isPrivate = !0, a.isPublic = !0;
                    var n = new nt,
                        i = a.n.toString(16),
                        s = a.e.toString(16);
                    return n.setPublic(i, s), n.isPrivate = !1, n.isPublic = !0, (o = {}).prvKeyObj = a, o.pubKeyObj = n, o
                }
                if ("EC" == t) {
                    var a, o, u = e,
                        c = new ct.crypto.ECDSA({
                            curve: u
                        }).generateKeyPairHex();
                    return (a = new ct.crypto.ECDSA({
                        curve: u
                    })).setPublicKeyHex(c.ecpubhex), a.setPrivateKeyHex(c.ecprvhex), a.isPrivate = !0, a.isPublic = !1, (n = new ct.crypto.ECDSA({
                        curve: u
                    })).setPublicKeyHex(c.ecpubhex), n.isPrivate = !1, n.isPublic = !0, (o = {}).prvKeyObj = a, o.pubKeyObj = n, o
                }
                throw "unknown algorithm: " + t
            }, Ht.getPEM = function(t, e, r, n, i, s) {
                var a = ct,
                    o = a.asn1,
                    u = o.DERObjectIdentifier,
                    c = o.DERInteger,
                    h = o.ASN1Util.newObject,
                    l = o.x509.SubjectPublicKeyInfo,
                    f = a.crypto,
                    p = f.DSA,
                    d = f.ECDSA,
                    g = nt;

                function v(t) {
                    return h({
                        seq: [{
                            int: 0
                        }, {
                            int: {
                                bigint: t.n
                            }
                        }, {
                            int: t.e
                        }, {
                            int: {
                                bigint: t.d
                            }
                        }, {
                            int: {
                                bigint: t.p
                            }
                        }, {
                            int: {
                                bigint: t.q
                            }
                        }, {
                            int: {
                                bigint: t.dmp1
                            }
                        }, {
                            int: {
                                bigint: t.dmq1
                            }
                        }, {
                            int: {
                                bigint: t.coeff
                            }
                        }]
                    })
                }

                function m(t) {
                    return h({
                        seq: [{
                            int: 1
                        }, {
                            octstr: {
                                hex: t.prvKeyHex
                            }
                        }, {
                            tag: ["a0", !0, {
                                oid: {
                                    name: t.curveName
                                }
                            }]
                        }, {
                            tag: ["a1", !0, {
                                bitstr: {
                                    hex: "00" + t.pubKeyHex
                                }
                            }]
                        }]
                    })
                }

                function E(t) {
                    return h({
                        seq: [{
                            int: 0
                        }, {
                            int: {
                                bigint: t.p
                            }
                        }, {
                            int: {
                                bigint: t.q
                            }
                        }, {
                            int: {
                                bigint: t.g
                            }
                        }, {
                            int: {
                                bigint: t.y
                            }
                        }, {
                            int: {
                                bigint: t.x
                            }
                        }]
                    })
                }
                if ((void 0 !== g && t instanceof g || void 0 !== p && t instanceof p || void 0 !== d && t instanceof d) && 1 == t.isPublic && (void 0 === e || "PKCS8PUB" == e)) return Bt(A = new l(t).getEncodedHex(), "PUBLIC KEY");
                if ("PKCS1PRV" == e && void 0 !== g && t instanceof g && (void 0 === r || null == r) && 1 == t.isPrivate) return Bt(A = v(t).getEncodedHex(), "RSA PRIVATE KEY");
                if ("PKCS1PRV" == e && void 0 !== d && t instanceof d && (void 0 === r || null == r) && 1 == t.isPrivate) {
                    var S = new u({
                            name: t.curveName
                        }).getEncodedHex(),
                        b = m(t).getEncodedHex(),
                        C = "";
                    return C += Bt(S, "EC PARAMETERS"), C += Bt(b, "EC PRIVATE KEY")
                }
                if ("PKCS1PRV" == e && void 0 !== p && t instanceof p && (void 0 === r || null == r) && 1 == t.isPrivate) return Bt(A = E(t).getEncodedHex(), "DSA PRIVATE KEY");
                if ("PKCS5PRV" == e && void 0 !== g && t instanceof g && void 0 !== r && null != r && 1 == t.isPrivate) {
                    var A = v(t).getEncodedHex();
                    return void 0 === n && (n = "DES-EDE3-CBC"), this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA", A, r, n, s)
                }
                if ("PKCS5PRV" == e && void 0 !== d && t instanceof d && void 0 !== r && null != r && 1 == t.isPrivate) {
                    A = m(t).getEncodedHex();
                    return void 0 === n && (n = "DES-EDE3-CBC"), this.getEncryptedPKCS5PEMFromPrvKeyHex("EC", A, r, n, s)
                }
                if ("PKCS5PRV" == e && void 0 !== p && t instanceof p && void 0 !== r && null != r && 1 == t.isPrivate) {
                    A = E(t).getEncodedHex();
                    return void 0 === n && (n = "DES-EDE3-CBC"), this.getEncryptedPKCS5PEMFromPrvKeyHex("DSA", A, r, n, s)
                }
                var w = function(t, e) {
                        var r = T(t, e);
                        return new h({
                            seq: [{
                                seq: [{
                                    oid: {
                                        name: "pkcs5PBES2"
                                    }
                                }, {
                                    seq: [{
                                        seq: [{
                                            oid: {
                                                name: "pkcs5PBKDF2"
                                            }
                                        }, {
                                            seq: [{
                                                octstr: {
                                                    hex: r.pbkdf2Salt
                                                }
                                            }, {
                                                int: r.pbkdf2Iter
                                            }]
                                        }]
                                    }, {
                                        seq: [{
                                            oid: {
                                                name: "des-EDE3-CBC"
                                            }
                                        }, {
                                            octstr: {
                                                hex: r.encryptionSchemeIV
                                            }
                                        }]
                                    }]
                                }]
                            }, {
                                octstr: {
                                    hex: r.ciphertext
                                }
                            }]
                        }).getEncodedHex()
                    },
                    T = function(t, e) {
                        var r = y.lib.WordArray.random(8),
                            n = y.lib.WordArray.random(8),
                            i = y.PBKDF2(e, r, {
                                keySize: 6,
                                iterations: 100
                            }),
                            s = y.enc.Hex.parse(t),
                            a = y.TripleDES.encrypt(s, i, {
                                iv: n
                            }) + "",
                            o = {};
                        return o.ciphertext = a, o.pbkdf2Salt = y.enc.Hex.stringify(r), o.pbkdf2Iter = 100, o.encryptionSchemeAlg = "DES-EDE3-CBC", o.encryptionSchemeIV = y.enc.Hex.stringify(n), o
                    };
                if ("PKCS8PRV" == e && null != g && t instanceof g && 1 == t.isPrivate) {
                    var x = v(t).getEncodedHex();
                    A = h({
                        seq: [{
                            int: 0
                        }, {
                            seq: [{
                                oid: {
                                    name: "rsaEncryption"
                                }
                            }, {
                                null: !0
                            }]
                        }, {
                            octstr: {
                                hex: x
                            }
                        }]
                    }).getEncodedHex();
                    return void 0 === r || null == r ? Bt(A, "PRIVATE KEY") : Bt(b = w(A, r), "ENCRYPTED PRIVATE KEY")
                }
                if ("PKCS8PRV" == e && void 0 !== d && t instanceof d && 1 == t.isPrivate) {
                    x = new h({
                        seq: [{
                            int: 1
                        }, {
                            octstr: {
                                hex: t.prvKeyHex
                            }
                        }, {
                            tag: ["a1", !0, {
                                bitstr: {
                                    hex: "00" + t.pubKeyHex
                                }
                            }]
                        }]
                    }).getEncodedHex(), A = h({
                        seq: [{
                            int: 0
                        }, {
                            seq: [{
                                oid: {
                                    name: "ecPublicKey"
                                }
                            }, {
                                oid: {
                                    name: t.curveName
                                }
                            }]
                        }, {
                            octstr: {
                                hex: x
                            }
                        }]
                    }).getEncodedHex();
                    return void 0 === r || null == r ? Bt(A, "PRIVATE KEY") : Bt(b = w(A, r), "ENCRYPTED PRIVATE KEY")
                }
                if ("PKCS8PRV" == e && void 0 !== p && t instanceof p && 1 == t.isPrivate) {
                    x = new c({
                        bigint: t.x
                    }).getEncodedHex(), A = h({
                        seq: [{
                            int: 0
                        }, {
                            seq: [{
                                oid: {
                                    name: "dsa"
                                }
                            }, {
                                seq: [{
                                    int: {
                                        bigint: t.p
                                    }
                                }, {
                                    int: {
                                        bigint: t.q
                                    }
                                }, {
                                    int: {
                                        bigint: t.g
                                    }
                                }]
                            }]
                        }, {
                            octstr: {
                                hex: x
                            }
                        }]
                    }).getEncodedHex();
                    return void 0 === r || null == r ? Bt(A, "PRIVATE KEY") : Bt(b = w(A, r), "ENCRYPTED PRIVATE KEY")
                }
                throw new Error("unsupported object nor format")
            }, Ht.getKeyFromCSRPEM = function(t) {
                var e = Ft(t, "CERTIFICATE REQUEST");
                return Ht.getKeyFromCSRHex(e)
            }, Ht.getKeyFromCSRHex = function(t) {
                var e = Ht.parseCSRHex(t);
                return Ht.getKey(e.p8pubkeyhex, null, "pkcs8pub")
            }, Ht.parseCSRHex = function(t) {
                var e = ft,
                    r = e.getChildIdx,
                    n = e.getTLV,
                    i = {},
                    s = t;
                if ("30" != s.substr(0, 2)) throw "malformed CSR(code:001)";
                var a = r(s, 0);
                if (a.length < 1) throw "malformed CSR(code:002)";
                if ("30" != s.substr(a[0], 2)) throw "malformed CSR(code:003)";
                var o = r(s, a[0]);
                if (o.length < 3) throw "malformed CSR(code:004)";
                return i.p8pubkeyhex = n(s, o[2]), i
            }, Ht.getKeyID = function(t) {
                var e = Ht,
                    r = ft;
                "string" == typeof t && -1 != t.indexOf("BEGIN ") && (t = e.getKey(t));
                var n = Ft(e.getPEM(t)),
                    i = r.getIdxbyList(n, 0, [1]),
                    s = r.getV(n, i).substring(2);
                return ct.crypto.Util.hashHex(s, "sha1")
            }, Ht.getJWKFromKey = function(t) {
                var e = {};
                if (t instanceof nt && t.isPrivate) return e.kty = "RSA", e.n = Et(t.n.toString(16)), e.e = Et(t.e.toString(16)), e.d = Et(t.d.toString(16)), e.p = Et(t.p.toString(16)), e.q = Et(t.q.toString(16)), e.dp = Et(t.dmp1.toString(16)), e.dq = Et(t.dmq1.toString(16)), e.qi = Et(t.coeff.toString(16)), e;
                if (t instanceof nt && t.isPublic) return e.kty = "RSA", e.n = Et(t.n.toString(16)), e.e = Et(t.e.toString(16)), e;
                if (t instanceof ct.crypto.ECDSA && t.isPrivate) {
                    if ("P-256" !== (n = t.getShortNISTPCurveName()) && "P-384" !== n) throw "unsupported curve name for JWT: " + n;
                    var r = t.getPublicKeyXYHex();
                    return e.kty = "EC", e.crv = n, e.x = Et(r.x), e.y = Et(r.y), e.d = Et(t.prvKeyHex), e
                }
                if (t instanceof ct.crypto.ECDSA && t.isPublic) {
                    var n;
                    if ("P-256" !== (n = t.getShortNISTPCurveName()) && "P-384" !== n) throw "unsupported curve name for JWT: " + n;
                    r = t.getPublicKeyXYHex();
                    return e.kty = "EC", e.crv = n, e.x = Et(r.x), e.y = Et(r.y), e
                }
                throw "not supported key object"
            }, nt.getPosArrayOfChildrenFromHex = function(t) {
                return ft.getChildIdx(t, 0)
            }, nt.getHexValueArrayOfChildrenFromHex = function(t) {
                var e, r = ft.getV,
                    n = r(t, (e = nt.getPosArrayOfChildrenFromHex(t))[0]),
                    i = r(t, e[1]),
                    s = r(t, e[2]),
                    a = r(t, e[3]),
                    o = r(t, e[4]),
                    u = r(t, e[5]),
                    c = r(t, e[6]),
                    h = r(t, e[7]),
                    l = r(t, e[8]);
                return (e = new Array).push(n, i, s, a, o, u, c, h, l), e
            }, nt.prototype.readPrivateKeyFromPEMString = function(t) {
                var e = Ft(t),
                    r = nt.getHexValueArrayOfChildrenFromHex(e);
                this.setPrivateEx(r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8])
            }, nt.prototype.readPKCS5PrvKeyHex = function(t) {
                var e = nt.getHexValueArrayOfChildrenFromHex(t);
                this.setPrivateEx(e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8])
            }, nt.prototype.readPKCS8PrvKeyHex = function(t) {
                var e, r, n, i, s, a, o, u, c = ft,
                    h = c.getVbyListEx;
                if (!1 === c.isASN1HEX(t)) throw new Error("not ASN.1 hex string");
                try {
                    e = h(t, 0, [2, 0, 1], "02"), r = h(t, 0, [2, 0, 2], "02"), n = h(t, 0, [2, 0, 3], "02"), i = h(t, 0, [2, 0, 4], "02"), s = h(t, 0, [2, 0, 5], "02"), a = h(t, 0, [2, 0, 6], "02"), o = h(t, 0, [2, 0, 7], "02"), u = h(t, 0, [2, 0, 8], "02")
                } catch (t) {
                    throw new Error("malformed PKCS#8 plain RSA private key")
                }
                this.setPrivateEx(e, r, n, i, s, a, o, u)
            }, nt.prototype.readPKCS5PubKeyHex = function(t) {
                var e = ft,
                    r = e.getV;
                if (!1 === e.isASN1HEX(t)) throw new Error("keyHex is not ASN.1 hex string");
                var n = e.getChildIdx(t, 0);
                if (2 !== n.length || "02" !== t.substr(n[0], 2) || "02" !== t.substr(n[1], 2)) throw new Error("wrong hex for PKCS#5 public key");
                var i = r(t, n[0]),
                    s = r(t, n[1]);
                this.setPublic(i, s)
            }, nt.prototype.readPKCS8PubKeyHex = function(t) {
                var e = ft;
                if (!1 === e.isASN1HEX(t)) throw new Error("not ASN.1 hex string");
                if ("06092a864886f70d010101" !== e.getTLVbyListEx(t, 0, [0, 0])) throw new Error("not PKCS8 RSA public key");
                var r = e.getTLVbyListEx(t, 0, [1, 0]);
                this.readPKCS5PubKeyHex(r)
            }, nt.prototype.readCertPubKeyHex = function(t, e) {
                var r, n;
                (r = new zt).readCertHex(t), n = r.getPublicKeyHex(), this.readPKCS8PubKeyHex(n)
            };
            var jt = new RegExp("[^0-9a-f]", "gi");

            function Mt(t, e) {
                for (var r = "", n = e / 4 - t.length, i = 0; i < n; i++) r += "0";
                return r + t
            }

            function Kt(t, e, r) {
                for (var n = "", i = 0; n.length < e;) n += At(r(wt(t + String.fromCharCode.apply(String, [(4278190080 & i) >> 24, (16711680 & i) >> 16, (65280 & i) >> 8, 255 & i])))), i += 1;
                return n
            }

            function qt(t) {
                for (var e in ct.crypto.Util.DIGESTINFOHEAD) {
                    var r = ct.crypto.Util.DIGESTINFOHEAD[e],
                        n = r.length;
                    if (t.substring(0, n) == r) return [e, t.substring(n)]
                }
                return []
            }

            function zt() {
                var t, e = ft,
                    r = e.getChildIdx,
                    n = e.getV,
                    i = e.getTLV,
                    s = e.getVbyList,
                    a = e.getVbyListEx,
                    o = e.getTLVbyList,
                    u = e.getTLVbyListEx,
                    c = e.getIdxbyList,
                    h = e.getIdxbyListEx,
                    l = e.getVidx,
                    f = e.oidname,
                    p = e.hextooidstr,
                    d = zt,
                    g = Ft;
                try {
                    t = ct.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV
                } catch (t) {}
                this.HEX2STAG = {
                    "0c": "utf8",
                    13: "prn",
                    16: "ia5",
                    "1a": "vis",
                    "1e": "bmp"
                }, this.hex = null, this.version = 0, this.foffset = 0, this.aExtInfo = null, this.getVersion = function() {
                    return null === this.hex || 0 !== this.version ? this.version : "a003020102" !== o(this.hex, 0, [0, 0]) ? (this.version = 1, this.foffset = -1, 1) : (this.version = 3, 3)
                }, this.getSerialNumberHex = function() {
                    return a(this.hex, 0, [0, 0], "02")
                }, this.getSignatureAlgorithmField = function() {
                    var t = u(this.hex, 0, [0, 1]);
                    return this.getAlgorithmIdentifierName(t)
                }, this.getAlgorithmIdentifierName = function(e) {
                    for (var r in t)
                        if (e === t[r]) return r;
                    return f(a(e, 0, [0], "06"))
                }, this.getIssuer = function() {
                    var t = {};
                    return t.array = this.getX500Name(this.getIssuerHex()), t.str = this.getIssuerString(), t
                }, this.getIssuerHex = function() {
                    return o(this.hex, 0, [0, 3 + this.foffset], "30")
                }, this.getIssuerString = function() {
                    return d.hex2dn(this.getIssuerHex())
                }, this.getSubject = function() {
                    var t = {};
                    return t.array = this.getX500Name(this.getSubjectHex()), t.str = this.getSubjectString(), t
                }, this.getSubjectHex = function() {
                    return o(this.hex, 0, [0, 5 + this.foffset], "30")
                }, this.getSubjectString = function() {
                    return d.hex2dn(this.getSubjectHex())
                }, this.getNotBefore = function() {
                    var t = s(this.hex, 0, [0, 4 + this.foffset, 0]);
                    return t = t.replace(/(..)/g, "%$1"), t = decodeURIComponent(t)
                }, this.getNotAfter = function() {
                    var t = s(this.hex, 0, [0, 4 + this.foffset, 1]);
                    return t = t.replace(/(..)/g, "%$1"), t = decodeURIComponent(t)
                }, this.getPublicKeyHex = function() {
                    return e.getTLVbyList(this.hex, 0, [0, 6 + this.foffset], "30")
                }, this.getPublicKeyIdx = function() {
                    return c(this.hex, 0, [0, 6 + this.foffset], "30")
                }, this.getPublicKeyContentIdx = function() {
                    var t = this.getPublicKeyIdx();
                    return c(this.hex, t, [1, 0], "30")
                }, this.getPublicKey = function() {
                    return Ht.getKey(this.getPublicKeyHex(), null, "pkcs8pub")
                }, this.getSignatureAlgorithmName = function() {
                    var t = o(this.hex, 0, [1], "30");
                    return this.getAlgorithmIdentifierName(t)
                }, this.getSignatureValueHex = function() {
                    return s(this.hex, 0, [2], "03", !0)
                }, this.verifySignature = function(t) {
                    var e = this.getSignatureAlgorithmField(),
                        r = this.getSignatureValueHex(),
                        n = o(this.hex, 0, [0], "30"),
                        i = new ct.crypto.Signature({
                            alg: e
                        });
                    return i.init(t), i.updateHex(n), i.verify(r)
                }, this.parseExt = function(t) {
                    var i, a, o;
                    if (void 0 === t) {
                        if (o = this.hex, 3 !== this.version) return -1;
                        i = c(o, 0, [0, 7, 0], "30"), a = r(o, i)
                    } else {
                        o = Ft(t);
                        var u = c(o, 0, [0, 3, 0, 0], "06");
                        if ("2a864886f70d01090e" != n(o, u)) return void(this.aExtInfo = new Array);
                        i = c(o, 0, [0, 3, 0, 1, 0], "30"), a = r(o, i), this.hex = o
                    }
                    this.aExtInfo = new Array;
                    for (var h = 0; h < a.length; h++) {
                        var f = {
                                critical: !1
                            },
                            p = 0;
                        3 === r(o, a[h]).length && (f.critical = !0, p = 1), f.oid = e.hextooidstr(s(o, a[h], [0], "06"));
                        var d = c(o, a[h], [1 + p]);
                        f.vidx = l(o, d), this.aExtInfo.push(f)
                    }
                }, this.getExtInfo = function(t) {
                    var e = this.aExtInfo,
                        r = t;
                    if (t.match(/^[0-9.]+$/) || (r = ct.asn1.x509.OID.name2oid(t)), "" !== r)
                        for (var n = 0; n < e.length; n++)
                            if (e[n].oid === r) return e[n]
                }, this.getExtBasicConstraints = function(t, e) {
                    if (void 0 === t && void 0 === e) {
                        var r = this.getExtInfo("basicConstraints");
                        if (void 0 === r) return;
                        t = i(this.hex, r.vidx), e = r.critical
                    }
                    var s = {
                        extname: "basicConstraints"
                    };
                    if (e && (s.critical = !0), "3000" === t) return s;
                    if ("30030101ff" === t) return s.cA = !0, s;
                    if ("30060101ff02" === t.substr(0, 12)) {
                        var a = n(t, 10),
                            o = parseInt(a, 16);
                        return s.cA = !0, s.pathLen = o, s
                    }
                    throw new Error("hExtV parse error: " + t)
                }, this.getExtKeyUsage = function(t, e) {
                    if (void 0 === t && void 0 === e) {
                        var r = this.getExtInfo("keyUsage");
                        if (void 0 === r) return;
                        t = i(this.hex, r.vidx), e = r.critical
                    }
                    var n = {
                        extname: "keyUsage"
                    };
                    return e && (n.critical = !0), n.names = this.getExtKeyUsageString(t).split(","), n
                }, this.getExtKeyUsageBin = function(t) {
                    if (void 0 === t) {
                        var e = this.getExtInfo("keyUsage");
                        if (void 0 === e) return "";
                        t = i(this.hex, e.vidx)
                    }
                    if (8 != t.length && 10 != t.length) throw new Error("malformed key usage value: " + t);
                    var r = "000000000000000" + parseInt(t.substr(6), 16).toString(2);
                    return 8 == t.length && (r = r.slice(-8)), 10 == t.length && (r = r.slice(-16)), "" == (r = r.replace(/0+$/, "")) && (r = "0"), r
                }, this.getExtKeyUsageString = function(t) {
                    for (var e = this.getExtKeyUsageBin(t), r = new Array, n = 0; n < e.length; n++) "1" == e.substr(n, 1) && r.push(zt.KEYUSAGE_NAME[n]);
                    return r.join(",")
                }, this.getExtSubjectKeyIdentifier = function(t, e) {
                    if (void 0 === t && void 0 === e) {
                        var r = this.getExtInfo("subjectKeyIdentifier");
                        if (void 0 === r) return;
                        t = i(this.hex, r.vidx), e = r.critical
                    }
                    var s = {
                        extname: "subjectKeyIdentifier"
                    };
                    e && (s.critical = !0);
                    var a = n(t, 0);
                    return s.kid = {
                        hex: a
                    }, s
                }, this.getExtAuthorityKeyIdentifier = function(t, e) {
                    if (void 0 === t && void 0 === e) {
                        var s = this.getExtInfo("authorityKeyIdentifier");
                        if (void 0 === s) return;
                        t = i(this.hex, s.vidx), e = s.critical
                    }
                    var a = {
                        extname: "authorityKeyIdentifier"
                    };
                    e && (a.critical = !0);
                    for (var o = r(t, 0), u = 0; u < o.length; u++) {
                        var c = t.substr(o[u], 2);
                        if ("80" === c && (a.kid = {
                                hex: n(t, o[u])
                            }), "a1" === c) {
                            var h = i(t, o[u]),
                                l = this.getGeneralNames(h);
                            a.issuer = l[0].dn
                        }
                        "82" === c && (a.sn = {
                            hex: n(t, o[u])
                        })
                    }
                    return a
                }, this.getExtExtKeyUsage = function(t, e) {
                    if (void 0 === t && void 0 === e) {
                        var s = this.getExtInfo("extKeyUsage");
                        if (void 0 === s) return;
                        t = i(this.hex, s.vidx), e = s.critical
                    }
                    var a = {
                        extname: "extKeyUsage",
                        array: []
                    };
                    e && (a.critical = !0);
                    for (var o = r(t, 0), u = 0; u < o.length; u++) a.array.push(f(n(t, o[u])));
                    return a
                }, this.getExtExtKeyUsageName = function() {
                    var t = this.getExtInfo("extKeyUsage");
                    if (void 0 === t) return t;
                    var e = new Array,
                        s = i(this.hex, t.vidx);
                    if ("" === s) return e;
                    for (var a = r(s, 0), o = 0; o < a.length; o++) e.push(f(n(s, a[o])));
                    return e
                }, this.getExtSubjectAltName = function(t, e) {
                    if (void 0 === t && void 0 === e) {
                        var r = this.getExtInfo("subjectAltName");
                        if (void 0 === r) return;
                        t = i(this.hex, r.vidx), e = r.critical
                    }
                    var n = {
                        extname: "subjectAltName",
                        array: []
                    };
                    return e && (n.critical = !0), n.array = this.getGeneralNames(t), n
                }, this.getExtIssuerAltName = function(t, e) {
                    if (void 0 === t && void 0 === e) {
                        var r = this.getExtInfo("issuerAltName");
                        if (void 0 === r) return;
                        t = i(this.hex, r.vidx), e = r.critical
                    }
                    var n = {
                        extname: "issuerAltName",
                        array: []
                    };
                    return e && (n.critical = !0), n.array = this.getGeneralNames(t), n
                }, this.getGeneralNames = function(t) {
                    for (var e = r(t, 0), n = [], s = 0; s < e.length; s++) {
                        var a = this.getGeneralName(i(t, e[s]));
                        void 0 !== a && n.push(a)
                    }
                    return n
                }, this.getGeneralName = function(t) {
                    var e = t.substr(0, 2),
                        r = n(t, 0),
                        i = At(r);
                    return "81" == e ? {
                        rfc822: i
                    } : "82" == e ? {
                        dns: i
                    } : "a4" == e ? {
                        dn: {
                            hex: r
                        }
                    } : "86" == e ? {
                        uri: i
                    } : "87" == e ? {
                        ip: Lt(r)
                    } : void 0
                }, this.getExtSubjectAltName2 = function() {
                    var t, e, s, a = this.getExtInfo("subjectAltName");
                    if (void 0 === a) return a;
                    for (var o = new Array, u = i(this.hex, a.vidx), c = r(u, 0), h = 0; h < c.length; h++) s = u.substr(c[h], 2), t = n(u, c[h]), "81" === s && (e = Ct(t), o.push(["MAIL", e])), "82" === s && (e = Ct(t), o.push(["DNS", e])), "84" === s && (e = zt.hex2dn(t, 0), o.push(["DN", e])), "86" === s && (e = Ct(t), o.push(["URI", e])), "87" === s && (e = Lt(t), o.push(["IP", e]));
                    return o
                }, this.getExtCRLDistributionPoints = function(t, e) {
                    if (void 0 === t && void 0 === e) {
                        var n = this.getExtInfo("cRLDistributionPoints");
                        if (void 0 === n) return;
                        t = i(this.hex, n.vidx), e = n.critical
                    }
                    var s = {
                        extname: "cRLDistributionPoints",
                        array: []
                    };
                    e && (s.critical = !0);
                    for (var a = r(t, 0), o = 0; o < a.length; o++) {
                        var u = i(t, a[o]);
                        s.array.push(this.getDistributionPoint(u))
                    }
                    return s
                }, this.getDistributionPoint = function(t) {
                    for (var e = {}, n = r(t, 0), s = 0; s < n.length; s++) {
                        var a = t.substr(n[s], 2),
                            o = i(t, n[s]);
                        "a0" == a && (e.dpname = this.getDistributionPointName(o))
                    }
                    return e
                }, this.getDistributionPointName = function(t) {
                    for (var e = {}, n = r(t, 0), s = 0; s < n.length; s++) {
                        var a = t.substr(n[s], 2),
                            o = i(t, n[s]);
                        "a0" == a && (e.full = this.getGeneralNames(o))
                    }
                    return e
                }, this.getExtCRLDistributionPointsURI = function() {
                    var t = this.getExtInfo("cRLDistributionPoints");
                    if (void 0 === t) return t;
                    for (var e = new Array, n = r(this.hex, t.vidx), i = 0; i < n.length; i++) try {
                        var a = Ct(s(this.hex, n[i], [0, 0, 0], "86"));
                        e.push(a)
                    } catch (t) {}
                    return e
                }, this.getExtAIAInfo = function() {
                    var t = this.getExtInfo("authorityInfoAccess");
                    if (void 0 === t) return t;
                    for (var e = {
                            ocsp: [],
                            caissuer: []
                        }, n = r(this.hex, t.vidx), i = 0; i < n.length; i++) {
                        var a = s(this.hex, n[i], [0], "06"),
                            o = s(this.hex, n[i], [1], "86");
                        "2b06010505073001" === a && e.ocsp.push(Ct(o)), "2b06010505073002" === a && e.caissuer.push(Ct(o))
                    }
                    return e
                }, this.getExtAuthorityInfoAccess = function(t, e) {
                    if (void 0 === t && void 0 === e) {
                        var n = this.getExtInfo("authorityInfoAccess");
                        if (void 0 === n) return;
                        t = i(this.hex, n.vidx), e = n.critical
                    }
                    var o = {
                        extname: "authorityInfoAccess",
                        array: []
                    };
                    e && (o.critical = !0);
                    for (var u = r(t, 0), c = 0; c < u.length; c++) {
                        var h = a(t, u[c], [0], "06"),
                            l = Ct(s(t, u[c], [1], "86"));
                        if ("2b06010505073001" == h) o.array.push({
                            ocsp: l
                        });
                        else {
                            if ("2b06010505073002" != h) throw new Error("unknown method: " + h);
                            o.array.push({
                                caissuer: l
                            })
                        }
                    }
                    return o
                }, this.getExtCertificatePolicies = function(t, e) {
                    if (void 0 === t && void 0 === e) {
                        var n = this.getExtInfo("certificatePolicies");
                        if (void 0 === n) return;
                        t = i(this.hex, n.vidx), e = n.critical
                    }
                    var s = {
                        extname: "certificatePolicies",
                        array: []
                    };
                    e && (s.critical = !0);
                    for (var a = r(t, 0), o = 0; o < a.length; o++) {
                        var u = i(t, a[o]),
                            c = this.getPolicyInformation(u);
                        s.array.push(c)
                    }
                    return s
                }, this.getPolicyInformation = function(t) {
                    var e = {},
                        n = s(t, 0, [0], "06");
                    e.policyoid = f(n);
                    var a = h(t, 0, [1], "30");
                    if (-1 != a) {
                        e.array = [];
                        for (var o = r(t, a), u = 0; u < o.length; u++) {
                            var c = i(t, o[u]),
                                l = this.getPolicyQualifierInfo(c);
                            e.array.push(l)
                        }
                    }
                    return e
                }, this.getPolicyQualifierInfo = function(t) {
                    var e = {},
                        r = s(t, 0, [0], "06");
                    if ("2b06010505070201" === r) {
                        var n = a(t, 0, [1], "16");
                        e.cps = At(n)
                    } else if ("2b06010505070202" === r) {
                        var i = o(t, 0, [1], "30");
                        e.unotice = this.getUserNotice(i)
                    }
                    return e
                }, this.getUserNotice = function(t) {
                    for (var e = {}, n = r(t, 0), s = 0; s < n.length; s++) {
                        var a = i(t, n[s]);
                        "30" != a.substr(0, 2) && (e.exptext = this.getDisplayText(a))
                    }
                    return e
                }, this.getDisplayText = function(t) {
                    var e = {};
                    return e.type = {
                        "0c": "utf8",
                        16: "ia5",
                        "1a": "vis",
                        "1e": "bmp"
                    }[t.substr(0, 2)], e.str = At(n(t, 0)), e
                }, this.getExtCRLNumber = function(t, e) {
                    var r = {
                        extname: "cRLNumber"
                    };
                    if (e && (r.critical = !0), "02" == t.substr(0, 2)) return r.num = {
                        hex: n(t, 0)
                    }, r;
                    throw new Error("hExtV parse error: " + t)
                }, this.getExtCRLReason = function(t, e) {
                    var r = {
                        extname: "cRLReason"
                    };
                    if (e && (r.critical = !0), "0a" == t.substr(0, 2)) return r.code = parseInt(n(t, 0), 16), r;
                    throw new Error("hExtV parse error: " + t)
                }, this.getExtOcspNonce = function(t, e) {
                    var r = {
                        extname: "ocspNonce"
                    };
                    e && (r.critical = !0);
                    var i = n(t, 0);
                    return r.hex = i, r
                }, this.getExtOcspNoCheck = function(t, e) {
                    var r = {
                        extname: "ocspNoCheck"
                    };
                    return e && (r.critical = !0), r
                }, this.getX500NameRule = function(t) {
                    for (var e = null, r = [], n = 0; n < t.length; n++)
                        for (var i = t[n], s = 0; s < i.length; s++) r.push(i[s]);
                    for (n = 0; n < r.length; n++) {
                        var a = r[n],
                            o = a.ds,
                            u = a.value,
                            c = a.type;
                        if (":" + o, "prn" != o && "utf8" != o && "ia5" != o) return "mixed";
                        if ("ia5" == o) {
                            if ("CN" != c) return "mixed";
                            if (ct.lang.String.isMail(u)) continue;
                            return "mixed"
                        }
                        if ("C" == c) {
                            if ("prn" == o) continue;
                            return "mixed"
                        }
                        if (":" + o, null == e) e = o;
                        else if (e !== o) return "mixed"
                    }
                    return null == e ? "prn" : e
                }, this.getX500Name = function(t) {
                    for (var e = [], n = r(t, 0), s = 0; s < n.length; s++) e.push(this.getRDN(i(t, n[s])));
                    return e
                }, this.getRDN = function(t) {
                    for (var e = [], n = r(t, 0), s = 0; s < n.length; s++) e.push(this.getAttrTypeAndValue(i(t, n[s])));
                    return e
                }, this.getAttrTypeAndValue = function(t) {
                    var e = {
                            type: null,
                            value: null,
                            ds: null
                        },
                        n = r(t, 0),
                        i = s(t, n[0], [], "06"),
                        a = s(t, n[1], []),
                        o = ct.asn1.ASN1Util.oidHexToInt(i);
                    return e.type = ct.asn1.x509.OID.oid2atype(o), e.value = At(a), e.ds = this.HEX2STAG[t.substr(n[1], 2)], e
                }, this.readCertPEM = function(t) {
                    this.readCertHex(g(t))
                }, this.readCertHex = function(t) {
                    this.hex = t, this.getVersion();
                    try {
                        c(this.hex, 0, [0, 7], "a3"), this.parseExt()
                    } catch (t) {}
                }, this.getParam = function() {
                    var t = {};
                    return t.version = this.getVersion(), t.serial = {
                        hex: this.getSerialNumberHex()
                    }, t.sigalg = this.getSignatureAlgorithmField(), t.issuer = this.getIssuer(), t.notbefore = this.getNotBefore(), t.notafter = this.getNotAfter(), t.subject = this.getSubject(), t.sbjpubkey = Bt(this.getPublicKeyHex(), "PUBLIC KEY"), this.aExtInfo.length > 0 && (t.ext = this.getExtParamArray()), t.sighex = this.getSignatureValueHex(), t
                }, this.getExtParamArray = function(t) {
                    null == t && (-1 != h(this.hex, 0, [0, "[3]"]) && (t = u(this.hex, 0, [0, "[3]", 0], "30")));
                    for (var e = [], n = r(t, 0), s = 0; s < n.length; s++) {
                        var a = i(t, n[s]),
                            o = this.getExtParam(a);
                        null != o && e.push(o)
                    }
                    return e
                }, this.getExtParam = function(t) {
                    var e = r(t, 0).length;
                    if (2 != e && 3 != e) throw new Error("wrong number elements in Extension: " + e + " " + t);
                    var n = p(s(t, 0, [0], "06")),
                        i = !1;
                    3 == e && "0101ff" == o(t, 0, [1]) && (i = !0);
                    var a = o(t, 0, [e - 1, 0]),
                        u = void 0;
                    if ("2.5.29.14" == n ? u = this.getExtSubjectKeyIdentifier(a, i) : "2.5.29.15" == n ? u = this.getExtKeyUsage(a, i) : "2.5.29.17" == n ? u = this.getExtSubjectAltName(a, i) : "2.5.29.18" == n ? u = this.getExtIssuerAltName(a, i) : "2.5.29.19" == n ? u = this.getExtBasicConstraints(a, i) : "2.5.29.31" == n ? u = this.getExtCRLDistributionPoints(a, i) : "2.5.29.32" == n ? u = this.getExtCertificatePolicies(a, i) : "2.5.29.35" == n ? u = this.getExtAuthorityKeyIdentifier(a, i) : "2.5.29.37" == n ? u = this.getExtExtKeyUsage(a, i) : "1.3.6.1.5.5.7.1.1" == n ? u = this.getExtAuthorityInfoAccess(a, i) : "2.5.29.20" == n ? u = this.getExtCRLNumber(a, i) : "2.5.29.21" == n ? u = this.getExtCRLReason(a, i) : "1.3.6.1.5.5.7.48.1.2" == n ? u = this.getExtOcspNonce(a, i) : "1.3.6.1.5.5.7.48.1.5" == n && (u = this.getExtOcspNoCheck(a, i)), null != u) return u;
                    var c = {
                        extname: n,
                        extn: a
                    };
                    return i && (c.critical = !0), c
                }, this.getInfo = function() {
                    var t, e, r, n, i = function(t) {
                            for (var e = "", r = t.array, n = 0; n < r.length; n++) {
                                var i = r[n];
                                if (e += "    policy oid: " + i.policyoid + "\n", void 0 !== i.array)
                                    for (var s = 0; s < i.array.length; s++) {
                                        var a = i.array[s];
                                        void 0 !== a.cps && (e += "    cps: " + a.cps + "\n")
                                    }
                            }
                            return e
                        },
                        s = function(t) {
                            for (var e = "", r = t.array, n = 0; n < r.length; n++) {
                                var i = r[n];
                                try {
                                    void 0 !== i.dpname.full[0].uri && (e += "    " + i.dpname.full[0].uri + "\n")
                                } catch (t) {}
                                try {
                                    void 0 !== i.dname.full[0].dn.hex && (e += "    " + zt.hex2dn(i.dpname.full[0].dn.hex) + "\n")
                                } catch (t) {}
                            }
                            return e
                        },
                        a = function(t) {
                            for (var e = "", r = t.array, n = 0; n < r.length; n++) {
                                var i = r[n];
                                void 0 !== i.caissuer && (e += "    caissuer: " + i.caissuer + "\n"), void 0 !== i.ocsp && (e += "    ocsp: " + i.ocsp + "\n")
                            }
                            return e
                        };
                    if (t = "Basic Fields\n", t += "  serial number: " + this.getSerialNumberHex() + "\n", t += "  signature algorithm: " + this.getSignatureAlgorithmField() + "\n", t += "  issuer: " + this.getIssuerString() + "\n", t += "  notBefore: " + this.getNotBefore() + "\n", t += "  notAfter: " + this.getNotAfter() + "\n", t += "  subject: " + this.getSubjectString() + "\n", t += "  subject public key info: \n", t += "    key algorithm: " + (e = this.getPublicKey()).type + "\n", "RSA" === e.type && (t += "    n=" + Ut(e.n.toString(16)).substr(0, 16) + "...\n", t += "    e=" + Ut(e.e.toString(16)) + "\n"), null != (r = this.aExtInfo)) {
                        t += "X509v3 Extensions:\n";
                        for (var o = 0; o < r.length; o++) {
                            var u = r[o],
                                c = ct.asn1.x509.OID.oid2name(u.oid);
                            "" === c && (c = u.oid);
                            var h = "";
                            if (!0 === u.critical && (h = "CRITICAL"), t += "  " + c + " " + h + ":\n", "basicConstraints" === c) {
                                var l = this.getExtBasicConstraints();
                                void 0 === l.cA ? t += "    {}\n" : (t += "    cA=true", void 0 !== l.pathLen && (t += ", pathLen=" + l.pathLen), t += "\n")
                            } else if ("keyUsage" === c) t += "    " + this.getExtKeyUsageString() + "\n";
                            else if ("subjectKeyIdentifier" === c) t += "    " + this.getExtSubjectKeyIdentifier().kid.hex + "\n";
                            else if ("authorityKeyIdentifier" === c) {
                                var f = this.getExtAuthorityKeyIdentifier();
                                void 0 !== f.kid && (t += "    kid=" + f.kid.hex + "\n")
                            } else {
                                if ("extKeyUsage" === c) t += "    " + this.getExtExtKeyUsage().array.join(", ") + "\n";
                                else if ("subjectAltName" === c) t += "    " + (n = this.getExtSubjectAltName(), JSON.stringify(n.array).replace(/[\[\]\{\}\"]/g, "")) + "\n";
                                else if ("cRLDistributionPoints" === c) t += s(this.getExtCRLDistributionPoints());
                                else if ("authorityInfoAccess" === c) t += a(this.getExtAuthorityInfoAccess());
                                else "certificatePolicies" === c && (t += i(this.getExtCertificatePolicies()))
                            }
                        }
                    }
                    return t += "signature algorithm: " + this.getSignatureAlgorithmName() + "\n", t += "signature: " + this.getSignatureValueHex().substr(0, 16) + "...\n"
                }
            }
            nt.prototype.sign = function(t, e) {
                var r = function(t) {
                    return ct.crypto.Util.hashString(t, e)
                }(t);
                return this.signWithMessageHash(r, e)
            }, nt.prototype.signWithMessageHash = function(t, e) {
                var r = et(ct.crypto.Util.getPaddedDigestInfoHex(t, e, this.n.bitLength()), 16);
                return Mt(this.doPrivate(r).toString(16), this.n.bitLength())
            }, nt.prototype.signPSS = function(t, e, r) {
                var n, i = (n = wt(t), ct.crypto.Util.hashHex(n, e));
                return void 0 === r && (r = -1), this.signWithMessageHashPSS(i, e, r)
            }, nt.prototype.signWithMessageHashPSS = function(t, e, r) {
                var n, i = At(t),
                    s = i.length,
                    a = this.n.bitLength() - 1,
                    o = Math.ceil(a / 8),
                    u = function(t) {
                        return ct.crypto.Util.hashHex(t, e)
                    };
                if (-1 === r || void 0 === r) r = s;
                else if (-2 === r) r = o - s - 2;
                else if (r < -2) throw new Error("invalid salt length");
                if (o < s + r + 2) throw new Error("data too long");
                var c = "";
                r > 0 && (c = new Array(r), (new tt).nextBytes(c), c = String.fromCharCode.apply(String, c));
                var h = At(u(wt("\0\0\0\0\0\0\0\0" + i + c))),
                    l = [];
                for (n = 0; n < o - r - s - 2; n += 1) l[n] = 0;
                var f = String.fromCharCode.apply(String, l) + "" + c,
                    p = Kt(h, f.length, u),
                    d = [];
                for (n = 0; n < f.length; n += 1) d[n] = f.charCodeAt(n) ^ p.charCodeAt(n);
                var g = 65280 >> 8 * o - a & 255;
                for (d[0] &= ~g, n = 0; n < s; n++) d.push(h.charCodeAt(n));
                return d.push(188), Mt(this.doPrivate(new C(d)).toString(16), this.n.bitLength())
            }, nt.prototype.verify = function(t, e) {
                var r = et(e = (e = e.replace(jt, "")).replace(/[ \n]+/g, ""), 16);
                if (r.bitLength() > this.n.bitLength()) return 0;
                var n = qt(this.doPublic(r).toString(16).replace(/^1f+00/, ""));
                if (0 == n.length) return !1;
                var i = n[0];
                return n[1] == function(t) {
                    return ct.crypto.Util.hashString(t, i)
                }(t)
            }, nt.prototype.verifyWithMessageHash = function(t, e) {
                if (e.length != Math.ceil(this.n.bitLength() / 4)) return !1;
                var r = et(e, 16);
                if (r.bitLength() > this.n.bitLength()) return 0;
                var n = qt(this.doPublic(r).toString(16).replace(/^1f+00/, ""));
                if (0 == n.length) return !1;
                n[0];
                return n[1] == t
            }, nt.prototype.verifyPSS = function(t, e, r, n) {
                var i, s = (i = wt(t), ct.crypto.Util.hashHex(i, r));
                return void 0 === n && (n = -1), this.verifyWithMessageHashPSS(s, e, r, n)
            }, nt.prototype.verifyWithMessageHashPSS = function(t, e, r, n) {
                if (e.length != Math.ceil(this.n.bitLength() / 4)) return !1;
                var i, s = new C(e, 16),
                    a = function(t) {
                        return ct.crypto.Util.hashHex(t, r)
                    },
                    o = At(t),
                    u = o.length,
                    c = this.n.bitLength() - 1,
                    h = Math.ceil(c / 8);
                if (-1 === n || void 0 === n) n = u;
                else if (-2 === n) n = h - u - 2;
                else if (n < -2) throw new Error("invalid salt length");
                if (h < u + n + 2) throw new Error("data too long");
                var l = this.doPublic(s).toByteArray();
                for (i = 0; i < l.length; i += 1) l[i] &= 255;
                for (; l.length < h;) l.unshift(0);
                if (188 !== l[h - 1]) throw new Error("encoded message does not end in 0xbc");
                var f = (l = String.fromCharCode.apply(String, l)).substr(0, h - u - 1),
                    p = l.substr(f.length, u),
                    d = 65280 >> 8 * h - c & 255;
                if (0 != (f.charCodeAt(0) & d)) throw new Error("bits beyond keysize not zero");
                var g = Kt(p, f.length, a),
                    y = [];
                for (i = 0; i < f.length; i += 1) y[i] = f.charCodeAt(i) ^ g.charCodeAt(i);
                y[0] &= ~d;
                var v = h - u - n - 2;
                for (i = 0; i < v; i += 1)
                    if (0 !== y[i]) throw new Error("leftmost octets not zero");
                if (1 !== y[v]) throw new Error("0x01 marker not found");
                return p === At(a(wt("\0\0\0\0\0\0\0\0" + o + String.fromCharCode.apply(String, y.slice(-n)))))
            }, nt.SALT_LEN_HLEN = -1, nt.SALT_LEN_MAX = -2, nt.SALT_LEN_RECOVER = -2, zt.hex2dn = function(t, e) {
                if (void 0 === e && (e = 0), "30" !== t.substr(e, 2)) throw new Error("malformed DN");
                for (var r = new Array, n = ft.getChildIdx(t, e), i = 0; i < n.length; i++) r.push(zt.hex2rdn(t, n[i]));
                return "/" + (r = r.map((function(t) {
                    return t.replace("/", "\\/")
                }))).join("/")
            }, zt.hex2rdn = function(t, e) {
                if (void 0 === e && (e = 0), "31" !== t.substr(e, 2)) throw new Error("malformed RDN");
                for (var r = new Array, n = ft.getChildIdx(t, e), i = 0; i < n.length; i++) r.push(zt.hex2attrTypeValue(t, n[i]));
                return (r = r.map((function(t) {
                    return t.replace("+", "\\+")
                }))).join("+")
            }, zt.hex2attrTypeValue = function(t, e) {
                var r = ft,
                    n = r.getV;
                if (void 0 === e && (e = 0), "30" !== t.substr(e, 2)) throw new Error("malformed attribute type and value");
                var i = r.getChildIdx(t, e);
                2 !== i.length || t.substr(i[0], 2);
                var s = n(t, i[0]),
                    a = ct.asn1.ASN1Util.oidHexToInt(s);
                return ct.asn1.x509.OID.oid2atype(a) + "=" + At(n(t, i[1]))
            }, zt.getPublicKeyFromCertHex = function(t) {
                var e = new zt;
                return e.readCertHex(t), e.getPublicKey()
            }, zt.getPublicKeyFromCertPEM = function(t) {
                var e = new zt;
                return e.readCertPEM(t), e.getPublicKey()
            }, zt.getPublicKeyInfoPropOfCertPEM = function(t) {
                var e, r, n = ft.getVbyList,
                    i = {};
                return i.algparam = null, (e = new zt).readCertPEM(t), r = e.getPublicKeyHex(), i.keyhex = n(r, 0, [1], "03").substr(2), i.algoid = n(r, 0, [0, 0], "06"), "2a8648ce3d0201" === i.algoid && (i.algparam = n(r, 0, [0, 1], "06")), i
            }, zt.KEYUSAGE_NAME = ["digitalSignature", "nonRepudiation", "keyEncipherment", "dataEncipherment", "keyAgreement", "keyCertSign", "cRLSign", "encipherOnly", "decipherOnly"];
            void 0 !== ct && ct || (ct = {}), void 0 !== ct.jws && ct.jws || (ct.jws = {}), ct.jws.JWS = function() {
                var t = ct.jws.JWS.isSafeJSONString;
                this.parseJWS = function(e, r) {
                    if (void 0 === this.parsedJWS || !r && void 0 === this.parsedJWS.sigvalH) {
                        var n = e.match(/^([^.]+)\.([^.]+)\.([^.]+)$/);
                        if (null == n) throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
                        var i = n[1],
                            s = n[2],
                            a = n[3],
                            o = i + "." + s;
                        if (this.parsedJWS = {}, this.parsedJWS.headB64U = i, this.parsedJWS.payloadB64U = s, this.parsedJWS.sigvalB64U = a, this.parsedJWS.si = o, !r) {
                            var u = St(a),
                                c = et(u, 16);
                            this.parsedJWS.sigvalH = u, this.parsedJWS.sigvalBI = c
                        }
                        var h = lt(i),
                            l = lt(s);
                        if (this.parsedJWS.headS = h, this.parsedJWS.payloadS = l, !t(h, this.parsedJWS, "headP")) throw "malformed JSON string for JWS Head: " + h
                    }
                }
            }, ct.jws.JWS.sign = function(t, e, r, n, i) {
                var s, a, o, u = ct,
                    c = u.jws.JWS,
                    h = c.readSafeJSONString,
                    l = c.isSafeJSONString,
                    f = u.crypto,
                    p = (f.ECDSA, f.Mac),
                    d = f.Signature,
                    g = JSON;
                if ("string" != typeof e && "object" != typeof e) throw "spHeader must be JSON string or object: " + e;
                if ("object" == typeof e && (a = e, s = g.stringify(a)), "string" == typeof e) {
                    if (!l(s = e)) throw "JWS Head is not safe JSON string: " + s;
                    a = h(s)
                }
                if (o = r, "object" == typeof r && (o = g.stringify(r)), "" != t && null != t || void 0 === a.alg || (t = a.alg), "" != t && null != t && void 0 === a.alg && (a.alg = t, s = g.stringify(a)), t !== a.alg) throw "alg and sHeader.alg doesn't match: " + t + "!=" + a.alg;
                var y = null;
                if (void 0 === c.jwsalg2sigalg[t]) throw "unsupported alg name: " + t;
                y = c.jwsalg2sigalg[t];
                var v = ht(s) + "." + ht(o),
                    m = "";
                if ("Hmac" == y.substr(0, 4)) {
                    if (void 0 === n) throw "mac key shall be specified for HS* alg";
                    var E = new p({
                        alg: y,
                        prov: "cryptojs",
                        pass: n
                    });
                    E.updateString(v), m = E.doFinal()
                } else if (-1 != y.indexOf("withECDSA")) {
                    (b = new d({
                        alg: y
                    })).init(n, i), b.updateString(v);
                    var S = b.sign();
                    m = ct.crypto.ECDSA.asn1SigToConcatSig(S)
                } else {
                    var b;
                    if ("none" != y)(b = new d({
                        alg: y
                    })).init(n, i), b.updateString(v), m = b.sign()
                }
                return v + "." + Et(m)
            }, ct.jws.JWS.verify = function(t, e, r) {
                var n, i = ct,
                    s = i.jws.JWS,
                    a = s.readSafeJSONString,
                    o = i.crypto,
                    u = o.ECDSA,
                    c = o.Mac,
                    h = o.Signature;
                n = nt;
                var l = t.split(".");
                if (3 !== l.length) return !1;
                var f = l[0] + "." + l[1],
                    p = St(l[2]),
                    d = a(lt(l[0])),
                    g = null,
                    y = null;
                if (void 0 === d.alg) throw "algorithm not specified in header";
                if ((y = (g = d.alg).substr(0, 2), null != r && "[object Array]" === Object.prototype.toString.call(r) && r.length > 0) && -1 == (":" + r.join(":") + ":").indexOf(":" + g + ":")) throw "algorithm '" + g + "' not accepted in the list";
                if ("none" != g && null === e) throw "key shall be specified to verify.";
                if ("string" == typeof e && -1 != e.indexOf("-----BEGIN ") && (e = Ht.getKey(e)), !("RS" != y && "PS" != y || e instanceof n)) throw "key shall be a RSAKey obj for RS* and PS* algs";
                if ("ES" == y && !(e instanceof u)) throw "key shall be a ECDSA obj for ES* algs";
                var v = null;
                if (void 0 === s.jwsalg2sigalg[d.alg]) throw "unsupported alg name: " + g;
                if ("none" == (v = s.jwsalg2sigalg[g])) throw "not supported";
                if ("Hmac" == v.substr(0, 4)) {
                    if (void 0 === e) throw "hexadecimal key shall be specified for HMAC";
                    var m = new c({
                        alg: v,
                        pass: e
                    });
                    return m.updateString(f), p == m.doFinal()
                }
                if (-1 != v.indexOf("withECDSA")) {
                    var E, S = null;
                    try {
                        S = u.concatSigToASN1Sig(p)
                    } catch (t) {
                        return !1
                    }
                    return (E = new h({
                        alg: v
                    })).init(e), E.updateString(f), E.verify(S)
                }
                return (E = new h({
                    alg: v
                })).init(e), E.updateString(f), E.verify(p)
            }, ct.jws.JWS.parse = function(t) {
                var e, r, n, i = t.split("."),
                    s = {};
                if (2 != i.length && 3 != i.length) throw "malformed sJWS: wrong number of '.' splitted elements";
                return e = i[0], r = i[1], 3 == i.length && (n = i[2]), s.headerObj = ct.jws.JWS.readSafeJSONString(lt(e)), s.payloadObj = ct.jws.JWS.readSafeJSONString(lt(r)), s.headerPP = JSON.stringify(s.headerObj, null, "  "), null == s.payloadObj ? s.payloadPP = lt(r) : s.payloadPP = JSON.stringify(s.payloadObj, null, "  "), void 0 !== n && (s.sigHex = St(n)), s
            }, ct.jws.JWS.verifyJWT = function(t, e, r) {
                var n = ct.jws,
                    i = n.JWS,
                    s = i.readSafeJSONString,
                    a = i.inArray,
                    o = i.includedArray,
                    u = t.split("."),
                    c = u[0],
                    h = u[1],
                    l = (St(u[2]), s(lt(c))),
                    f = s(lt(h));
                if (void 0 === l.alg) return !1;
                if (void 0 === r.alg) throw "acceptField.alg shall be specified";
                if (!a(l.alg, r.alg)) return !1;
                if (void 0 !== f.iss && "object" == typeof r.iss && !a(f.iss, r.iss)) return !1;
                if (void 0 !== f.sub && "object" == typeof r.sub && !a(f.sub, r.sub)) return !1;
                if (void 0 !== f.aud && "object" == typeof r.aud)
                    if ("string" == typeof f.aud) {
                        if (!a(f.aud, r.aud)) return !1
                    } else if ("object" == typeof f.aud && !o(f.aud, r.aud)) return !1;
                var p = n.IntDate.getNow();
                return void 0 !== r.verifyAt && "number" == typeof r.verifyAt && (p = r.verifyAt), void 0 !== r.gracePeriod && "number" == typeof r.gracePeriod || (r.gracePeriod = 0), !(void 0 !== f.exp && "number" == typeof f.exp && f.exp + r.gracePeriod < p) && (!(void 0 !== f.nbf && "number" == typeof f.nbf && p < f.nbf - r.gracePeriod) && (!(void 0 !== f.iat && "number" == typeof f.iat && p < f.iat - r.gracePeriod) && ((void 0 === f.jti || void 0 === r.jti || f.jti === r.jti) && !!i.verify(t, e, r.alg))))
            }, ct.jws.JWS.includedArray = function(t, e) {
                var r = ct.jws.JWS.inArray;
                if (null === t) return !1;
                if ("object" != typeof t) return !1;
                if ("number" != typeof t.length) return !1;
                for (var n = 0; n < t.length; n++)
                    if (!r(t[n], e)) return !1;
                return !0
            }, ct.jws.JWS.inArray = function(t, e) {
                if (null === e) return !1;
                if ("object" != typeof e) return !1;
                if ("number" != typeof e.length) return !1;
                for (var r = 0; r < e.length; r++)
                    if (e[r] == t) return !0;
                return !1
            }, ct.jws.JWS.jwsalg2sigalg = {
                HS256: "HmacSHA256",
                HS384: "HmacSHA384",
                HS512: "HmacSHA512",
                RS256: "SHA256withRSA",
                RS384: "SHA384withRSA",
                RS512: "SHA512withRSA",
                ES256: "SHA256withECDSA",
                ES384: "SHA384withECDSA",
                PS256: "SHA256withRSAandMGF1",
                PS384: "SHA384withRSAandMGF1",
                PS512: "SHA512withRSAandMGF1",
                none: "none"
            }, ct.jws.JWS.isSafeJSONString = function(t, e, r) {
                var n = null;
                try {
                    return "object" != typeof(n = ut(t)) || n.constructor === Array ? 0 : (e && (e[r] = n), 1)
                } catch (t) {
                    return 0
                }
            }, ct.jws.JWS.readSafeJSONString = function(t) {
                var e = null;
                try {
                    return "object" != typeof(e = ut(t)) || e.constructor === Array ? null : e
                } catch (t) {
                    return null
                }
            }, ct.jws.JWS.getEncodedSignatureValueFromJWS = function(t) {
                var e = t.match(/^[^.]+\.[^.]+\.([^.]+)$/);
                if (null == e) throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
                return e[1]
            }, ct.jws.JWS.getJWKthumbprint = function(t) {
                if ("RSA" !== t.kty && "EC" !== t.kty && "oct" !== t.kty) throw "unsupported algorithm for JWK Thumprint";
                var e = "{";
                if ("RSA" === t.kty) {
                    if ("string" != typeof t.n || "string" != typeof t.e) throw "wrong n and e value for RSA key";
                    e += '"e":"' + t.e + '",', e += '"kty":"' + t.kty + '",', e += '"n":"' + t.n + '"}'
                } else if ("EC" === t.kty) {
                    if ("string" != typeof t.crv || "string" != typeof t.x || "string" != typeof t.y) throw "wrong crv, x and y value for EC key";
                    e += '"crv":"' + t.crv + '",', e += '"kty":"' + t.kty + '",', e += '"x":"' + t.x + '",', e += '"y":"' + t.y + '"}'
                } else if ("oct" === t.kty) {
                    if ("string" != typeof t.k) throw "wrong k value for oct(symmetric) key";
                    e += '"kty":"' + t.kty + '",', e += '"k":"' + t.k + '"}'
                }
                var r = wt(e);
                return Et(ct.crypto.Util.hashHex(r, "sha256"))
            }, ct.jws.IntDate = {}, ct.jws.IntDate.get = function(t) {
                var e = ct.jws.IntDate,
                    r = e.getNow,
                    n = e.getZulu;
                if ("now" == t) return r();
                if ("now + 1hour" == t) return r() + 3600;
                if ("now + 1day" == t) return r() + 86400;
                if ("now + 1month" == t) return r() + 2592e3;
                if ("now + 1year" == t) return r() + 31536e3;
                if (t.match(/Z$/)) return n(t);
                if (t.match(/^[0-9]+$/)) return parseInt(t);
                throw "unsupported format: " + t
            }, ct.jws.IntDate.getZulu = function(t) {
                return Dt(t)
            }, ct.jws.IntDate.getNow = function() {
                return ~~(new Date / 1e3)
            }, ct.jws.IntDate.intDate2UTCString = function(t) {
                return new Date(1e3 * t).toUTCString()
            }, ct.jws.IntDate.intDate2Zulu = function(t) {
                var e = new Date(1e3 * t);
                return ("0000" + e.getUTCFullYear()).slice(-4) + ("00" + (e.getUTCMonth() + 1)).slice(-2) + ("00" + e.getUTCDate()).slice(-2) + ("00" + e.getUTCHours()).slice(-2) + ("00" + e.getUTCMinutes()).slice(-2) + ("00" + e.getUTCSeconds()).slice(-2) + "Z"
            }, void 0 !== ct && ct || (ct = {}), void 0 !== ct.jws && ct.jws || (ct.jws = {}), ct.jws.JWSJS = function() {
                var t = ct.jws.JWS,
                    e = t.readSafeJSONString;
                this.aHeader = [], this.sPayload = "", this.aSignature = [], this.init = function() {
                    this.aHeader = [], this.sPayload = void 0, this.aSignature = []
                }, this.initWithJWS = function(t) {
                    this.init();
                    var e = t.split(".");
                    if (3 != e.length) throw "malformed input JWS";
                    this.aHeader.push(e[0]), this.sPayload = e[1], this.aSignature.push(e[2])
                }, this.addSignature = function(t, e, r, n) {
                    if (void 0 === this.sPayload || null === this.sPayload) throw "there's no JSON-JS signature to add.";
                    var i = this.aHeader.length;
                    if (this.aHeader.length != this.aSignature.length) throw "aHeader.length != aSignature.length";
                    try {
                        var s = ct.jws.JWS.sign(t, e, this.sPayload, r, n).split(".");
                        s[0], s[2];
                        this.aHeader.push(s[0]), this.aSignature.push(s[2])
                    } catch (t) {
                        throw this.aHeader.length > i && this.aHeader.pop(), this.aSignature.length > i && this.aSignature.pop(), "addSignature failed: " + t
                    }
                }, this.verifyAll = function(t) {
                    if (this.aHeader.length !== t.length || this.aSignature.length !== t.length) return !1;
                    for (var e = 0; e < t.length; e++) {
                        var r = t[e];
                        if (2 !== r.length) return !1;
                        if (!1 === this.verifyNth(e, r[0], r[1])) return !1
                    }
                    return !0
                }, this.verifyNth = function(e, r, n) {
                    if (this.aHeader.length <= e || this.aSignature.length <= e) return !1;
                    var i = this.aHeader[e],
                        s = this.aSignature[e],
                        a = i + "." + this.sPayload + "." + s,
                        o = !1;
                    try {
                        o = t.verify(a, r, n)
                    } catch (t) {
                        return !1
                    }
                    return o
                }, this.readJWSJS = function(t) {
                    if ("string" == typeof t) {
                        var r = e(t);
                        if (null == r) throw "argument is not safe JSON object string";
                        this.aHeader = r.headers, this.sPayload = r.payload, this.aSignature = r.signatures
                    } else try {
                        if (!(t.headers.length > 0)) throw "malformed header";
                        if (this.aHeader = t.headers, "string" != typeof t.payload) throw "malformed signatures";
                        if (this.sPayload = t.payload, !(t.signatures.length > 0)) throw "malformed signatures";
                        this.aSignature = t.signatures
                    } catch (t) {
                        throw "malformed JWS-JS JSON object: " + t
                    }
                }, this.getJSON = function() {
                    return {
                        headers: this.aHeader,
                        payload: this.sPayload,
                        signatures: this.aSignature
                    }
                }, this.isEmpty = function() {
                    return 0 == this.aHeader.length ? 1 : 0
                }
            }, e.SecureRandom = tt, e.rng_seed_time = W, e.BigInteger = C, e.RSAKey = nt, e.ECDSA = ct.crypto.ECDSA, e.DSA = ct.crypto.DSA, e.Signature = ct.crypto.Signature, e.MessageDigest = ct.crypto.MessageDigest, e.Mac = ct.crypto.Mac, e.Cipher = ct.crypto.Cipher, e.KEYUTIL = Ht, e.ASN1HEX = ft, e.X509 = zt, e.X509CRL = function(t) {
                var e = ct.lang.String.isHex,
                    r = ft,
                    n = r.getV,
                    i = r.getTLV,
                    s = r.getVbyList,
                    a = r.getTLVbyList,
                    o = r.getTLVbyListEx,
                    u = r.getIdxbyList,
                    c = r.getIdxbyListEx,
                    h = r.getChildIdx,
                    l = new zt;
                this.hex = null, this.posSigAlg = null, this.posRevCert = null, this._setPos = function() {
                    var t = u(this.hex, 0, [0, 0]),
                        e = this.hex.substr(t, 2);
                    if ("02" == e) this.posSigAlg = 1;
                    else {
                        if ("30" != e) throw new Error("malformed 1st item of TBSCertList: " + e);
                        this.posSigAlg = 0
                    }
                    var r, n = u(this.hex, 0, [0, this.posSigAlg + 3]),
                        i = this.hex.substr(n, 2);
                    if ("17" == i || "18" == i) r = u(this.hex, 0, [0, this.posSigAlg + 4]), this.posRevCert = null, -1 != r && "30" == this.hex.substr(r, 2) && (this.posRevCert = this.posSigAlg + 4);
                    else if ("30" == i) this.posRevCert = this.posSigAlg + 3;
                    else {
                        if ("a0" != i) throw new Error("malformed nextUpdate or revCert tag: " + i);
                        this.posRevCert = null
                    }
                }, this.getVersion = function() {
                    return 0 == this.posSigAlg ? null : parseInt(s(this.hex, 0, [0, 0], "02"), 16) + 1
                }, this.getSignatureAlgorithmField = function() {
                    var t = a(this.hex, 0, [0, this.posSigAlg], "30");
                    return l.getAlgorithmIdentifierName(t)
                }, this.getIssuer = function() {
                    var t = a(this.hex, 0, [0, this.posSigAlg + 1], "30"),
                        e = {};
                    return e.array = l.getX500Name(t), e
                }, this.getThisUpdate = function() {
                    var t = s(this.hex, 0, [0, this.posSigAlg + 2]);
                    return result = At(t)
                }, this.getNextUpdate = function() {
                    var t = u(this.hex, 0, [0, this.posSigAlg + 3]),
                        e = this.hex.substr(t, 2);
                    return "17" != e && "18" != e ? null : At(n(this.hex, t))
                }, this.getRevCertArray = function() {
                    if (null == this.posRevCert) return null;
                    for (var t = [], e = u(this.hex, 0, [0, this.posRevCert]), r = h(this.hex, e), n = 0; n < r.length; n++) {
                        var s = i(this.hex, r[n]);
                        t.push(this.getRevCert(s))
                    }
                    return t
                }, this.getRevCert = function(t) {
                    var e = {},
                        r = h(t, 0);
                    return e.sn = {
                        hex: s(t, 0, [0], "02")
                    }, e.date = At(s(t, 0, [1])), 3 == r.length && (e.ext = l.getExtParamArray(a(t, 0, [2]))), e
                }, this.getSignatureValueHex = function() {
                    return s(this.hex, 0, [2], "03", !0)
                }, this.verifySignature = function(t) {
                    var e = this.getSignatureAlgorithmField(),
                        r = this.getSignatureValueHex(),
                        n = a(this.hex, 0, [0], "30"),
                        i = new ct.crypto.Signature({
                            alg: e
                        });
                    return i.init(t), i.updateHex(n), i.verify(r)
                }, this.getParam = function() {
                    var t = {},
                        e = this.getVersion();
                    null != e && (t.version = e), t.sigalg = this.getSignatureAlgorithmField(), t.issuer = this.getIssuer(), t.thisupdate = this.getThisUpdate();
                    var r = this.getNextUpdate();
                    null != r && (t.nextupdate = r);
                    var n = this.getRevCertArray();
                    if (null != n && (t.revcert = n), -1 != c(this.hex, 0, [0, "[0]"])) {
                        var i = o(this.hex, 0, [0, "[0]", 0]);
                        t.ext = l.getExtParamArray(i)
                    }
                    return t.sighex = this.getSignatureValueHex(), t
                }, "string" == typeof t && (e(t) ? this.hex = t : t.match(/-----BEGIN X509 CRL/) && (this.hex = Ft(t)), this._setPos())
            }, e.CryptoJS = y, e.b64tohex = S, e.b64toBA = b, e.ECFieldElementFp = st, e.ECPointFp = at, e.ECCurveFp = ot, e.stoBA = pt, e.BAtos = dt, e.BAtohex = gt, e.stohex = yt, e.stob64 = function(t) {
                return E(yt(t))
            }, e.stob64u = function(t) {
                return vt(E(yt(t)))
            }, e.b64utos = function(t) {
                return dt(b(mt(t)))
            }, e.b64tob64u = vt, e.b64utob64 = mt, e.hex2b64 = E, e.hextob64u = Et, e.b64utohex = St, e.utf8tob64u = ht, e.b64utoutf8 = lt, e.utf8tob64 = function(t) {
                return E(Nt(Ot(t)))
            }, e.b64toutf8 = function(t) {
                return decodeURIComponent(_t(S(t)))
            }, e.utf8tohex = bt, e.hextoutf8 = Ct, e.hextorstr = At, e.rstrtohex = wt, e.hextob64 = Tt, e.hextob64nl = xt, e.b64nltohex = It, e.hextopem = Bt, e.pemtohex = Ft, e.hextoArrayBuffer = function(t) {
                if (t.length % 2 != 0) throw "input is not even length";
                if (null == t.match(/^[0-9A-Fa-f]+$/)) throw "input is not hexadecimal";
                for (var e = new ArrayBuffer(t.length / 2), r = new DataView(e), n = 0; n < t.length / 2; n++) r.setUint8(n, parseInt(t.substr(2 * n, 2), 16));
                return e
            }, e.ArrayBuffertohex = function(t) {
                for (var e = "", r = new DataView(t), n = 0; n < t.byteLength; n++) e += ("00" + r.getUint8(n).toString(16)).slice(-2);
                return e
            }, e.zulutomsec = Rt, e.zulutosec = Dt, e.zulutodate = function(t) {
                return new Date(Rt(t))
            }, e.datetozulu = function(t, e, r) {
                var n, i = t.getUTCFullYear();
                if (e) {
                    if (i < 1950 || 2049 < i) throw "not proper year for UTCTime: " + i;
                    n = ("" + i).slice(-2)
                } else n = ("000" + i).slice(-4);
                if (n += ("0" + (t.getUTCMonth() + 1)).slice(-2), n += ("0" + t.getUTCDate()).slice(-2), n += ("0" + t.getUTCHours()).slice(-2), n += ("0" + t.getUTCMinutes()).slice(-2), n += ("0" + t.getUTCSeconds()).slice(-2), r) {
                    var s = t.getUTCMilliseconds();
                    0 !== s && (n += "." + (s = (s = ("00" + s).slice(-3)).replace(/0+$/g, "")))
                }
                return n += "Z"
            }, e.uricmptohex = Nt, e.hextouricmp = _t, e.ipv6tohex = Pt, e.hextoipv6 = kt, e.hextoip = Lt, e.iptohex = function(t) {
                var e = "malformed IP address";
                if (!(t = t.toLowerCase(t)).match(/^[0-9.]+$/)) {
                    if (t.match(/^[0-9a-f:]+$/) && -1 !== t.indexOf(":")) return Pt(t);
                    throw e
                }
                var r = t.split(".");
                if (4 !== r.length) throw e;
                var n = "";
                try {
                    for (var i = 0; i < 4; i++) {
                        n += ("0" + parseInt(r[i]).toString(16)).slice(-2)
                    }
                    return n
                } catch (t) {
                    throw e
                }
            }, e.encodeURIComponentAll = Ot, e.newline_toUnix = function(t) {
                return t = t.replace(/\r\n/gm, "\n")
            }, e.newline_toDos = function(t) {
                return t = (t = t.replace(/\r\n/gm, "\n")).replace(/\n/gm, "\r\n")
            }, e.hextoposhex = Ut, e.intarystrtohex = Vt, e.strdiffidx = function(t, e) {
                var r = t.length;
                t.length > e.length && (r = e.length);
                for (var n = 0; n < r; n++)
                    if (t.charCodeAt(n) != e.charCodeAt(n)) return n;
                return t.length != e.length ? r : -1
            }, e.KJUR = ct, e.crypto = ct.crypto, e.asn1 = ct.asn1, e.jws = ct.jws, e.lang = ct.lang
        }).call(this, r(2).Buffer)
    }, function(t, e, r) {
        "use strict";
        r(78), r(66), r(137), r(30), r(38);
        var n = r(206),
            i = r(184),
            s = r(51),
            a = s.BigInteger,
            o = (s.SecureRandom, r(195)),
            u = r(197),
            c = (r(198).SM4, r(77)),
            h = r(279),
            l = c.generateEcparam(),
            f = (l.G, l.curve, l.n, r(280));
        r(200);

        function p(t) {
            var e, r, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                i = "";
            for (e = 0; e + 3 <= t.length; e += 3) r = parseInt(t.substring(e, e + 3), 16), i += n.charAt(r >> 6) + n.charAt(63 & r);
            for (e + 1 == t.length ? (r = parseInt(t.substring(e, e + 1), 16), i += n.charAt(r << 2)) : e + 2 == t.length && (r = parseInt(t.substring(e, e + 2), 16), i += n.charAt(r >> 2) + n.charAt((3 & r) << 4)), "=";
                (3 & i.length) > 0;) i += "=";
            return i
        }
        t.exports = {
            isec_crypto_getversion: function() {
                return f.success("2.0.0.0")
            },
            isec_crypto_generate_asymm_key: function(t) {
                var e = null,
                    r = null;
                if (-1 == ["256", "1024", "2048"].indexOf(t)) return f.error().paramError;
                if ("256" == t) {
                    var n = c.generateKeyPairHex(),
                        s = {
                            publicKey: e = n.publicKey,
                            privateKey: r = n.privateKey
                        };
                    return f.success(s)
                }
                var a = i.pki.rsa.generateKeyPair({
                    bits: t,
                    e: 65537
                });
                e = i.pki.publicKeyToPem(a.publicKey), r = i.pki.privateKeyToPem(a.privateKey);
                var o = {
                    publicKey: e.split("-----BEGIN PUBLIC KEY-----\r\n")[1].split("\r\n-----END PUBLIC KEY-----")[0],
                    privateKey: r.split("-----BEGIN RSA PRIVATE KEY-----\r\n")[1].split("\r\n-----END RSA PRIVATE KEY-----")[0]
                };
                return f.success(o)
            },
            isec_crypto_generate_symm_key: function(t) {
                if (-1 == [64, 128, 192, 256].indexOf(t)) return f.error().paramError;
                var e = function(t) {
                    for (var e, r, n = "", i = parseInt((t + 7) / 8), s = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"], a = "", o = 0; o < i; o++) e = Math.round(Math.random() * (s.length - 1)), n += s[e], r = Math.round(Math.random() * (s.length - 1)), a += s[r];
                    return {
                        key: n,
                        iv: a
                    }
                }(t);
                return e.key = e.key, e.iv = e.iv, f.success(e)
            },
            isec_crypto_sm2_encrypt: function(t) {
                var e = t.plaintext,
                    r = t.publicKey,
                    n = t.encType,
                    i = void 0 === n || n,
                    s = t.cipherMode,
                    a = void 0 === s ? 1 : s,
                    u = new o;
                e = i ? c.hexToArray(c.parseUtf8StringToHex(e)) : e, (r = r).length > 128 && (r = r.substr(r.length - 128));
                var h = r.substr(0, 64),
                    l = r.substr(64);
                r = u.createPoint(h, l);
                var p = u.initEncipher(r);
                u.encryptBlock(e);
                var d = c.arrayToHex(e),
                    g = new Array(32);
                return u.doFinal(g), g = c.arrayToHex(g), f.success(0 === a ? p + d + g : p + g + d)
            },
            isec_crypto_sm2_decrypt: function(t) {
                var e = t.ciphertext,
                    r = t.privateKey,
                    n = t.decType,
                    i = void 0 === n || n,
                    s = t.cipherMode,
                    u = void 0 === s ? 1 : s,
                    h = new o;
                r = new a(r, 16);
                var l = e.substr(0, 64),
                    p = e.substr(0 + l.length, 64),
                    d = l.length + p.length,
                    g = e.substr(d, 64),
                    y = e.substr(d + 64);
                0 === u && (g = e.substr(e.length - 64), y = e.substr(d, e.length - d - 64));
                var v = c.hexToArray(y),
                    m = h.createPoint(l, p);
                h.initDecipher(r, m), h.decryptBlock(v);
                var E = new Array(32);
                if (h.doFinal(E), c.arrayToHex(E) === g) {
                    var S = i ? c.arrayToUtf8(v) : v;
                    return f.success(S)
                }
                return f.error().decryptError
            },
            isec_crypto_ascii_to_hex: function(t) {
                return c.arrayToHex(t)
            },
            isec_crypto_hex_to_ascii: function(t) {
                return c.hexToArray(t)
            },
            isec_crypto_utf8_to_hex: function(t) {
                return c.parseUtf8StringToHex(t)
            },
            isec_crypto_utf8_to_base64: function(t) {
                var e = n.enc.Utf8.parse(t),
                    r = n.enc.Base64.stringify(e);
                return f.success(r)
            },
            isec_crypto_base64_to_utf8: function(t) {
                var e = n.enc.Base64.parse(t).toString(n.enc.Utf8);
                return f.success(e)
            },
            isec_crypto_sm2_sign: function(t) {
                var e = t.privateKey,
                    r = t.plaintext,
                    n = f.doSignature(r, e, {
                        der: !0,
                        hash: !0
                    });
                return f.success(p(n))
            },
            isec_crypto_sm2_verify: function(t) {
                var e = t.plaintext,
                    r = t.ciphertext,
                    n = t.publicKey,
                    i = f.doVerifySignature(e, f.b64tohex(r), n, {
                        der: !0,
                        hash: !0
                    });
                return i ? f.success(i) : f.error().verifyError
            },
            isec_crypto_base64_to_hex: function(t) {
                return f.success(f.b64tohex(t))
            },
            isec_crypto_hex_to_base64: function(t) {
                return f.success(p(t))
            },
            isec_crypto_sm4_encrypt: function(t) {
                var e = t.plaintext,
                    r = void 0 === e ? "" : e,
                    n = t.key,
                    i = t.iv,
                    s = void 0 === i ? null : i,
                    a = t.mode,
                    o = void 0 === a ? "ECB" : a,
                    u = t.padding,
                    l = void 0 === u ? "pkcs7padding" : u,
                    d = null,
                    g = new h.SM4;
                switch (o) {
                    case "ECB":
                        d = g.encrypt_ecb(n, c.hexToArray(c.parseUtf8StringToHex(r)), l);
                        break;
                    case "CBC":
                        if (!s) return f.error().paramError;
                        d = g.encrypt_cbc(n, s, c.hexToArray(c.parseUtf8StringToHex(r)), l);
                        break;
                    case "OFB":
                        if (!s) return f.error().paramError;
                        d = g.encrypt_ofb(n, s, c.hexToArray(c.parseUtf8StringToHex(r)), l);
                        break;
                    case "CTR":
                        if (!s) return f.error().paramError;
                        d = g.encrypt_ctr(n, s, c.hexToArray(c.parseUtf8StringToHex(r)), l)
                }
                return -1 == d ? f.error().paramError : f.success(p(d))
            },
            isec_crypto_sm4_decrypt: function(t) {
                var e = t.ciphertext,
                    r = void 0 === e ? "" : e,
                    n = t.key,
                    i = t.iv,
                    s = void 0 === i ? null : i,
                    a = t.mode,
                    o = void 0 === a ? "ECB" : a,
                    u = t.padding,
                    c = void 0 === u ? "pkcs7padding" : u,
                    l = null,
                    p = new h.SM4;
                if ("ECB" == o) l = p.decrypt_ecb(n, f.b64tohex(r), c);
                else if ("CBC" == o) {
                    if (!s) return f.error().paramError;
                    l = p.decrypt_cbc(n, s, f.b64tohex(r), c)
                } else if ("OFB" == o) {
                    if (!s) return f.error().paramError;
                    l = p.decrypt_ofb(n, s, f.b64tohex(r), c)
                } else if ("CTR" == o) {
                    if (!s) return f.error().paramError;
                    l = p.decrypt_ctr(n, s, f.b64tohex(r), c)
                }
                return -1 == l ? f.error().paramError : f.success(l)
            },
            isec_crypto_sm3_hash: function(t) {
                return f.success(u(t))
            },
            isec_crypto_hmac_sm3: function(t) {
                var e = t.plaintext,
                    r = t.key;
                return f.success(f.hmacSM3(e, r))
            }
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(10),
            s = r(9),
            a = r(14),
            o = n.TypeError;
        t.exports = function(t, e) {
            var r, n;
            if ("string" === e && s(r = t.toString) && !a(n = i(r, t))) return n;
            if (s(r = t.valueOf) && !a(n = i(r, t))) return n;
            if ("string" !== e && s(r = t.toString) && !a(n = i(r, t))) return n;
            throw o("Can't convert object to primitive value")
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(9),
            s = r(83),
            a = n.WeakMap;
        t.exports = i(a) && /native code/.test(s(a))
    }, function(t, e, r) {
        var n = r(28),
            i = r(1),
            s = r(44),
            a = r(134),
            o = r(11),
            u = i([].concat);
        t.exports = n("Reflect", "ownKeys") || function(t) {
            var e = s.f(o(t)),
                r = a.f;
            return r ? u(e, r(t)) : e
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(135),
            i = r(46);
        t.exports = n ? {}.toString : function() {
            return "[object " + i(this) + "]"
        }
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(94), r(208), r(227), r(49), r(228), r(59), r(149), r(150), r(229), r(183), r(230), r(231), r(232), r(125), r(233), r(50), r(18), r(234), r(235), r(236), r(237), r(238), r(239), r(240), r(241), r(242), r(243), r(244), r(245), r(246), r(247), r(248), r(249), n)
    }, function(t, e) {}, function(t, e, r) {
        "use strict";
        var n, i, s, a;

        function o(t) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }
        r(68), r(69), r(70), r(57), r(73), r(173), r(98), r(30), r(31), r(99), r(101), r(102), r(103), r(104), r(106), r(107), r(108), r(109), r(110), r(111), r(112), r(113), r(114), r(115), r(116), r(117), r(118), r(119), r(120), r(121), r(122), r(123), r(124), r(222), r(223), r(224), r(180), r(225), r(181), r(226), r(182), a = function(t) {
            return function() {
                if ("function" == typeof ArrayBuffer) {
                    var e = t.lib.WordArray,
                        r = e.init;
                    (e.init = function(t) {
                        if (t instanceof ArrayBuffer && (t = new Uint8Array(t)), (t instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array) && (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength)), t instanceof Uint8Array) {
                            for (var e = t.byteLength, n = [], i = 0; i < e; i++) n[i >>> 2] |= t[i] << 24 - i % 4 * 8;
                            r.call(this, n, e)
                        } else r.apply(this, arguments)
                    }).prototype = e
                }
            }(), t.lib.WordArray
        }, "object" === o(e) ? t.exports = e = a(r(4)) : (i = [r(4)], void 0 === (s = "function" == typeof(n = a) ? n.apply(e, i) : n) || (t.exports = s))
    }, function(t, e, r) {
        var n = r(41),
            i = r(23),
            s = r(44).f,
            a = r(21),
            o = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        t.exports.f = function(t) {
            return o && "Window" == n(t) ? function(t) {
                try {
                    return s(t)
                } catch (t) {
                    return a(o)
                }
            }(t) : s(i(t))
        }
    }, function(t, e, r) {
        var n = r(0);
        t.exports = n
    }, function(t, e, r) {
        var n = r(0),
            i = r(95),
            s = r(91),
            a = r(14),
            o = r(7)("species"),
            u = n.Array;
        t.exports = function(t) {
            var e;
            return i(t) && (e = t.constructor, (s(e) && (e === u || i(e.prototype)) || a(e) && null === (e = e[o])) && (e = void 0)), void 0 === e ? u : e
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(9),
            s = n.String,
            a = n.TypeError;
        t.exports = function(t) {
            if ("object" == typeof t || i(t)) return t;
            throw a("Can't set " + s(t) + " as a prototype")
        }
    }, function(t, e, r) {
        var n = r(0).Array,
            i = Math.abs,
            s = Math.pow,
            a = Math.floor,
            o = Math.log,
            u = Math.LN2;
        t.exports = {
            pack: function(t, e, r) {
                var c, h, l, f = n(r),
                    p = 8 * r - e - 1,
                    d = (1 << p) - 1,
                    g = d >> 1,
                    y = 23 === e ? s(2, -24) - s(2, -77) : 0,
                    v = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0,
                    m = 0;
                for ((t = i(t)) != t || t === 1 / 0 ? (h = t != t ? 1 : 0, c = d) : (c = a(o(t) / u), t * (l = s(2, -c)) < 1 && (c--, l *= 2), (t += c + g >= 1 ? y / l : y * s(2, 1 - g)) * l >= 2 && (c++, l /= 2), c + g >= d ? (h = 0, c = d) : c + g >= 1 ? (h = (t * l - 1) * s(2, e), c += g) : (h = t * s(2, g - 1) * s(2, e), c = 0)); e >= 8; f[m++] = 255 & h, h /= 256, e -= 8);
                for (c = c << e | h, p += e; p > 0; f[m++] = 255 & c, c /= 256, p -= 8);
                return f[--m] |= 128 * v, f
            },
            unpack: function(t, e) {
                var r, n = t.length,
                    i = 8 * n - e - 1,
                    a = (1 << i) - 1,
                    o = a >> 1,
                    u = i - 7,
                    c = n - 1,
                    h = t[c--],
                    l = 127 & h;
                for (h >>= 7; u > 0; l = 256 * l + t[c], c--, u -= 8);
                for (r = l & (1 << -u) - 1, l >>= -u, u += e; u > 0; r = 256 * r + t[c], c--, u -= 8);
                if (0 === l) l = 1 - o;
                else {
                    if (l === a) return r ? NaN : h ? -1 / 0 : 1 / 0;
                    r += s(2, e), l -= o
                }
                return (h ? -1 : 1) * r * s(2, l - e)
            }
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(3),
            s = r(144),
            a = r(8).NATIVE_ARRAY_BUFFER_VIEWS,
            o = n.ArrayBuffer,
            u = n.Int8Array;
        t.exports = !a || !i((function() {
            u(1)
        })) || !i((function() {
            new u(-1)
        })) || !s((function(t) {
            new u, new u(null), new u(1.5), new u(t)
        }), !0) || i((function() {
            return 1 !== new u(new o(2), 1, void 0).length
        }))
    }, function(t, e, r) {
        var n = r(14),
            i = Math.floor;
        t.exports = Number.isInteger || function(t) {
            return !n(t) && isFinite(t) && i(t) === t
        }
    }, function(t, e, r) {
        var n = r(0),
            i = r(26),
            s = n.RangeError;
        t.exports = function(t) {
            var e = i(t);
            if (e < 0) throw s("The argument can't be less than 0");
            return e
        }
    }, function(t, e, r) {
        var n = r(39),
            i = r(10),
            s = r(139),
            a = r(15),
            o = r(20),
            u = r(100),
            c = r(75),
            h = r(145),
            l = r(8).aTypedArrayConstructor;
        t.exports = function(t) {
            var e, r, f, p, d, g, y = s(this),
                v = a(t),
                m = arguments.length,
                E = m > 1 ? arguments[1] : void 0,
                S = void 0 !== E,
                b = c(v);
            if (b && !h(b))
                for (g = (d = u(v, b)).next, v = []; !(p = i(g, d)).done;) v.push(p.value);
            for (S && m > 2 && (E = n(E, arguments[2])), r = o(v), f = new(l(y))(r), e = 0; r > e; e++) f[e] = S ? E(v[e], e) : v[e];
            return f
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(15),
            i = r(45),
            s = r(20),
            a = Math.min;
        t.exports = [].copyWithin || function(t, e) {
            var r = n(this),
                o = s(r),
                u = i(t, o),
                c = i(e, o),
                h = arguments.length > 2 ? arguments[2] : void 0,
                l = a((void 0 === h ? o : i(h, o)) - c, o - u),
                f = 1;
            for (c < u && u < c + l && (f = -1, c += l - 1, u += l - 1); l-- > 0;) c in r ? r[u] = r[c] : delete r[u], u += f, c += f;
            return r
        }
    }, function(t, e, r) {
        var n = r(220),
            i = r(105);
        t.exports = function(t, e) {
            return n(i(t), e)
        }
    }, function(t, e) {
        t.exports = function(t, e) {
            for (var r = 0, n = e.length, i = new t(n); n > r;) i[r] = e[r++];
            return i
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(34),
            i = r(23),
            s = r(26),
            a = r(20),
            o = r(56),
            u = Math.min,
            c = [].lastIndexOf,
            h = !!c && 1 / [1].lastIndexOf(1, -0) < 0,
            l = o("lastIndexOf"),
            f = h || !l;
        t.exports = f ? function(t) {
            if (h) return n(c, this, arguments) || 0;
            var e = i(this),
                r = a(e),
                o = r - 1;
            for (arguments.length > 1 && (o = u(o, s(arguments[1]))), o < 0 && (o = r + o); o >= 0; o--)
                if (o in e && e[o] === t) return o || 0;
            return -1
        } : c
    }, function(t, e, r) {
        r(35)("Int8", (function(t) {
            return function(e, r, n) {
                return t(this, e, r, n)
            }
        }))
    }, function(t, e, r) {
        r(35)("Uint8", (function(t) {
            return function(e, r, n) {
                return t(this, e, r, n)
            }
        }), !0)
    }, function(t, e, r) {
        r(35)("Int16", (function(t) {
            return function(e, r, n) {
                return t(this, e, r, n)
            }
        }))
    }, function(t, e, r) {
        r(35)("Int32", (function(t) {
            return function(e, r, n) {
                return t(this, e, r, n)
            }
        }))
    }, function(t, e, r) {
        r(35)("Float32", (function(t) {
            return function(e, r, n) {
                return t(this, e, r, n)
            }
        }))
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), function() {
            var t = n,
                e = t.lib.WordArray,
                r = t.enc;

            function i(t) {
                return t << 8 & 4278255360 | t >>> 8 & 16711935
            }
            r.Utf16 = r.Utf16BE = {
                stringify: function(t) {
                    for (var e = t.words, r = t.sigBytes, n = [], i = 0; i < r; i += 2) {
                        var s = e[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
                        n.push(String.fromCharCode(s))
                    }
                    return n.join("")
                },
                parse: function(t) {
                    for (var r = t.length, n = [], i = 0; i < r; i++) n[i >>> 1] |= t.charCodeAt(i) << 16 - i % 2 * 16;
                    return e.create(n, 2 * r)
                }
            }, r.Utf16LE = {
                stringify: function(t) {
                    for (var e = t.words, r = t.sigBytes, n = [], s = 0; s < r; s += 2) {
                        var a = i(e[s >>> 2] >>> 16 - s % 4 * 8 & 65535);
                        n.push(String.fromCharCode(a))
                    }
                    return n.join("")
                },
                parse: function(t) {
                    for (var r = t.length, n = [], s = 0; s < r; s++) n[s >>> 1] |= i(t.charCodeAt(s) << 16 - s % 2 * 16);
                    return e.create(n, 2 * r)
                }
            }
        }(), n.enc.Utf16)
    }, function(t, e, r) {
        "use strict";
        var n, i, s, a;

        function o(t) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }
        r(68), r(69), r(30), r(70), r(31), r(57), r(73), r(58), r(78), a = function(t) {
            return function() {
                var e = t,
                    r = e.lib.WordArray;

                function n(t, e, n) {
                    for (var i = [], s = 0, a = 0; a < e; a++)
                        if (a % 4) {
                            var o = n[t.charCodeAt(a - 1)] << a % 4 * 2 | n[t.charCodeAt(a)] >>> 6 - a % 4 * 2;
                            i[s >>> 2] |= o << 24 - s % 4 * 8, s++
                        }
                    return r.create(i, s)
                }
                e.enc.Base64url = {
                    stringify: function(t) {
                        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                            r = t.words,
                            n = t.sigBytes,
                            i = e ? this._safe_map : this._map;
                        t.clamp();
                        for (var s = [], a = 0; a < n; a += 3)
                            for (var o = r[a >>> 2] >>> 24 - a % 4 * 8 & 255, u = r[a + 1 >>> 2] >>> 24 - (a + 1) % 4 * 8 & 255, c = r[a + 2 >>> 2] >>> 24 - (a + 2) % 4 * 8 & 255, h = o << 16 | u << 8 | c, l = 0; l < 4 && a + .75 * l < n; l++) s.push(i.charAt(h >>> 6 * (3 - l) & 63));
                        var f = i.charAt(64);
                        if (f)
                            for (; s.length % 4;) s.push(f);
                        return s.join("")
                    },
                    parse: function(t) {
                        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                            r = t.length,
                            i = e ? this._safe_map : this._map,
                            s = this._reverseMap;
                        if (!s) {
                            s = this._reverseMap = [];
                            for (var a = 0; a < i.length; a++) s[i.charCodeAt(a)] = a
                        }
                        var o = i.charAt(64);
                        if (o) {
                            var u = t.indexOf(o); - 1 !== u && (r = u)
                        }
                        return n(t, r, s)
                    },
                    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
                }
            }(), t.enc.Base64url
        }, "object" === o(e) ? t.exports = e = a(r(4)) : (i = [r(4)], void 0 === (s = "function" == typeof(n = a) ? n.apply(e, i) : n) || (t.exports = s))
    }, function(t, e, r) {
        var n, i, s, a, o, u;
        t.exports = (u = r(4), r(150), i = (n = u).lib.WordArray, s = n.algo, a = s.SHA256, o = s.SHA224 = a.extend({
            _doReset: function() {
                this._hash = new i.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
            },
            _doFinalize: function() {
                var t = a._doFinalize.call(this);
                return t.sigBytes -= 4, t
            }
        }), n.SHA224 = a._createHelper(o), n.HmacSHA224 = a._createHmacHelper(o), u.SHA224)
    }, function(t, e, r) {
        var n, i, s, a, o, u, c, h;
        t.exports = (h = r(4), r(94), r(183), i = (n = h).x64, s = i.Word, a = i.WordArray, o = n.algo, u = o.SHA512, c = o.SHA384 = u.extend({
            _doReset: function() {
                this._hash = new a.init([new s.init(3418070365, 3238371032), new s.init(1654270250, 914150663), new s.init(2438529370, 812702999), new s.init(355462360, 4144912697), new s.init(1731405415, 4290775857), new s.init(2394180231, 1750603025), new s.init(3675008525, 1694076839), new s.init(1203062813, 3204075428)])
            },
            _doFinalize: function() {
                var t = u._doFinalize.call(this);
                return t.sigBytes -= 16, t
            }
        }), n.SHA384 = u._createHelper(c), n.HmacSHA384 = u._createHmacHelper(c), h.SHA384)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(94), function(t) {
            var e = n,
                r = e.lib,
                i = r.WordArray,
                s = r.Hasher,
                a = e.x64.Word,
                o = e.algo,
                u = [],
                c = [],
                h = [];
            ! function() {
                for (var t = 1, e = 0, r = 0; r < 24; r++) {
                    u[t + 5 * e] = (r + 1) * (r + 2) / 2 % 64;
                    var n = (2 * t + 3 * e) % 5;
                    t = e % 5, e = n
                }
                for (t = 0; t < 5; t++)
                    for (e = 0; e < 5; e++) c[t + 5 * e] = e + (2 * t + 3 * e) % 5 * 5;
                for (var i = 1, s = 0; s < 24; s++) {
                    for (var o = 0, l = 0, f = 0; f < 7; f++) {
                        if (1 & i) {
                            var p = (1 << f) - 1;
                            p < 32 ? l ^= 1 << p : o ^= 1 << p - 32
                        }
                        128 & i ? i = i << 1 ^ 113 : i <<= 1
                    }
                    h[s] = a.create(o, l)
                }
            }();
            var l = [];
            ! function() {
                for (var t = 0; t < 25; t++) l[t] = a.create()
            }();
            var f = o.SHA3 = s.extend({
                cfg: s.cfg.extend({
                    outputLength: 512
                }),
                _doReset: function() {
                    for (var t = this._state = [], e = 0; e < 25; e++) t[e] = new a.init;
                    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32
                },
                _doProcessBlock: function(t, e) {
                    for (var r = this._state, n = this.blockSize / 2, i = 0; i < n; i++) {
                        var s = t[e + 2 * i],
                            a = t[e + 2 * i + 1];
                        s = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8), a = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8), (B = r[i]).high ^= a, B.low ^= s
                    }
                    for (var o = 0; o < 24; o++) {
                        for (var f = 0; f < 5; f++) {
                            for (var p = 0, d = 0, g = 0; g < 5; g++) p ^= (B = r[f + 5 * g]).high, d ^= B.low;
                            var y = l[f];
                            y.high = p, y.low = d
                        }
                        for (f = 0; f < 5; f++) {
                            var v = l[(f + 4) % 5],
                                m = l[(f + 1) % 5],
                                E = m.high,
                                S = m.low;
                            for (p = v.high ^ (E << 1 | S >>> 31), d = v.low ^ (S << 1 | E >>> 31), g = 0; g < 5; g++)(B = r[f + 5 * g]).high ^= p, B.low ^= d
                        }
                        for (var b = 1; b < 25; b++) {
                            var C = (B = r[b]).high,
                                A = B.low,
                                w = u[b];
                            w < 32 ? (p = C << w | A >>> 32 - w, d = A << w | C >>> 32 - w) : (p = A << w - 32 | C >>> 64 - w, d = C << w - 32 | A >>> 64 - w);
                            var T = l[c[b]];
                            T.high = p, T.low = d
                        }
                        var x = l[0],
                            I = r[0];
                        for (x.high = I.high, x.low = I.low, f = 0; f < 5; f++)
                            for (g = 0; g < 5; g++) {
                                var B = r[b = f + 5 * g],
                                    F = l[b],
                                    R = l[(f + 1) % 5 + 5 * g],
                                    D = l[(f + 2) % 5 + 5 * g];
                                B.high = F.high ^ ~R.high & D.high, B.low = F.low ^ ~R.low & D.low
                            }
                        B = r[0];
                        var N = h[o];
                        B.high ^= N.high, B.low ^= N.low
                    }
                },
                _doFinalize: function() {
                    var e = this._data,
                        r = e.words,
                        n = (this._nDataBytes, 8 * e.sigBytes),
                        s = 32 * this.blockSize;
                    r[n >>> 5] |= 1 << 24 - n % 32, r[(t.ceil((n + 1) / s) * s >>> 5) - 1] |= 128, e.sigBytes = 4 * r.length, this._process();
                    for (var a = this._state, o = this.cfg.outputLength / 8, u = o / 8, c = [], h = 0; h < u; h++) {
                        var l = a[h],
                            f = l.high,
                            p = l.low;
                        f = 16711935 & (f << 8 | f >>> 24) | 4278255360 & (f << 24 | f >>> 8), p = 16711935 & (p << 8 | p >>> 24) | 4278255360 & (p << 24 | p >>> 8), c.push(p), c.push(f)
                    }
                    return new i.init(c, o)
                },
                clone: function() {
                    for (var t = s.clone.call(this), e = t._state = this._state.slice(0), r = 0; r < 25; r++) e[r] = e[r].clone();
                    return t
                }
            });
            e.SHA3 = s._createHelper(f), e.HmacSHA3 = s._createHmacHelper(f)
        }(Math), n.SHA3)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4),
            /** @preserve
            	(c) 2012 by Cdric Mesnil. All rights reserved.

            	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

            	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
            	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

            	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
            	*/
            function(t) {
                var e = n,
                    r = e.lib,
                    i = r.WordArray,
                    s = r.Hasher,
                    a = e.algo,
                    o = i.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
                    u = i.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
                    c = i.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),
                    h = i.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
                    l = i.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
                    f = i.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),
                    p = a.RIPEMD160 = s.extend({
                        _doReset: function() {
                            this._hash = i.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                        },
                        _doProcessBlock: function(t, e) {
                            for (var r = 0; r < 16; r++) {
                                var n = e + r,
                                    i = t[n];
                                t[n] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8)
                            }
                            var s, a, p, S, b, C, A, w, T, x, I, B = this._hash.words,
                                F = l.words,
                                R = f.words,
                                D = o.words,
                                N = u.words,
                                _ = c.words,
                                P = h.words;
                            for (C = s = B[0], A = a = B[1], w = p = B[2], T = S = B[3], x = b = B[4], r = 0; r < 80; r += 1) I = s + t[e + D[r]] | 0, I += r < 16 ? d(a, p, S) + F[0] : r < 32 ? g(a, p, S) + F[1] : r < 48 ? y(a, p, S) + F[2] : r < 64 ? v(a, p, S) + F[3] : m(a, p, S) + F[4], I = (I = E(I |= 0, _[r])) + b | 0, s = b, b = S, S = E(p, 10), p = a, a = I, I = C + t[e + N[r]] | 0, I += r < 16 ? m(A, w, T) + R[0] : r < 32 ? v(A, w, T) + R[1] : r < 48 ? y(A, w, T) + R[2] : r < 64 ? g(A, w, T) + R[3] : d(A, w, T) + R[4], I = (I = E(I |= 0, P[r])) + x | 0, C = x, x = T, T = E(w, 10), w = A, A = I;
                            I = B[1] + p + T | 0, B[1] = B[2] + S + x | 0, B[2] = B[3] + b + C | 0, B[3] = B[4] + s + A | 0, B[4] = B[0] + a + w | 0, B[0] = I
                        },
                        _doFinalize: function() {
                            var t = this._data,
                                e = t.words,
                                r = 8 * this._nDataBytes,
                                n = 8 * t.sigBytes;
                            e[n >>> 5] |= 128 << 24 - n % 32, e[14 + (n + 64 >>> 9 << 4)] = 16711935 & (r << 8 | r >>> 24) | 4278255360 & (r << 24 | r >>> 8), t.sigBytes = 4 * (e.length + 1), this._process();
                            for (var i = this._hash, s = i.words, a = 0; a < 5; a++) {
                                var o = s[a];
                                s[a] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8)
                            }
                            return i
                        },
                        clone: function() {
                            var t = s.clone.call(this);
                            return t._hash = this._hash.clone(), t
                        }
                    });

                function d(t, e, r) {
                    return t ^ e ^ r
                }

                function g(t, e, r) {
                    return t & e | ~t & r
                }

                function y(t, e, r) {
                    return (t | ~e) ^ r
                }

                function v(t, e, r) {
                    return t & r | e & ~r
                }

                function m(t, e, r) {
                    return t ^ (e | ~r)
                }

                function E(t, e) {
                    return t << e | t >>> 32 - e
                }
                e.RIPEMD160 = s._createHelper(p), e.HmacRIPEMD160 = s._createHmacHelper(p)
            }(Math), n.RIPEMD160)
    }, function(t, e, r) {
        var n, i, s, a, o, u, c, h, l;
        t.exports = (l = r(4), r(149), r(125), i = (n = l).lib, s = i.Base, a = i.WordArray, o = n.algo, u = o.SHA1, c = o.HMAC, h = o.PBKDF2 = s.extend({
            cfg: s.extend({
                keySize: 4,
                hasher: u,
                iterations: 1
            }),
            init: function(t) {
                this.cfg = this.cfg.extend(t)
            },
            compute: function(t, e) {
                for (var r = this.cfg, n = c.create(r.hasher, t), i = a.create(), s = a.create([1]), o = i.words, u = s.words, h = r.keySize, l = r.iterations; o.length < h;) {
                    var f = n.update(e).finalize(s);
                    n.reset();
                    for (var p = f.words, d = p.length, g = f, y = 1; y < l; y++) {
                        g = n.finalize(g), n.reset();
                        for (var v = g.words, m = 0; m < d; m++) p[m] ^= v[m]
                    }
                    i.concat(f), u[0]++
                }
                return i.sigBytes = 4 * h, i
            }
        }), n.PBKDF2 = function(t, e, r) {
            return h.create(r).compute(t, e)
        }, l.PBKDF2)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(18), n.mode.CFB = function() {
            var t = n.lib.BlockCipherMode.extend();

            function e(t, e, r, n) {
                var i, s = this._iv;
                s ? (i = s.slice(0), this._iv = void 0) : i = this._prevBlock, n.encryptBlock(i, 0);
                for (var a = 0; a < r; a++) t[e + a] ^= i[a]
            }
            return t.Encryptor = t.extend({
                processBlock: function(t, r) {
                    var n = this._cipher,
                        i = n.blockSize;
                    e.call(this, t, r, i, n), this._prevBlock = t.slice(r, r + i)
                }
            }), t.Decryptor = t.extend({
                processBlock: function(t, r) {
                    var n = this._cipher,
                        i = n.blockSize,
                        s = t.slice(r, r + i);
                    e.call(this, t, r, i, n), this._prevBlock = s
                }
            }), t
        }(), n.mode.CFB)
    }, function(t, e, r) {
        var n, i, s;
        t.exports = (s = r(4), r(18), s.mode.CTR = (n = s.lib.BlockCipherMode.extend(), i = n.Encryptor = n.extend({
            processBlock: function(t, e) {
                var r = this._cipher,
                    n = r.blockSize,
                    i = this._iv,
                    s = this._counter;
                i && (s = this._counter = i.slice(0), this._iv = void 0);
                var a = s.slice(0);
                r.encryptBlock(a, 0), s[n - 1] = s[n - 1] + 1 | 0;
                for (var o = 0; o < n; o++) t[e + o] ^= a[o]
            }
        }), n.Decryptor = i, n), s.mode.CTR)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(18),
            /** @preserve
             * Counter block mode compatible with  Dr Brian Gladman fileenc.c
             * derived from CryptoJS.mode.CTR
             * Jan Hruby jhruby.web@gmail.com
             */
            n.mode.CTRGladman = function() {
                var t = n.lib.BlockCipherMode.extend();

                function e(t) {
                    if (255 == (t >> 24 & 255)) {
                        var e = t >> 16 & 255,
                            r = t >> 8 & 255,
                            n = 255 & t;
                        255 === e ? (e = 0, 255 === r ? (r = 0, 255 === n ? n = 0 : ++n) : ++r) : ++e, t = 0, t += e << 16, t += r << 8, t += n
                    } else t += 1 << 24;
                    return t
                }
                var r = t.Encryptor = t.extend({
                    processBlock: function(t, r) {
                        var n = this._cipher,
                            i = n.blockSize,
                            s = this._iv,
                            a = this._counter;
                        s && (a = this._counter = s.slice(0), this._iv = void 0),
                            function(t) {
                                0 === (t[0] = e(t[0])) && (t[1] = e(t[1]))
                            }(a);
                        var o = a.slice(0);
                        n.encryptBlock(o, 0);
                        for (var u = 0; u < i; u++) t[r + u] ^= o[u]
                    }
                });
                return t.Decryptor = r, t
            }(), n.mode.CTRGladman)
    }, function(t, e, r) {
        var n, i, s;
        t.exports = (s = r(4), r(18), s.mode.OFB = (n = s.lib.BlockCipherMode.extend(), i = n.Encryptor = n.extend({
            processBlock: function(t, e) {
                var r = this._cipher,
                    n = r.blockSize,
                    i = this._iv,
                    s = this._keystream;
                i && (s = this._keystream = i.slice(0), this._iv = void 0), r.encryptBlock(s, 0);
                for (var a = 0; a < n; a++) t[e + a] ^= s[a]
            }
        }), n.Decryptor = i, n), s.mode.OFB)
    }, function(t, e, r) {
        var n, i;
        t.exports = (i = r(4), r(18), i.mode.ECB = ((n = i.lib.BlockCipherMode.extend()).Encryptor = n.extend({
            processBlock: function(t, e) {
                this._cipher.encryptBlock(t, e)
            }
        }), n.Decryptor = n.extend({
            processBlock: function(t, e) {
                this._cipher.decryptBlock(t, e)
            }
        }), n), i.mode.ECB)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(18), n.pad.AnsiX923 = {
            pad: function(t, e) {
                var r = t.sigBytes,
                    n = 4 * e,
                    i = n - r % n,
                    s = r + i - 1;
                t.clamp(), t.words[s >>> 2] |= i << 24 - s % 4 * 8, t.sigBytes += i
            },
            unpad: function(t) {
                var e = 255 & t.words[t.sigBytes - 1 >>> 2];
                t.sigBytes -= e
            }
        }, n.pad.Ansix923)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(18), n.pad.Iso10126 = {
            pad: function(t, e) {
                var r = 4 * e,
                    i = r - t.sigBytes % r;
                t.concat(n.lib.WordArray.random(i - 1)).concat(n.lib.WordArray.create([i << 24], 1))
            },
            unpad: function(t) {
                var e = 255 & t.words[t.sigBytes - 1 >>> 2];
                t.sigBytes -= e
            }
        }, n.pad.Iso10126)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(18), n.pad.Iso97971 = {
            pad: function(t, e) {
                t.concat(n.lib.WordArray.create([2147483648], 1)), n.pad.ZeroPadding.pad(t, e)
            },
            unpad: function(t) {
                n.pad.ZeroPadding.unpad(t), t.sigBytes--
            }
        }, n.pad.Iso97971)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(18), n.pad.ZeroPadding = {
            pad: function(t, e) {
                var r = 4 * e;
                t.clamp(), t.sigBytes += r - (t.sigBytes % r || r)
            },
            unpad: function(t) {
                var e = t.words,
                    r = t.sigBytes - 1;
                for (r = t.sigBytes - 1; r >= 0; r--)
                    if (e[r >>> 2] >>> 24 - r % 4 * 8 & 255) {
                        t.sigBytes = r + 1;
                        break
                    }
            }
        }, n.pad.ZeroPadding)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(18), n.pad.NoPadding = {
            pad: function() {},
            unpad: function() {}
        }, n.pad.NoPadding)
    }, function(t, e, r) {
        var n, i, s, a;
        t.exports = (a = r(4), r(18), i = (n = a).lib.CipherParams, s = n.enc.Hex, n.format.Hex = {
            stringify: function(t) {
                return t.ciphertext.toString(s)
            },
            parse: function(t) {
                var e = s.parse(t);
                return i.create({
                    ciphertext: e
                })
            }
        }, a.format.Hex)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(49), r(59), r(50), r(18), function() {
            var t = n,
                e = t.lib.BlockCipher,
                r = t.algo,
                i = [],
                s = [],
                a = [],
                o = [],
                u = [],
                c = [],
                h = [],
                l = [],
                f = [],
                p = [];
            ! function() {
                for (var t = [], e = 0; e < 256; e++) t[e] = e < 128 ? e << 1 : e << 1 ^ 283;
                var r = 0,
                    n = 0;
                for (e = 0; e < 256; e++) {
                    var d = n ^ n << 1 ^ n << 2 ^ n << 3 ^ n << 4;
                    d = d >>> 8 ^ 255 & d ^ 99, i[r] = d, s[d] = r;
                    var g = t[r],
                        y = t[g],
                        v = t[y],
                        m = 257 * t[d] ^ 16843008 * d;
                    a[r] = m << 24 | m >>> 8, o[r] = m << 16 | m >>> 16, u[r] = m << 8 | m >>> 24, c[r] = m, m = 16843009 * v ^ 65537 * y ^ 257 * g ^ 16843008 * r, h[d] = m << 24 | m >>> 8, l[d] = m << 16 | m >>> 16, f[d] = m << 8 | m >>> 24, p[d] = m, r ? (r = g ^ t[t[t[v ^ g]]], n ^= t[t[n]]) : r = n = 1
                }
            }();
            var d = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
                g = r.AES = e.extend({
                    _doReset: function() {
                        if (!this._nRounds || this._keyPriorReset !== this._key) {
                            for (var t = this._keyPriorReset = this._key, e = t.words, r = t.sigBytes / 4, n = 4 * ((this._nRounds = r + 6) + 1), s = this._keySchedule = [], a = 0; a < n; a++) a < r ? s[a] = e[a] : (c = s[a - 1], a % r ? r > 6 && a % r == 4 && (c = i[c >>> 24] << 24 | i[c >>> 16 & 255] << 16 | i[c >>> 8 & 255] << 8 | i[255 & c]) : (c = i[(c = c << 8 | c >>> 24) >>> 24] << 24 | i[c >>> 16 & 255] << 16 | i[c >>> 8 & 255] << 8 | i[255 & c], c ^= d[a / r | 0] << 24), s[a] = s[a - r] ^ c);
                            for (var o = this._invKeySchedule = [], u = 0; u < n; u++) {
                                if (a = n - u, u % 4) var c = s[a];
                                else c = s[a - 4];
                                o[u] = u < 4 || a <= 4 ? c : h[i[c >>> 24]] ^ l[i[c >>> 16 & 255]] ^ f[i[c >>> 8 & 255]] ^ p[i[255 & c]]
                            }
                        }
                    },
                    encryptBlock: function(t, e) {
                        this._doCryptBlock(t, e, this._keySchedule, a, o, u, c, i)
                    },
                    decryptBlock: function(t, e) {
                        var r = t[e + 1];
                        t[e + 1] = t[e + 3], t[e + 3] = r, this._doCryptBlock(t, e, this._invKeySchedule, h, l, f, p, s), r = t[e + 1], t[e + 1] = t[e + 3], t[e + 3] = r
                    },
                    _doCryptBlock: function(t, e, r, n, i, s, a, o) {
                        for (var u = this._nRounds, c = t[e] ^ r[0], h = t[e + 1] ^ r[1], l = t[e + 2] ^ r[2], f = t[e + 3] ^ r[3], p = 4, d = 1; d < u; d++) {
                            var g = n[c >>> 24] ^ i[h >>> 16 & 255] ^ s[l >>> 8 & 255] ^ a[255 & f] ^ r[p++],
                                y = n[h >>> 24] ^ i[l >>> 16 & 255] ^ s[f >>> 8 & 255] ^ a[255 & c] ^ r[p++],
                                v = n[l >>> 24] ^ i[f >>> 16 & 255] ^ s[c >>> 8 & 255] ^ a[255 & h] ^ r[p++],
                                m = n[f >>> 24] ^ i[c >>> 16 & 255] ^ s[h >>> 8 & 255] ^ a[255 & l] ^ r[p++];
                            c = g, h = y, l = v, f = m
                        }
                        g = (o[c >>> 24] << 24 | o[h >>> 16 & 255] << 16 | o[l >>> 8 & 255] << 8 | o[255 & f]) ^ r[p++], y = (o[h >>> 24] << 24 | o[l >>> 16 & 255] << 16 | o[f >>> 8 & 255] << 8 | o[255 & c]) ^ r[p++], v = (o[l >>> 24] << 24 | o[f >>> 16 & 255] << 16 | o[c >>> 8 & 255] << 8 | o[255 & h]) ^ r[p++], m = (o[f >>> 24] << 24 | o[c >>> 16 & 255] << 16 | o[h >>> 8 & 255] << 8 | o[255 & l]) ^ r[p++], t[e] = g, t[e + 1] = y, t[e + 2] = v, t[e + 3] = m
                    },
                    keySize: 8
                });
            t.AES = e._createHelper(g)
        }(), n.AES)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(49), r(59), r(50), r(18), function() {
            var t = n,
                e = t.lib,
                r = e.WordArray,
                i = e.BlockCipher,
                s = t.algo,
                a = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4],
                o = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32],
                u = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
                c = [{
                    0: 8421888,
                    268435456: 32768,
                    536870912: 8421378,
                    805306368: 2,
                    1073741824: 512,
                    1342177280: 8421890,
                    1610612736: 8389122,
                    1879048192: 8388608,
                    2147483648: 514,
                    2415919104: 8389120,
                    2684354560: 33280,
                    2952790016: 8421376,
                    3221225472: 32770,
                    3489660928: 8388610,
                    3758096384: 0,
                    4026531840: 33282,
                    134217728: 0,
                    402653184: 8421890,
                    671088640: 33282,
                    939524096: 32768,
                    1207959552: 8421888,
                    1476395008: 512,
                    1744830464: 8421378,
                    2013265920: 2,
                    2281701376: 8389120,
                    2550136832: 33280,
                    2818572288: 8421376,
                    3087007744: 8389122,
                    3355443200: 8388610,
                    3623878656: 32770,
                    3892314112: 514,
                    4160749568: 8388608,
                    1: 32768,
                    268435457: 2,
                    536870913: 8421888,
                    805306369: 8388608,
                    1073741825: 8421378,
                    1342177281: 33280,
                    1610612737: 512,
                    1879048193: 8389122,
                    2147483649: 8421890,
                    2415919105: 8421376,
                    2684354561: 8388610,
                    2952790017: 33282,
                    3221225473: 514,
                    3489660929: 8389120,
                    3758096385: 32770,
                    4026531841: 0,
                    134217729: 8421890,
                    402653185: 8421376,
                    671088641: 8388608,
                    939524097: 512,
                    1207959553: 32768,
                    1476395009: 8388610,
                    1744830465: 2,
                    2013265921: 33282,
                    2281701377: 32770,
                    2550136833: 8389122,
                    2818572289: 514,
                    3087007745: 8421888,
                    3355443201: 8389120,
                    3623878657: 0,
                    3892314113: 33280,
                    4160749569: 8421378
                }, {
                    0: 1074282512,
                    16777216: 16384,
                    33554432: 524288,
                    50331648: 1074266128,
                    67108864: 1073741840,
                    83886080: 1074282496,
                    100663296: 1073758208,
                    117440512: 16,
                    134217728: 540672,
                    150994944: 1073758224,
                    167772160: 1073741824,
                    184549376: 540688,
                    201326592: 524304,
                    218103808: 0,
                    234881024: 16400,
                    251658240: 1074266112,
                    8388608: 1073758208,
                    25165824: 540688,
                    41943040: 16,
                    58720256: 1073758224,
                    75497472: 1074282512,
                    92274688: 1073741824,
                    109051904: 524288,
                    125829120: 1074266128,
                    142606336: 524304,
                    159383552: 0,
                    176160768: 16384,
                    192937984: 1074266112,
                    209715200: 1073741840,
                    226492416: 540672,
                    243269632: 1074282496,
                    260046848: 16400,
                    268435456: 0,
                    285212672: 1074266128,
                    301989888: 1073758224,
                    318767104: 1074282496,
                    335544320: 1074266112,
                    352321536: 16,
                    369098752: 540688,
                    385875968: 16384,
                    402653184: 16400,
                    419430400: 524288,
                    436207616: 524304,
                    452984832: 1073741840,
                    469762048: 540672,
                    486539264: 1073758208,
                    503316480: 1073741824,
                    520093696: 1074282512,
                    276824064: 540688,
                    293601280: 524288,
                    310378496: 1074266112,
                    327155712: 16384,
                    343932928: 1073758208,
                    360710144: 1074282512,
                    377487360: 16,
                    394264576: 1073741824,
                    411041792: 1074282496,
                    427819008: 1073741840,
                    444596224: 1073758224,
                    461373440: 524304,
                    478150656: 0,
                    494927872: 16400,
                    511705088: 1074266128,
                    528482304: 540672
                }, {
                    0: 260,
                    1048576: 0,
                    2097152: 67109120,
                    3145728: 65796,
                    4194304: 65540,
                    5242880: 67108868,
                    6291456: 67174660,
                    7340032: 67174400,
                    8388608: 67108864,
                    9437184: 67174656,
                    10485760: 65792,
                    11534336: 67174404,
                    12582912: 67109124,
                    13631488: 65536,
                    14680064: 4,
                    15728640: 256,
                    524288: 67174656,
                    1572864: 67174404,
                    2621440: 0,
                    3670016: 67109120,
                    4718592: 67108868,
                    5767168: 65536,
                    6815744: 65540,
                    7864320: 260,
                    8912896: 4,
                    9961472: 256,
                    11010048: 67174400,
                    12058624: 65796,
                    13107200: 65792,
                    14155776: 67109124,
                    15204352: 67174660,
                    16252928: 67108864,
                    16777216: 67174656,
                    17825792: 65540,
                    18874368: 65536,
                    19922944: 67109120,
                    20971520: 256,
                    22020096: 67174660,
                    23068672: 67108868,
                    24117248: 0,
                    25165824: 67109124,
                    26214400: 67108864,
                    27262976: 4,
                    28311552: 65792,
                    29360128: 67174400,
                    30408704: 260,
                    31457280: 65796,
                    32505856: 67174404,
                    17301504: 67108864,
                    18350080: 260,
                    19398656: 67174656,
                    20447232: 0,
                    21495808: 65540,
                    22544384: 67109120,
                    23592960: 256,
                    24641536: 67174404,
                    25690112: 65536,
                    26738688: 67174660,
                    27787264: 65796,
                    28835840: 67108868,
                    29884416: 67109124,
                    30932992: 67174400,
                    31981568: 4,
                    33030144: 65792
                }, {
                    0: 2151682048,
                    65536: 2147487808,
                    131072: 4198464,
                    196608: 2151677952,
                    262144: 0,
                    327680: 4198400,
                    393216: 2147483712,
                    458752: 4194368,
                    524288: 2147483648,
                    589824: 4194304,
                    655360: 64,
                    720896: 2147487744,
                    786432: 2151678016,
                    851968: 4160,
                    917504: 4096,
                    983040: 2151682112,
                    32768: 2147487808,
                    98304: 64,
                    163840: 2151678016,
                    229376: 2147487744,
                    294912: 4198400,
                    360448: 2151682112,
                    425984: 0,
                    491520: 2151677952,
                    557056: 4096,
                    622592: 2151682048,
                    688128: 4194304,
                    753664: 4160,
                    819200: 2147483648,
                    884736: 4194368,
                    950272: 4198464,
                    1015808: 2147483712,
                    1048576: 4194368,
                    1114112: 4198400,
                    1179648: 2147483712,
                    1245184: 0,
                    1310720: 4160,
                    1376256: 2151678016,
                    1441792: 2151682048,
                    1507328: 2147487808,
                    1572864: 2151682112,
                    1638400: 2147483648,
                    1703936: 2151677952,
                    1769472: 4198464,
                    1835008: 2147487744,
                    1900544: 4194304,
                    1966080: 64,
                    2031616: 4096,
                    1081344: 2151677952,
                    1146880: 2151682112,
                    1212416: 0,
                    1277952: 4198400,
                    1343488: 4194368,
                    1409024: 2147483648,
                    1474560: 2147487808,
                    1540096: 64,
                    1605632: 2147483712,
                    1671168: 4096,
                    1736704: 2147487744,
                    1802240: 2151678016,
                    1867776: 4160,
                    1933312: 2151682048,
                    1998848: 4194304,
                    2064384: 4198464
                }, {
                    0: 128,
                    4096: 17039360,
                    8192: 262144,
                    12288: 536870912,
                    16384: 537133184,
                    20480: 16777344,
                    24576: 553648256,
                    28672: 262272,
                    32768: 16777216,
                    36864: 537133056,
                    40960: 536871040,
                    45056: 553910400,
                    49152: 553910272,
                    53248: 0,
                    57344: 17039488,
                    61440: 553648128,
                    2048: 17039488,
                    6144: 553648256,
                    10240: 128,
                    14336: 17039360,
                    18432: 262144,
                    22528: 537133184,
                    26624: 553910272,
                    30720: 536870912,
                    34816: 537133056,
                    38912: 0,
                    43008: 553910400,
                    47104: 16777344,
                    51200: 536871040,
                    55296: 553648128,
                    59392: 16777216,
                    63488: 262272,
                    65536: 262144,
                    69632: 128,
                    73728: 536870912,
                    77824: 553648256,
                    81920: 16777344,
                    86016: 553910272,
                    90112: 537133184,
                    94208: 16777216,
                    98304: 553910400,
                    102400: 553648128,
                    106496: 17039360,
                    110592: 537133056,
                    114688: 262272,
                    118784: 536871040,
                    122880: 0,
                    126976: 17039488,
                    67584: 553648256,
                    71680: 16777216,
                    75776: 17039360,
                    79872: 537133184,
                    83968: 536870912,
                    88064: 17039488,
                    92160: 128,
                    96256: 553910272,
                    100352: 262272,
                    104448: 553910400,
                    108544: 0,
                    112640: 553648128,
                    116736: 16777344,
                    120832: 262144,
                    124928: 537133056,
                    129024: 536871040
                }, {
                    0: 268435464,
                    256: 8192,
                    512: 270532608,
                    768: 270540808,
                    1024: 268443648,
                    1280: 2097152,
                    1536: 2097160,
                    1792: 268435456,
                    2048: 0,
                    2304: 268443656,
                    2560: 2105344,
                    2816: 8,
                    3072: 270532616,
                    3328: 2105352,
                    3584: 8200,
                    3840: 270540800,
                    128: 270532608,
                    384: 270540808,
                    640: 8,
                    896: 2097152,
                    1152: 2105352,
                    1408: 268435464,
                    1664: 268443648,
                    1920: 8200,
                    2176: 2097160,
                    2432: 8192,
                    2688: 268443656,
                    2944: 270532616,
                    3200: 0,
                    3456: 270540800,
                    3712: 2105344,
                    3968: 268435456,
                    4096: 268443648,
                    4352: 270532616,
                    4608: 270540808,
                    4864: 8200,
                    5120: 2097152,
                    5376: 268435456,
                    5632: 268435464,
                    5888: 2105344,
                    6144: 2105352,
                    6400: 0,
                    6656: 8,
                    6912: 270532608,
                    7168: 8192,
                    7424: 268443656,
                    7680: 270540800,
                    7936: 2097160,
                    4224: 8,
                    4480: 2105344,
                    4736: 2097152,
                    4992: 268435464,
                    5248: 268443648,
                    5504: 8200,
                    5760: 270540808,
                    6016: 270532608,
                    6272: 270540800,
                    6528: 270532616,
                    6784: 8192,
                    7040: 2105352,
                    7296: 2097160,
                    7552: 0,
                    7808: 268435456,
                    8064: 268443656
                }, {
                    0: 1048576,
                    16: 33555457,
                    32: 1024,
                    48: 1049601,
                    64: 34604033,
                    80: 0,
                    96: 1,
                    112: 34603009,
                    128: 33555456,
                    144: 1048577,
                    160: 33554433,
                    176: 34604032,
                    192: 34603008,
                    208: 1025,
                    224: 1049600,
                    240: 33554432,
                    8: 34603009,
                    24: 0,
                    40: 33555457,
                    56: 34604032,
                    72: 1048576,
                    88: 33554433,
                    104: 33554432,
                    120: 1025,
                    136: 1049601,
                    152: 33555456,
                    168: 34603008,
                    184: 1048577,
                    200: 1024,
                    216: 34604033,
                    232: 1,
                    248: 1049600,
                    256: 33554432,
                    272: 1048576,
                    288: 33555457,
                    304: 34603009,
                    320: 1048577,
                    336: 33555456,
                    352: 34604032,
                    368: 1049601,
                    384: 1025,
                    400: 34604033,
                    416: 1049600,
                    432: 1,
                    448: 0,
                    464: 34603008,
                    480: 33554433,
                    496: 1024,
                    264: 1049600,
                    280: 33555457,
                    296: 34603009,
                    312: 1,
                    328: 33554432,
                    344: 1048576,
                    360: 1025,
                    376: 34604032,
                    392: 33554433,
                    408: 34603008,
                    424: 0,
                    440: 34604033,
                    456: 1049601,
                    472: 1024,
                    488: 33555456,
                    504: 1048577
                }, {
                    0: 134219808,
                    1: 131072,
                    2: 134217728,
                    3: 32,
                    4: 131104,
                    5: 134350880,
                    6: 134350848,
                    7: 2048,
                    8: 134348800,
                    9: 134219776,
                    10: 133120,
                    11: 134348832,
                    12: 2080,
                    13: 0,
                    14: 134217760,
                    15: 133152,
                    2147483648: 2048,
                    2147483649: 134350880,
                    2147483650: 134219808,
                    2147483651: 134217728,
                    2147483652: 134348800,
                    2147483653: 133120,
                    2147483654: 133152,
                    2147483655: 32,
                    2147483656: 134217760,
                    2147483657: 2080,
                    2147483658: 131104,
                    2147483659: 134350848,
                    2147483660: 0,
                    2147483661: 134348832,
                    2147483662: 134219776,
                    2147483663: 131072,
                    16: 133152,
                    17: 134350848,
                    18: 32,
                    19: 2048,
                    20: 134219776,
                    21: 134217760,
                    22: 134348832,
                    23: 131072,
                    24: 0,
                    25: 131104,
                    26: 134348800,
                    27: 134219808,
                    28: 134350880,
                    29: 133120,
                    30: 2080,
                    31: 134217728,
                    2147483664: 131072,
                    2147483665: 2048,
                    2147483666: 134348832,
                    2147483667: 133152,
                    2147483668: 32,
                    2147483669: 134348800,
                    2147483670: 134217728,
                    2147483671: 134219808,
                    2147483672: 134350880,
                    2147483673: 134217760,
                    2147483674: 134219776,
                    2147483675: 0,
                    2147483676: 133120,
                    2147483677: 2080,
                    2147483678: 131104,
                    2147483679: 134350848
                }],
                h = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679],
                l = s.DES = i.extend({
                    _doReset: function() {
                        for (var t = this._key.words, e = [], r = 0; r < 56; r++) {
                            var n = a[r] - 1;
                            e[r] = t[n >>> 5] >>> 31 - n % 32 & 1
                        }
                        for (var i = this._subKeys = [], s = 0; s < 16; s++) {
                            var c = i[s] = [],
                                h = u[s];
                            for (r = 0; r < 24; r++) c[r / 6 | 0] |= e[(o[r] - 1 + h) % 28] << 31 - r % 6, c[4 + (r / 6 | 0)] |= e[28 + (o[r + 24] - 1 + h) % 28] << 31 - r % 6;
                            for (c[0] = c[0] << 1 | c[0] >>> 31, r = 1; r < 7; r++) c[r] = c[r] >>> 4 * (r - 1) + 3;
                            c[7] = c[7] << 5 | c[7] >>> 27
                        }
                        var l = this._invSubKeys = [];
                        for (r = 0; r < 16; r++) l[r] = i[15 - r]
                    },
                    encryptBlock: function(t, e) {
                        this._doCryptBlock(t, e, this._subKeys)
                    },
                    decryptBlock: function(t, e) {
                        this._doCryptBlock(t, e, this._invSubKeys)
                    },
                    _doCryptBlock: function(t, e, r) {
                        this._lBlock = t[e], this._rBlock = t[e + 1], f.call(this, 4, 252645135), f.call(this, 16, 65535), p.call(this, 2, 858993459), p.call(this, 8, 16711935), f.call(this, 1, 1431655765);
                        for (var n = 0; n < 16; n++) {
                            for (var i = r[n], s = this._lBlock, a = this._rBlock, o = 0, u = 0; u < 8; u++) o |= c[u][((a ^ i[u]) & h[u]) >>> 0];
                            this._lBlock = a, this._rBlock = s ^ o
                        }
                        var l = this._lBlock;
                        this._lBlock = this._rBlock, this._rBlock = l, f.call(this, 1, 1431655765), p.call(this, 8, 16711935), p.call(this, 2, 858993459), f.call(this, 16, 65535), f.call(this, 4, 252645135), t[e] = this._lBlock, t[e + 1] = this._rBlock
                    },
                    keySize: 2,
                    ivSize: 2,
                    blockSize: 2
                });

            function f(t, e) {
                var r = (this._lBlock >>> t ^ this._rBlock) & e;
                this._rBlock ^= r, this._lBlock ^= r << t
            }

            function p(t, e) {
                var r = (this._rBlock >>> t ^ this._lBlock) & e;
                this._lBlock ^= r, this._rBlock ^= r << t
            }
            t.DES = i._createHelper(l);
            var d = s.TripleDES = i.extend({
                _doReset: function() {
                    var t = this._key.words;
                    if (2 !== t.length && 4 !== t.length && t.length < 6) throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                    var e = t.slice(0, 2),
                        n = t.length < 4 ? t.slice(0, 2) : t.slice(2, 4),
                        i = t.length < 6 ? t.slice(0, 2) : t.slice(4, 6);
                    this._des1 = l.createEncryptor(r.create(e)), this._des2 = l.createEncryptor(r.create(n)), this._des3 = l.createEncryptor(r.create(i))
                },
                encryptBlock: function(t, e) {
                    this._des1.encryptBlock(t, e), this._des2.decryptBlock(t, e), this._des3.encryptBlock(t, e)
                },
                decryptBlock: function(t, e) {
                    this._des3.decryptBlock(t, e), this._des2.encryptBlock(t, e), this._des1.decryptBlock(t, e)
                },
                keySize: 6,
                ivSize: 2,
                blockSize: 2
            });
            t.TripleDES = i._createHelper(d)
        }(), n.TripleDES)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(49), r(59), r(50), r(18), function() {
            var t = n,
                e = t.lib.StreamCipher,
                r = t.algo,
                i = r.RC4 = e.extend({
                    _doReset: function() {
                        for (var t = this._key, e = t.words, r = t.sigBytes, n = this._S = [], i = 0; i < 256; i++) n[i] = i;
                        i = 0;
                        for (var s = 0; i < 256; i++) {
                            var a = i % r,
                                o = e[a >>> 2] >>> 24 - a % 4 * 8 & 255;
                            s = (s + n[i] + o) % 256;
                            var u = n[i];
                            n[i] = n[s], n[s] = u
                        }
                        this._i = this._j = 0
                    },
                    _doProcessBlock: function(t, e) {
                        t[e] ^= s.call(this)
                    },
                    keySize: 8,
                    ivSize: 0
                });

            function s() {
                for (var t = this._S, e = this._i, r = this._j, n = 0, i = 0; i < 4; i++) {
                    r = (r + t[e = (e + 1) % 256]) % 256;
                    var s = t[e];
                    t[e] = t[r], t[r] = s, n |= t[(t[e] + t[r]) % 256] << 24 - 8 * i
                }
                return this._i = e, this._j = r, n
            }
            t.RC4 = e._createHelper(i);
            var a = r.RC4Drop = i.extend({
                cfg: i.cfg.extend({
                    drop: 192
                }),
                _doReset: function() {
                    i._doReset.call(this);
                    for (var t = this.cfg.drop; t > 0; t--) s.call(this)
                }
            });
            t.RC4Drop = e._createHelper(a)
        }(), n.RC4)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(49), r(59), r(50), r(18), function() {
            var t = n,
                e = t.lib.StreamCipher,
                r = t.algo,
                i = [],
                s = [],
                a = [],
                o = r.Rabbit = e.extend({
                    _doReset: function() {
                        for (var t = this._key.words, e = this.cfg.iv, r = 0; r < 4; r++) t[r] = 16711935 & (t[r] << 8 | t[r] >>> 24) | 4278255360 & (t[r] << 24 | t[r] >>> 8);
                        var n = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16],
                            i = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]];
                        for (this._b = 0, r = 0; r < 4; r++) u.call(this);
                        for (r = 0; r < 8; r++) i[r] ^= n[r + 4 & 7];
                        if (e) {
                            var s = e.words,
                                a = s[0],
                                o = s[1],
                                c = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8),
                                h = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8),
                                l = c >>> 16 | 4294901760 & h,
                                f = h << 16 | 65535 & c;
                            for (i[0] ^= c, i[1] ^= l, i[2] ^= h, i[3] ^= f, i[4] ^= c, i[5] ^= l, i[6] ^= h, i[7] ^= f, r = 0; r < 4; r++) u.call(this)
                        }
                    },
                    _doProcessBlock: function(t, e) {
                        var r = this._X;
                        u.call(this), i[0] = r[0] ^ r[5] >>> 16 ^ r[3] << 16, i[1] = r[2] ^ r[7] >>> 16 ^ r[5] << 16, i[2] = r[4] ^ r[1] >>> 16 ^ r[7] << 16, i[3] = r[6] ^ r[3] >>> 16 ^ r[1] << 16;
                        for (var n = 0; n < 4; n++) i[n] = 16711935 & (i[n] << 8 | i[n] >>> 24) | 4278255360 & (i[n] << 24 | i[n] >>> 8), t[e + n] ^= i[n]
                    },
                    blockSize: 4,
                    ivSize: 2
                });

            function u() {
                for (var t = this._X, e = this._C, r = 0; r < 8; r++) s[r] = e[r];
                for (e[0] = e[0] + 1295307597 + this._b | 0, e[1] = e[1] + 3545052371 + (e[0] >>> 0 < s[0] >>> 0 ? 1 : 0) | 0, e[2] = e[2] + 886263092 + (e[1] >>> 0 < s[1] >>> 0 ? 1 : 0) | 0, e[3] = e[3] + 1295307597 + (e[2] >>> 0 < s[2] >>> 0 ? 1 : 0) | 0, e[4] = e[4] + 3545052371 + (e[3] >>> 0 < s[3] >>> 0 ? 1 : 0) | 0, e[5] = e[5] + 886263092 + (e[4] >>> 0 < s[4] >>> 0 ? 1 : 0) | 0, e[6] = e[6] + 1295307597 + (e[5] >>> 0 < s[5] >>> 0 ? 1 : 0) | 0, e[7] = e[7] + 3545052371 + (e[6] >>> 0 < s[6] >>> 0 ? 1 : 0) | 0, this._b = e[7] >>> 0 < s[7] >>> 0 ? 1 : 0, r = 0; r < 8; r++) {
                    var n = t[r] + e[r],
                        i = 65535 & n,
                        o = n >>> 16,
                        u = ((i * i >>> 17) + i * o >>> 15) + o * o,
                        c = ((4294901760 & n) * n | 0) + ((65535 & n) * n | 0);
                    a[r] = u ^ c
                }
                t[0] = a[0] + (a[7] << 16 | a[7] >>> 16) + (a[6] << 16 | a[6] >>> 16) | 0, t[1] = a[1] + (a[0] << 8 | a[0] >>> 24) + a[7] | 0, t[2] = a[2] + (a[1] << 16 | a[1] >>> 16) + (a[0] << 16 | a[0] >>> 16) | 0, t[3] = a[3] + (a[2] << 8 | a[2] >>> 24) + a[1] | 0, t[4] = a[4] + (a[3] << 16 | a[3] >>> 16) + (a[2] << 16 | a[2] >>> 16) | 0, t[5] = a[5] + (a[4] << 8 | a[4] >>> 24) + a[3] | 0, t[6] = a[6] + (a[5] << 16 | a[5] >>> 16) + (a[4] << 16 | a[4] >>> 16) | 0, t[7] = a[7] + (a[6] << 8 | a[6] >>> 24) + a[5] | 0
            }
            t.Rabbit = e._createHelper(o)
        }(), n.Rabbit)
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(49), r(59), r(50), r(18), function() {
            var t = n,
                e = t.lib.StreamCipher,
                r = t.algo,
                i = [],
                s = [],
                a = [],
                o = r.RabbitLegacy = e.extend({
                    _doReset: function() {
                        var t = this._key.words,
                            e = this.cfg.iv,
                            r = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16],
                            n = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]];
                        this._b = 0;
                        for (var i = 0; i < 4; i++) u.call(this);
                        for (i = 0; i < 8; i++) n[i] ^= r[i + 4 & 7];
                        if (e) {
                            var s = e.words,
                                a = s[0],
                                o = s[1],
                                c = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8),
                                h = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8),
                                l = c >>> 16 | 4294901760 & h,
                                f = h << 16 | 65535 & c;
                            for (n[0] ^= c, n[1] ^= l, n[2] ^= h, n[3] ^= f, n[4] ^= c, n[5] ^= l, n[6] ^= h, n[7] ^= f, i = 0; i < 4; i++) u.call(this)
                        }
                    },
                    _doProcessBlock: function(t, e) {
                        var r = this._X;
                        u.call(this), i[0] = r[0] ^ r[5] >>> 16 ^ r[3] << 16, i[1] = r[2] ^ r[7] >>> 16 ^ r[5] << 16, i[2] = r[4] ^ r[1] >>> 16 ^ r[7] << 16, i[3] = r[6] ^ r[3] >>> 16 ^ r[1] << 16;
                        for (var n = 0; n < 4; n++) i[n] = 16711935 & (i[n] << 8 | i[n] >>> 24) | 4278255360 & (i[n] << 24 | i[n] >>> 8), t[e + n] ^= i[n]
                    },
                    blockSize: 4,
                    ivSize: 2
                });

            function u() {
                for (var t = this._X, e = this._C, r = 0; r < 8; r++) s[r] = e[r];
                for (e[0] = e[0] + 1295307597 + this._b | 0, e[1] = e[1] + 3545052371 + (e[0] >>> 0 < s[0] >>> 0 ? 1 : 0) | 0, e[2] = e[2] + 886263092 + (e[1] >>> 0 < s[1] >>> 0 ? 1 : 0) | 0, e[3] = e[3] + 1295307597 + (e[2] >>> 0 < s[2] >>> 0 ? 1 : 0) | 0, e[4] = e[4] + 3545052371 + (e[3] >>> 0 < s[3] >>> 0 ? 1 : 0) | 0, e[5] = e[5] + 886263092 + (e[4] >>> 0 < s[4] >>> 0 ? 1 : 0) | 0, e[6] = e[6] + 1295307597 + (e[5] >>> 0 < s[5] >>> 0 ? 1 : 0) | 0, e[7] = e[7] + 3545052371 + (e[6] >>> 0 < s[6] >>> 0 ? 1 : 0) | 0, this._b = e[7] >>> 0 < s[7] >>> 0 ? 1 : 0, r = 0; r < 8; r++) {
                    var n = t[r] + e[r],
                        i = 65535 & n,
                        o = n >>> 16,
                        u = ((i * i >>> 17) + i * o >>> 15) + o * o,
                        c = ((4294901760 & n) * n | 0) + ((65535 & n) * n | 0);
                    a[r] = u ^ c
                }
                t[0] = a[0] + (a[7] << 16 | a[7] >>> 16) + (a[6] << 16 | a[6] >>> 16) | 0, t[1] = a[1] + (a[0] << 8 | a[0] >>> 24) + a[7] | 0, t[2] = a[2] + (a[1] << 16 | a[1] >>> 16) + (a[0] << 16 | a[0] >>> 16) | 0, t[3] = a[3] + (a[2] << 8 | a[2] >>> 24) + a[1] | 0, t[4] = a[4] + (a[3] << 16 | a[3] >>> 16) + (a[2] << 16 | a[2] >>> 16) | 0, t[5] = a[5] + (a[4] << 8 | a[4] >>> 24) + a[3] | 0, t[6] = a[6] + (a[5] << 16 | a[5] >>> 16) + (a[4] << 16 | a[4] >>> 16) | 0, t[7] = a[7] + (a[6] << 8 | a[6] >>> 24) + a[5] | 0
            }
            t.RabbitLegacy = e._createHelper(o)
        }(), n.RabbitLegacy)
    }, function(t, e, r) {
        (function(t) {
            var n = void 0 !== t && t || "undefined" != typeof self && self || window,
                i = Function.prototype.apply;

            function s(t, e) {
                this._id = t, this._clearFn = e
            }
            e.setTimeout = function() {
                return new s(i.call(setTimeout, n, arguments), clearTimeout)
            }, e.setInterval = function() {
                return new s(i.call(setInterval, n, arguments), clearInterval)
            }, e.clearTimeout = e.clearInterval = function(t) {
                t && t.close()
            }, s.prototype.unref = s.prototype.ref = function() {}, s.prototype.close = function() {
                this._clearFn.call(n, this._id)
            }, e.enroll = function(t, e) {
                clearTimeout(t._idleTimeoutId), t._idleTimeout = e
            }, e.unenroll = function(t) {
                clearTimeout(t._idleTimeoutId), t._idleTimeout = -1
            }, e._unrefActive = e.active = function(t) {
                clearTimeout(t._idleTimeoutId);
                var e = t._idleTimeout;
                e >= 0 && (t._idleTimeoutId = setTimeout((function() {
                    t._onTimeout && t._onTimeout()
                }), e))
            }, r(251), e.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== t && t.setImmediate || this && this.setImmediate, e.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== t && t.clearImmediate || this && this.clearImmediate
        }).call(this, r(52))
    }, function(t, e, r) {
        (function(t, e) {
            ! function(t, r) {
                "use strict";
                if (!t.setImmediate) {
                    var n, i, s, a, o, u = 1,
                        c = {},
                        h = !1,
                        l = t.document,
                        f = Object.getPrototypeOf && Object.getPrototypeOf(t);
                    f = f && f.setTimeout ? f : t, "[object process]" === {}.toString.call(t.process) ? n = function(t) {
                        e.nextTick((function() {
                            d(t)
                        }))
                    } : ! function() {
                        if (t.postMessage && !t.importScripts) {
                            var e = !0,
                                r = t.onmessage;
                            return t.onmessage = function() {
                                e = !1
                            }, t.postMessage("", "*"), t.onmessage = r, e
                        }
                    }() ? t.MessageChannel ? ((s = new MessageChannel).port1.onmessage = function(t) {
                        d(t.data)
                    }, n = function(t) {
                        s.port2.postMessage(t)
                    }) : l && "onreadystatechange" in l.createElement("script") ? (i = l.documentElement, n = function(t) {
                        var e = l.createElement("script");
                        e.onreadystatechange = function() {
                            d(t), e.onreadystatechange = null, i.removeChild(e), e = null
                        }, i.appendChild(e)
                    }) : n = function(t) {
                        setTimeout(d, 0, t)
                    } : (a = "setImmediate$" + Math.random() + "$", o = function(e) {
                        e.source === t && "string" == typeof e.data && 0 === e.data.indexOf(a) && d(+e.data.slice(a.length))
                    }, t.addEventListener ? t.addEventListener("message", o, !1) : t.attachEvent("onmessage", o), n = function(e) {
                        t.postMessage(a + e, "*")
                    }), f.setImmediate = function(t) {
                        "function" != typeof t && (t = new Function("" + t));
                        for (var e = new Array(arguments.length - 1), r = 0; r < e.length; r++) e[r] = arguments[r + 1];
                        var i = {
                            callback: t,
                            args: e
                        };
                        return c[u] = i, n(u), u++
                    }, f.clearImmediate = p
                }

                function p(t) {
                    delete c[t]
                }

                function d(t) {
                    if (h) setTimeout(d, 0, t);
                    else {
                        var e = c[t];
                        if (e) {
                            h = !0;
                            try {
                                ! function(t) {
                                    var e = t.callback,
                                        r = t.args;
                                    switch (r.length) {
                                        case 0:
                                            e();
                                            break;
                                        case 1:
                                            e(r[0]);
                                            break;
                                        case 2:
                                            e(r[0], r[1]);
                                            break;
                                        case 3:
                                            e(r[0], r[1], r[2]);
                                            break;
                                        default:
                                            e.apply(void 0, r)
                                    }
                                }(e)
                            } finally {
                                p(t), h = !1
                            }
                        }
                    }
                }
            }("undefined" == typeof self ? void 0 === t ? this : t : self)
        }).call(this, r(52), r(151))
    }, function(t, e, r) {
        "use strict";
        e.byteLength = function(t) {
            var e = c(t),
                r = e[0],
                n = e[1];
            return 3 * (r + n) / 4 - n
        }, e.toByteArray = function(t) {
            var e, r, n = c(t),
                a = n[0],
                o = n[1],
                u = new s(function(t, e, r) {
                    return 3 * (e + r) / 4 - r
                }(0, a, o)),
                h = 0,
                l = o > 0 ? a - 4 : a;
            for (r = 0; r < l; r += 4) e = i[t.charCodeAt(r)] << 18 | i[t.charCodeAt(r + 1)] << 12 | i[t.charCodeAt(r + 2)] << 6 | i[t.charCodeAt(r + 3)], u[h++] = e >> 16 & 255, u[h++] = e >> 8 & 255, u[h++] = 255 & e;
            2 === o && (e = i[t.charCodeAt(r)] << 2 | i[t.charCodeAt(r + 1)] >> 4, u[h++] = 255 & e);
            1 === o && (e = i[t.charCodeAt(r)] << 10 | i[t.charCodeAt(r + 1)] << 4 | i[t.charCodeAt(r + 2)] >> 2, u[h++] = e >> 8 & 255, u[h++] = 255 & e);
            return u
        }, e.fromByteArray = function(t) {
            for (var e, r = t.length, i = r % 3, s = [], a = 0, o = r - i; a < o; a += 16383) s.push(h(t, a, a + 16383 > o ? o : a + 16383));
            1 === i ? (e = t[r - 1], s.push(n[e >> 2] + n[e << 4 & 63] + "==")) : 2 === i && (e = (t[r - 2] << 8) + t[r - 1], s.push(n[e >> 10] + n[e >> 4 & 63] + n[e << 2 & 63] + "="));
            return s.join("")
        };
        for (var n = [], i = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, u = a.length; o < u; ++o) n[o] = a[o], i[a.charCodeAt(o)] = o;

        function c(t) {
            var e = t.length;
            if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
            var r = t.indexOf("=");
            return -1 === r && (r = e), [r, r === e ? 0 : 4 - r % 4]
        }

        function h(t, e, r) {
            for (var i, s, a = [], o = e; o < r; o += 3) i = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (255 & t[o + 2]), a.push(n[(s = i) >> 18 & 63] + n[s >> 12 & 63] + n[s >> 6 & 63] + n[63 & s]);
            return a.join("")
        }
        i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63
    }, function(t, e) {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        e.read = function(t, e, r, n, i) {
            var s, a, o = 8 * i - n - 1,
                u = (1 << o) - 1,
                c = u >> 1,
                h = -7,
                l = r ? i - 1 : 0,
                f = r ? -1 : 1,
                p = t[e + l];
            for (l += f, s = p & (1 << -h) - 1, p >>= -h, h += o; h > 0; s = 256 * s + t[e + l], l += f, h -= 8);
            for (a = s & (1 << -h) - 1, s >>= -h, h += n; h > 0; a = 256 * a + t[e + l], l += f, h -= 8);
            if (0 === s) s = 1 - c;
            else {
                if (s === u) return a ? NaN : 1 / 0 * (p ? -1 : 1);
                a += Math.pow(2, n), s -= c
            }
            return (p ? -1 : 1) * a * Math.pow(2, s - n)
        }, e.write = function(t, e, r, n, i, s) {
            var a, o, u, c = 8 * s - i - 1,
                h = (1 << c) - 1,
                l = h >> 1,
                f = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                p = n ? 0 : s - 1,
                d = n ? 1 : -1,
                g = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
            for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = h) : (a = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), (e += a + l >= 1 ? f / u : f * Math.pow(2, 1 - l)) * u >= 2 && (a++, u /= 2), a + l >= h ? (o = 0, a = h) : a + l >= 1 ? (o = (e * u - 1) * Math.pow(2, i), a += l) : (o = e * Math.pow(2, l - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + p] = 255 & o, p += d, o /= 256, i -= 8);
            for (a = a << i | o, c += i; c > 0; t[r + p] = 255 & a, p += d, a /= 256, c -= 8);
            t[r + p - d] |= 128 * g
        }
    }, function(t, e) {
        var r = {}.toString;
        t.exports = Array.isArray || function(t) {
            return "[object Array]" == r.call(t)
        }
    }, function(t, e) {
        t.exports = function(t) {
            return t.webpackPolyfill || (t.deprecate = function() {}, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, "loaded", {
                enumerable: !0,
                get: function() {
                    return t.l
                }
            }), Object.defineProperty(t, "id", {
                enumerable: !0,
                get: function() {
                    return t.i
                }
            }), t.webpackPolyfill = 1), t
        }
    }, function(t, e, r) {
        var n = r(5),
            i = r(0),
            s = r(152);
        n({
            global: !0,
            bind: !0,
            enumerable: !0,
            forced: !i.setImmediate || !i.clearImmediate
        }, {
            setImmediate: s.set,
            clearImmediate: s.clear
        })
    }, function(t, e, r) {
        var n = r(5),
            i = r(0),
            s = r(34),
            a = r(9),
            o = r(36),
            u = r(21),
            c = /MSIE .\./.test(o),
            h = i.Function,
            l = function(t) {
                return function(e, r) {
                    var n = arguments.length > 2,
                        i = n ? u(arguments, 2) : void 0;
                    return t(n ? function() {
                        s(a(e) ? e : h(e), this, i)
                    } : e, r)
                }
            };
        n({
            global: !0,
            bind: !0,
            forced: c
        }, {
            setTimeout: l(i.setTimeout),
            setInterval: l(i.setInterval)
        })
    }, function(t, e, r) {
        var n = r(0),
            i = r(170),
            s = r(171),
            a = r(259),
            o = r(24),
            u = function(t) {
                if (t && t.forEach !== a) try {
                    o(t, "forEach", a)
                } catch (e) {
                    t.forEach = a
                }
            };
        for (var c in i) i[c] && u(n[c] && n[c].prototype);
        u(s)
    }, function(t, e, r) {
        "use strict";
        var n = r(22).forEach,
            i = r(56)("forEach");
        t.exports = i ? [].forEach : function(t) {
            return n(this, t, arguments.length > 1 ? arguments[1] : void 0)
        }
    }, function(t, e, r) {
        var n = r(5),
            i = r(96);
        n({
            global: !0,
            forced: !r(142)
        }, {
            DataView: i.DataView
        })
    }, function(t, e, r) {
        var n = r(1),
            i = r(15),
            s = Math.floor,
            a = n("".charAt),
            o = n("".replace),
            u = n("".slice),
            c = /\$([$&'`]|\d{1,2}|<[^>]*>)/g,
            h = /\$([$&'`]|\d{1,2})/g;
        t.exports = function(t, e, r, n, l, f) {
            var p = r + t.length,
                d = n.length,
                g = h;
            return void 0 !== l && (l = i(l), g = c), o(f, g, (function(i, o) {
                var c;
                switch (a(o, 0)) {
                    case "$":
                        return "$";
                    case "&":
                        return t;
                    case "`":
                        return u(e, 0, r);
                    case "'":
                        return u(e, p);
                    case "<":
                        c = l[u(o, 1, -1)];
                        break;
                    default:
                        var h = +o;
                        if (0 === h) return i;
                        if (h > d) {
                            var f = s(h / 10);
                            return 0 === f ? i : f <= d ? void 0 === n[f - 1] ? a(o, 1) : n[f - 1] + a(o, 1) : i
                        }
                        c = n[h - 1]
                }
                return void 0 === c ? "" : c
            }))
        }
    }, function(t, e) {
        t.exports = Object.is || function(t, e) {
            return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(0),
            s = r(1),
            a = r(26),
            o = r(189),
            u = r(264),
            c = r(3),
            h = i.RangeError,
            l = i.String,
            f = Math.floor,
            p = s(u),
            d = s("".slice),
            g = s(1..toFixed),
            y = function(t, e, r) {
                return 0 === e ? r : e % 2 == 1 ? y(t, e - 1, r * t) : y(t * t, e / 2, r)
            },
            v = function(t, e, r) {
                for (var n = -1, i = r; ++n < 6;) i += e * t[n], t[n] = i % 1e7, i = f(i / 1e7)
            },
            m = function(t, e) {
                for (var r = 6, n = 0; --r >= 0;) n += t[r], t[r] = f(n / e), n = n % e * 1e7
            },
            E = function(t) {
                for (var e = 6, r = ""; --e >= 0;)
                    if ("" !== r || 0 === e || 0 !== t[e]) {
                        var n = l(t[e]);
                        r = "" === r ? n : r + p("0", 7 - n.length) + n
                    }
                return r
            };
        n({
            target: "Number",
            proto: !0,
            forced: c((function() {
                return "0.000" !== g(8e-5, 3) || "1" !== g(.9, 0) || "1.25" !== g(1.255, 2) || "1000000000000000128" !== g(0xde0b6b3a7640080, 0)
            })) || !c((function() {
                g({})
            }))
        }, {
            toFixed: function(t) {
                var e, r, n, i, s = o(this),
                    u = a(t),
                    c = [0, 0, 0, 0, 0, 0],
                    f = "",
                    g = "0";
                if (u < 0 || u > 20) throw h("Incorrect fraction digits");
                if (s != s) return "NaN";
                if (s <= -1e21 || s >= 1e21) return l(s);
                if (s < 0 && (f = "-", s = -s), s > 1e-21)
                    if (r = (e = function(t) {
                            for (var e = 0, r = t; r >= 4096;) e += 12, r /= 4096;
                            for (; r >= 2;) e += 1, r /= 2;
                            return e
                        }(s * y(2, 69, 1)) - 69) < 0 ? s * y(2, -e, 1) : s / y(2, e, 1), r *= 4503599627370496, (e = 52 - e) > 0) {
                        for (v(c, 0, r), n = u; n >= 7;) v(c, 1e7, 0), n -= 7;
                        for (v(c, y(10, n, 1), 0), n = e - 1; n >= 23;) m(c, 1 << 23), n -= 23;
                        m(c, 1 << n), v(c, 1, 1), m(c, 2), g = E(c)
                    } else v(c, 0, r), v(c, 1 << -e, 0), g = E(c) + p("0", u);
                return g = u > 0 ? f + ((i = g.length) <= u ? "0." + p("0", u - i) + g : d(g, 0, i - u) + "." + d(g, i - u)) : f + g
            }
        })
    }, function(t, e, r) {
        "use strict";
        var n = r(0),
            i = r(26),
            s = r(17),
            a = r(27),
            o = n.RangeError;
        t.exports = function(t) {
            var e = s(a(this)),
                r = "",
                n = i(t);
            if (n < 0 || n == 1 / 0) throw o("Wrong number of repetitions");
            for (; n > 0;
                (n >>>= 1) && (e += e)) 1 & n && (r += e);
            return r
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(22).filter;
        n({
            target: "Array",
            proto: !0,
            forced: !r(76)("filter")
        }, {
            filter: function(t) {
                return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        })
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(0),
            s = r(45),
            a = r(26),
            o = r(20),
            u = r(15),
            c = r(141),
            h = r(128),
            l = r(76)("splice"),
            f = i.TypeError,
            p = Math.max,
            d = Math.min;
        n({
            target: "Array",
            proto: !0,
            forced: !l
        }, {
            splice: function(t, e) {
                var r, n, i, l, g, y, v = u(this),
                    m = o(v),
                    E = s(t, m),
                    S = arguments.length;
                if (0 === S ? r = n = 0 : 1 === S ? (r = 0, n = m - E) : (r = S - 2, n = d(p(a(e), 0), m - E)), m + r - n > 9007199254740991) throw f("Maximum allowed length exceeded");
                for (i = c(v, n), l = 0; l < n; l++)(g = E + l) in v && h(i, l, v[g]);
                if (i.length = n, r < n) {
                    for (l = E; l < m - n; l++) y = l + r, (g = l + n) in v ? v[y] = v[g] : delete v[y];
                    for (l = m; l > m - n + r; l--) delete v[l - 1]
                } else if (r > n)
                    for (l = m - n; l > E; l--) y = l + r - 1, (g = l + n - 1) in v ? v[y] = v[g] : delete v[y];
                for (l = 0; l < r; l++) v[l + E] = arguments[l + 2];
                return v.length = m - n + r, i
            }
        })
    }, function(t, e, r) {
        "use strict";
        r(57);
        var n, i = r(5),
            s = r(13),
            a = r(190),
            o = r(0),
            u = r(39),
            c = r(10),
            h = r(1),
            l = r(160),
            f = r(19),
            p = r(74),
            d = r(12),
            g = r(268),
            y = r(191),
            v = r(21),
            m = r(92).codeAt,
            E = r(270),
            S = r(17),
            b = r(47),
            C = r(193),
            A = r(25),
            w = A.set,
            T = A.getterFor("URL"),
            x = C.URLSearchParams,
            I = C.getState,
            B = o.URL,
            F = o.TypeError,
            R = o.parseInt,
            D = Math.floor,
            N = Math.pow,
            _ = h("".charAt),
            P = h(/./.exec),
            k = h([].join),
            L = h(1..toString),
            O = h([].pop),
            U = h([].push),
            V = h("".replace),
            H = h([].shift),
            j = h("".split),
            M = h("".slice),
            K = h("".toLowerCase),
            q = h([].unshift),
            z = /[a-z]/i,
            G = /[\d+-.a-z]/i,
            Y = /\d/,
            W = /^0x/i,
            X = /^[0-7]+$/,
            Q = /^\d+$/,
            Z = /^[\da-f]+$/i,
            J = /[\0\t\n\r #%/:<>?@[\\\]^|]/,
            $ = /[\0\t\n\r #/:<>?@[\\\]^|]/,
            tt = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g,
            et = /[\t\n\r]/g,
            rt = function(t, e) {
                var r, n, i;
                if ("[" == _(e, 0)) {
                    if ("]" != _(e, e.length - 1)) return "Invalid host";
                    if (!(r = it(M(e, 1, -1)))) return "Invalid host";
                    t.host = r
                } else if (ft(t)) {
                    if (e = E(e), P(J, e)) return "Invalid host";
                    if (null === (r = nt(e))) return "Invalid host";
                    t.host = r
                } else {
                    if (P($, e)) return "Invalid host";
                    for (r = "", n = y(e), i = 0; i < n.length; i++) r += ht(n[i], at);
                    t.host = r
                }
            },
            nt = function(t) {
                var e, r, n, i, s, a, o, u = j(t, ".");
                if (u.length && "" == u[u.length - 1] && u.length--, (e = u.length) > 4) return t;
                for (r = [], n = 0; n < e; n++) {
                    if ("" == (i = u[n])) return t;
                    if (s = 10, i.length > 1 && "0" == _(i, 0) && (s = P(W, i) ? 16 : 8, i = M(i, 8 == s ? 1 : 2)), "" === i) a = 0;
                    else {
                        if (!P(10 == s ? Q : 8 == s ? X : Z, i)) return t;
                        a = R(i, s)
                    }
                    U(r, a)
                }
                for (n = 0; n < e; n++)
                    if (a = r[n], n == e - 1) {
                        if (a >= N(256, 5 - e)) return null
                    } else if (a > 255) return null;
                for (o = O(r), n = 0; n < r.length; n++) o += r[n] * N(256, 3 - n);
                return o
            },
            it = function(t) {
                var e, r, n, i, s, a, o, u = [0, 0, 0, 0, 0, 0, 0, 0],
                    c = 0,
                    h = null,
                    l = 0,
                    f = function() {
                        return _(t, l)
                    };
                if (":" == f()) {
                    if (":" != _(t, 1)) return;
                    l += 2, h = ++c
                }
                for (; f();) {
                    if (8 == c) return;
                    if (":" != f()) {
                        for (e = r = 0; r < 4 && P(Z, f());) e = 16 * e + R(f(), 16), l++, r++;
                        if ("." == f()) {
                            if (0 == r) return;
                            if (l -= r, c > 6) return;
                            for (n = 0; f();) {
                                if (i = null, n > 0) {
                                    if (!("." == f() && n < 4)) return;
                                    l++
                                }
                                if (!P(Y, f())) return;
                                for (; P(Y, f());) {
                                    if (s = R(f(), 10), null === i) i = s;
                                    else {
                                        if (0 == i) return;
                                        i = 10 * i + s
                                    }
                                    if (i > 255) return;
                                    l++
                                }
                                u[c] = 256 * u[c] + i, 2 != ++n && 4 != n || c++
                            }
                            if (4 != n) return;
                            break
                        }
                        if (":" == f()) {
                            if (l++, !f()) return
                        } else if (f()) return;
                        u[c++] = e
                    } else {
                        if (null !== h) return;
                        l++, h = ++c
                    }
                }
                if (null !== h)
                    for (a = c - h, c = 7; 0 != c && a > 0;) o = u[c], u[c--] = u[h + a - 1], u[h + --a] = o;
                else if (8 != c) return;
                return u
            },
            st = function(t) {
                var e, r, n, i;
                if ("number" == typeof t) {
                    for (e = [], r = 0; r < 4; r++) q(e, t % 256), t = D(t / 256);
                    return k(e, ".")
                }
                if ("object" == typeof t) {
                    for (e = "", n = function(t) {
                            for (var e = null, r = 1, n = null, i = 0, s = 0; s < 8; s++) 0 !== t[s] ? (i > r && (e = n, r = i), n = null, i = 0) : (null === n && (n = s), ++i);
                            return i > r && (e = n, r = i), e
                        }(t), r = 0; r < 8; r++) i && 0 === t[r] || (i && (i = !1), n === r ? (e += r ? ":" : "::", i = !0) : (e += L(t[r], 16), r < 7 && (e += ":")));
                    return "[" + e + "]"
                }
                return t
            },
            at = {},
            ot = g({}, at, {
                " ": 1,
                '"': 1,
                "<": 1,
                ">": 1,
                "`": 1
            }),
            ut = g({}, ot, {
                "#": 1,
                "?": 1,
                "{": 1,
                "}": 1
            }),
            ct = g({}, ut, {
                "/": 1,
                ":": 1,
                ";": 1,
                "=": 1,
                "@": 1,
                "[": 1,
                "\\": 1,
                "]": 1,
                "^": 1,
                "|": 1
            }),
            ht = function(t, e) {
                var r = m(t, 0);
                return r > 32 && r < 127 && !d(e, t) ? t : encodeURIComponent(t)
            },
            lt = {
                ftp: 21,
                file: null,
                http: 80,
                https: 443,
                ws: 80,
                wss: 443
            },
            ft = function(t) {
                return d(lt, t.scheme)
            },
            pt = function(t) {
                return "" != t.username || "" != t.password
            },
            dt = function(t) {
                return !t.host || t.cannotBeABaseURL || "file" == t.scheme
            },
            gt = function(t, e) {
                var r;
                return 2 == t.length && P(z, _(t, 0)) && (":" == (r = _(t, 1)) || !e && "|" == r)
            },
            yt = function(t) {
                var e;
                return t.length > 1 && gt(M(t, 0, 2)) && (2 == t.length || "/" === (e = _(t, 2)) || "\\" === e || "?" === e || "#" === e)
            },
            vt = function(t) {
                var e = t.path,
                    r = e.length;
                !r || "file" == t.scheme && 1 == r && gt(e[0], !0) || e.length--
            },
            mt = function(t) {
                return "." === t || "%2e" === K(t)
            },
            Et = {},
            St = {},
            bt = {},
            Ct = {},
            At = {},
            wt = {},
            Tt = {},
            xt = {},
            It = {},
            Bt = {},
            Ft = {},
            Rt = {},
            Dt = {},
            Nt = {},
            _t = {},
            Pt = {},
            kt = {},
            Lt = {},
            Ot = {},
            Ut = {},
            Vt = {},
            Ht = function(t, e, r, i) {
                var s, a, o, u, c, h = r || Et,
                    l = 0,
                    f = "",
                    p = !1,
                    g = !1,
                    m = !1;
                for (r || (t.scheme = "", t.username = "", t.password = "", t.host = null, t.port = null, t.path = [], t.query = null, t.fragment = null, t.cannotBeABaseURL = !1, e = V(e, tt, "")), e = V(e, et, ""), s = y(e); l <= s.length;) {
                    switch (a = s[l], h) {
                        case Et:
                            if (!a || !P(z, a)) {
                                if (r) return "Invalid scheme";
                                h = bt;
                                continue
                            }
                            f += K(a), h = St;
                            break;
                        case St:
                            if (a && (P(G, a) || "+" == a || "-" == a || "." == a)) f += K(a);
                            else {
                                if (":" != a) {
                                    if (r) return "Invalid scheme";
                                    f = "", h = bt, l = 0;
                                    continue
                                }
                                if (r && (ft(t) != d(lt, f) || "file" == f && (pt(t) || null !== t.port) || "file" == t.scheme && !t.host)) return;
                                if (t.scheme = f, r) return void(ft(t) && lt[t.scheme] == t.port && (t.port = null));
                                f = "", "file" == t.scheme ? h = Nt : ft(t) && i && i.scheme == t.scheme ? h = Ct : ft(t) ? h = xt : "/" == s[l + 1] ? (h = At, l++) : (t.cannotBeABaseURL = !0, U(t.path, ""), h = Ot)
                            }
                            break;
                        case bt:
                            if (!i || i.cannotBeABaseURL && "#" != a) return "Invalid scheme";
                            if (i.cannotBeABaseURL && "#" == a) {
                                t.scheme = i.scheme, t.path = v(i.path), t.query = i.query, t.fragment = "", t.cannotBeABaseURL = !0, h = Vt;
                                break
                            }
                            h = "file" == i.scheme ? Nt : wt;
                            continue;
                        case Ct:
                            if ("/" != a || "/" != s[l + 1]) {
                                h = wt;
                                continue
                            }
                            h = It, l++;
                            break;
                        case At:
                            if ("/" == a) {
                                h = Bt;
                                break
                            }
                            h = Lt;
                            continue;
                        case wt:
                            if (t.scheme = i.scheme, a == n) t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, t.path = v(i.path), t.query = i.query;
                            else if ("/" == a || "\\" == a && ft(t)) h = Tt;
                            else if ("?" == a) t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, t.path = v(i.path), t.query = "", h = Ut;
                            else {
                                if ("#" != a) {
                                    t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, t.path = v(i.path), t.path.length--, h = Lt;
                                    continue
                                }
                                t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, t.path = v(i.path), t.query = i.query, t.fragment = "", h = Vt
                            }
                            break;
                        case Tt:
                            if (!ft(t) || "/" != a && "\\" != a) {
                                if ("/" != a) {
                                    t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, h = Lt;
                                    continue
                                }
                                h = Bt
                            } else h = It;
                            break;
                        case xt:
                            if (h = It, "/" != a || "/" != _(f, l + 1)) continue;
                            l++;
                            break;
                        case It:
                            if ("/" != a && "\\" != a) {
                                h = Bt;
                                continue
                            }
                            break;
                        case Bt:
                            if ("@" == a) {
                                p && (f = "%40" + f), p = !0, o = y(f);
                                for (var E = 0; E < o.length; E++) {
                                    var S = o[E];
                                    if (":" != S || m) {
                                        var b = ht(S, ct);
                                        m ? t.password += b : t.username += b
                                    } else m = !0
                                }
                                f = ""
                            } else if (a == n || "/" == a || "?" == a || "#" == a || "\\" == a && ft(t)) {
                                if (p && "" == f) return "Invalid authority";
                                l -= y(f).length + 1, f = "", h = Ft
                            } else f += a;
                            break;
                        case Ft:
                        case Rt:
                            if (r && "file" == t.scheme) {
                                h = Pt;
                                continue
                            }
                            if (":" != a || g) {
                                if (a == n || "/" == a || "?" == a || "#" == a || "\\" == a && ft(t)) {
                                    if (ft(t) && "" == f) return "Invalid host";
                                    if (r && "" == f && (pt(t) || null !== t.port)) return;
                                    if (u = rt(t, f)) return u;
                                    if (f = "", h = kt, r) return;
                                    continue
                                }
                                "[" == a ? g = !0 : "]" == a && (g = !1), f += a
                            } else {
                                if ("" == f) return "Invalid host";
                                if (u = rt(t, f)) return u;
                                if (f = "", h = Dt, r == Rt) return
                            }
                            break;
                        case Dt:
                            if (!P(Y, a)) {
                                if (a == n || "/" == a || "?" == a || "#" == a || "\\" == a && ft(t) || r) {
                                    if ("" != f) {
                                        var C = R(f, 10);
                                        if (C > 65535) return "Invalid port";
                                        t.port = ft(t) && C === lt[t.scheme] ? null : C, f = ""
                                    }
                                    if (r) return;
                                    h = kt;
                                    continue
                                }
                                return "Invalid port"
                            }
                            f += a;
                            break;
                        case Nt:
                            if (t.scheme = "file", "/" == a || "\\" == a) h = _t;
                            else {
                                if (!i || "file" != i.scheme) {
                                    h = Lt;
                                    continue
                                }
                                if (a == n) t.host = i.host, t.path = v(i.path), t.query = i.query;
                                else if ("?" == a) t.host = i.host, t.path = v(i.path), t.query = "", h = Ut;
                                else {
                                    if ("#" != a) {
                                        yt(k(v(s, l), "")) || (t.host = i.host, t.path = v(i.path), vt(t)), h = Lt;
                                        continue
                                    }
                                    t.host = i.host, t.path = v(i.path), t.query = i.query, t.fragment = "", h = Vt
                                }
                            }
                            break;
                        case _t:
                            if ("/" == a || "\\" == a) {
                                h = Pt;
                                break
                            }
                            i && "file" == i.scheme && !yt(k(v(s, l), "")) && (gt(i.path[0], !0) ? U(t.path, i.path[0]) : t.host = i.host), h = Lt;
                            continue;
                        case Pt:
                            if (a == n || "/" == a || "\\" == a || "?" == a || "#" == a) {
                                if (!r && gt(f)) h = Lt;
                                else if ("" == f) {
                                    if (t.host = "", r) return;
                                    h = kt
                                } else {
                                    if (u = rt(t, f)) return u;
                                    if ("localhost" == t.host && (t.host = ""), r) return;
                                    f = "", h = kt
                                }
                                continue
                            }
                            f += a;
                            break;
                        case kt:
                            if (ft(t)) {
                                if (h = Lt, "/" != a && "\\" != a) continue
                            } else if (r || "?" != a)
                                if (r || "#" != a) {
                                    if (a != n && (h = Lt, "/" != a)) continue
                                } else t.fragment = "", h = Vt;
                            else t.query = "", h = Ut;
                            break;
                        case Lt:
                            if (a == n || "/" == a || "\\" == a && ft(t) || !r && ("?" == a || "#" == a)) {
                                if (".." === (c = K(c = f)) || "%2e." === c || ".%2e" === c || "%2e%2e" === c ? (vt(t), "/" == a || "\\" == a && ft(t) || U(t.path, "")) : mt(f) ? "/" == a || "\\" == a && ft(t) || U(t.path, "") : ("file" == t.scheme && !t.path.length && gt(f) && (t.host && (t.host = ""), f = _(f, 0) + ":"), U(t.path, f)), f = "", "file" == t.scheme && (a == n || "?" == a || "#" == a))
                                    for (; t.path.length > 1 && "" === t.path[0];) H(t.path);
                                "?" == a ? (t.query = "", h = Ut) : "#" == a && (t.fragment = "", h = Vt)
                            } else f += ht(a, ut);
                            break;
                        case Ot:
                            "?" == a ? (t.query = "", h = Ut) : "#" == a ? (t.fragment = "", h = Vt) : a != n && (t.path[0] += ht(a, at));
                            break;
                        case Ut:
                            r || "#" != a ? a != n && ("'" == a && ft(t) ? t.query += "%27" : t.query += "#" == a ? "%23" : ht(a, at)) : (t.fragment = "", h = Vt);
                            break;
                        case Vt:
                            a != n && (t.fragment += ht(a, ot))
                    }
                    l++
                }
            },
            jt = function(t) {
                var e, r, n = p(this, Mt),
                    i = arguments.length > 1 ? arguments[1] : void 0,
                    a = S(t),
                    o = w(n, {
                        type: "URL"
                    });
                if (void 0 !== i) try {
                    e = T(i)
                } catch (t) {
                    if (r = Ht(e = {}, S(i))) throw F(r)
                }
                if (r = Ht(o, a, null, e)) throw F(r);
                var u = o.searchParams = new x,
                    h = I(u);
                h.updateSearchParams(o.query), h.updateURL = function() {
                    o.query = S(u) || null
                }, s || (n.href = c(Kt, n), n.origin = c(qt, n), n.protocol = c(zt, n), n.username = c(Gt, n), n.password = c(Yt, n), n.host = c(Wt, n), n.hostname = c(Xt, n), n.port = c(Qt, n), n.pathname = c(Zt, n), n.search = c(Jt, n), n.searchParams = c($t, n), n.hash = c(te, n))
            },
            Mt = jt.prototype,
            Kt = function() {
                var t = T(this),
                    e = t.scheme,
                    r = t.username,
                    n = t.password,
                    i = t.host,
                    s = t.port,
                    a = t.path,
                    o = t.query,
                    u = t.fragment,
                    c = e + ":";
                return null !== i ? (c += "//", pt(t) && (c += r + (n ? ":" + n : "") + "@"), c += st(i), null !== s && (c += ":" + s)) : "file" == e && (c += "//"), c += t.cannotBeABaseURL ? a[0] : a.length ? "/" + k(a, "/") : "", null !== o && (c += "?" + o), null !== u && (c += "#" + u), c
            },
            qt = function() {
                var t = T(this),
                    e = t.scheme,
                    r = t.port;
                if ("blob" == e) try {
                    return new jt(e.path[0]).origin
                } catch (t) {
                    return "null"
                }
                return "file" != e && ft(t) ? e + "://" + st(t.host) + (null !== r ? ":" + r : "") : "null"
            },
            zt = function() {
                return T(this).scheme + ":"
            },
            Gt = function() {
                return T(this).username
            },
            Yt = function() {
                return T(this).password
            },
            Wt = function() {
                var t = T(this),
                    e = t.host,
                    r = t.port;
                return null === e ? "" : null === r ? st(e) : st(e) + ":" + r
            },
            Xt = function() {
                var t = T(this).host;
                return null === t ? "" : st(t)
            },
            Qt = function() {
                var t = T(this).port;
                return null === t ? "" : S(t)
            },
            Zt = function() {
                var t = T(this),
                    e = t.path;
                return t.cannotBeABaseURL ? e[0] : e.length ? "/" + k(e, "/") : ""
            },
            Jt = function() {
                var t = T(this).query;
                return t ? "?" + t : ""
            },
            $t = function() {
                return T(this).searchParams
            },
            te = function() {
                var t = T(this).fragment;
                return t ? "#" + t : ""
            },
            ee = function(t, e) {
                return {
                    get: t,
                    set: e,
                    configurable: !0,
                    enumerable: !0
                }
            };
        if (s && l(Mt, {
                href: ee(Kt, (function(t) {
                    var e = T(this),
                        r = S(t),
                        n = Ht(e, r);
                    if (n) throw F(n);
                    I(e.searchParams).updateSearchParams(e.query)
                })),
                origin: ee(qt),
                protocol: ee(zt, (function(t) {
                    var e = T(this);
                    Ht(e, S(t) + ":", Et)
                })),
                username: ee(Gt, (function(t) {
                    var e = T(this),
                        r = y(S(t));
                    if (!dt(e)) {
                        e.username = "";
                        for (var n = 0; n < r.length; n++) e.username += ht(r[n], ct)
                    }
                })),
                password: ee(Yt, (function(t) {
                    var e = T(this),
                        r = y(S(t));
                    if (!dt(e)) {
                        e.password = "";
                        for (var n = 0; n < r.length; n++) e.password += ht(r[n], ct)
                    }
                })),
                host: ee(Wt, (function(t) {
                    var e = T(this);
                    e.cannotBeABaseURL || Ht(e, S(t), Ft)
                })),
                hostname: ee(Xt, (function(t) {
                    var e = T(this);
                    e.cannotBeABaseURL || Ht(e, S(t), Rt)
                })),
                port: ee(Qt, (function(t) {
                    var e = T(this);
                    dt(e) || ("" == (t = S(t)) ? e.port = null : Ht(e, t, Dt))
                })),
                pathname: ee(Zt, (function(t) {
                    var e = T(this);
                    e.cannotBeABaseURL || (e.path = [], Ht(e, S(t), kt))
                })),
                search: ee(Jt, (function(t) {
                    var e = T(this);
                    "" == (t = S(t)) ? e.query = null: ("?" == _(t, 0) && (t = M(t, 1)), e.query = "", Ht(e, t, Ut)), I(e.searchParams).updateSearchParams(e.query)
                })),
                searchParams: ee($t),
                hash: ee(te, (function(t) {
                    var e = T(this);
                    "" != (t = S(t)) ? ("#" == _(t, 0) && (t = M(t, 1)), e.fragment = "", Ht(e, t, Vt)) : e.fragment = null
                }))
            }), f(Mt, "toJSON", (function() {
                return c(Kt, this)
            }), {
                enumerable: !0
            }), f(Mt, "toString", (function() {
                return c(Kt, this)
            }), {
                enumerable: !0
            }), B) {
            var re = B.createObjectURL,
                ne = B.revokeObjectURL;
            re && f(jt, "createObjectURL", u(re, B)), ne && f(jt, "revokeObjectURL", u(ne, B))
        }
        b(jt, "URL"), i({
            global: !0,
            forced: !a,
            sham: !s
        }, {
            URL: jt
        })
    }, function(t, e, r) {
        "use strict";
        var n = r(13),
            i = r(1),
            s = r(10),
            a = r(3),
            o = r(67),
            u = r(134),
            c = r(79),
            h = r(15),
            l = r(61),
            f = Object.assign,
            p = Object.defineProperty,
            d = i([].concat);
        t.exports = !f || a((function() {
            if (n && 1 !== f({
                    b: 1
                }, f(p({}, "a", {
                    enumerable: !0,
                    get: function() {
                        p(this, "b", {
                            value: 3,
                            enumerable: !1
                        })
                    }
                }), {
                    b: 2
                })).b) return !0;
            var t = {},
                e = {},
                r = Symbol();
            return t[r] = 7, "abcdefghijklmnopqrst".split("").forEach((function(t) {
                e[t] = t
            })), 7 != f({}, t)[r] || "abcdefghijklmnopqrst" != o(f({}, e)).join("")
        })) ? function(t, e) {
            for (var r = h(t), i = arguments.length, a = 1, f = u.f, p = c.f; i > a;)
                for (var g, y = l(arguments[a++]), v = f ? d(o(y), f(y)) : o(y), m = v.length, E = 0; m > E;) g = v[E++], n && !s(p, y, g) || (r[g] = y[g]);
            return r
        } : f
    }, function(t, e, r) {
        var n = r(11),
            i = r(192);
        t.exports = function(t, e, r, s) {
            try {
                return s ? e(n(r)[0], r[1]) : e(r)
            } catch (e) {
                i(t, "throw", e)
            }
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(0),
            i = r(1),
            s = /[^\0-\u007E]/,
            a = /[.\u3002\uFF0E\uFF61]/g,
            o = "Overflow: input needs wider integers to process",
            u = n.RangeError,
            c = i(a.exec),
            h = Math.floor,
            l = String.fromCharCode,
            f = i("".charCodeAt),
            p = i([].join),
            d = i([].push),
            g = i("".replace),
            y = i("".split),
            v = i("".toLowerCase),
            m = function(t) {
                return t + 22 + 75 * (t < 26)
            },
            E = function(t, e, r) {
                var n = 0;
                for (t = r ? h(t / 700) : t >> 1, t += h(t / e); t > 455; n += 36) t = h(t / 35);
                return h(n + 36 * t / (t + 38))
            },
            S = function(t) {
                var e, r, n = [],
                    i = (t = function(t) {
                        for (var e = [], r = 0, n = t.length; r < n;) {
                            var i = f(t, r++);
                            if (i >= 55296 && i <= 56319 && r < n) {
                                var s = f(t, r++);
                                56320 == (64512 & s) ? d(e, ((1023 & i) << 10) + (1023 & s) + 65536) : (d(e, i), r--)
                            } else d(e, i)
                        }
                        return e
                    }(t)).length,
                    s = 128,
                    a = 0,
                    c = 72;
                for (e = 0; e < t.length; e++)(r = t[e]) < 128 && d(n, l(r));
                var g = n.length,
                    y = g;
                for (g && d(n, "-"); y < i;) {
                    var v = 2147483647;
                    for (e = 0; e < t.length; e++)(r = t[e]) >= s && r < v && (v = r);
                    var S = y + 1;
                    if (v - s > h((2147483647 - a) / S)) throw u(o);
                    for (a += (v - s) * S, s = v, e = 0; e < t.length; e++) {
                        if ((r = t[e]) < s && ++a > 2147483647) throw u(o);
                        if (r == s) {
                            for (var b = a, C = 36;; C += 36) {
                                var A = C <= c ? 1 : C >= c + 26 ? 26 : C - c;
                                if (b < A) break;
                                var w = b - A,
                                    T = 36 - A;
                                d(n, l(m(A + w % T))), b = h(w / T)
                            }
                            d(n, l(m(b))), c = E(a, S, y == g), a = 0, ++y
                        }
                    }++a, ++s
                }
                return p(n, "")
            };
        t.exports = function(t) {
            var e, r, n = [],
                i = y(g(v(t), a, "."), ".");
            for (e = 0; e < i.length; e++) r = i[e], d(n, c(s, r) ? "xn--" + S(r) : r);
            return p(n, ".")
        }
    }, function(t, e, r) {
        var n = r(13),
            i = r(16),
            s = r(88),
            a = r(3),
            o = RegExp.prototype;
        n && a((function() {
            return "sy" !== Object.getOwnPropertyDescriptor(o, "flags").get.call({
                dotAll: !0,
                sticky: !0
            })
        })) && i.f(o, "flags", {
            configurable: !0,
            get: s
        })
    }, function(t, e, r) {
        "use strict";
        var n = r(13),
            i = r(0),
            s = r(1),
            a = r(86),
            o = r(19),
            u = r(12),
            c = r(146),
            h = r(29),
            l = r(63),
            f = r(155),
            p = r(3),
            d = r(44).f,
            g = r(53).f,
            y = r(16).f,
            v = r(189),
            m = r(273).trim,
            E = i.Number,
            S = E.prototype,
            b = i.TypeError,
            C = s("".slice),
            A = s("".charCodeAt),
            w = function(t) {
                var e = f(t, "number");
                return "bigint" == typeof e ? e : T(e)
            },
            T = function(t) {
                var e, r, n, i, s, a, o, u, c = f(t, "number");
                if (l(c)) throw b("Cannot convert a Symbol value to a number");
                if ("string" == typeof c && c.length > 2)
                    if (c = m(c), 43 === (e = A(c, 0)) || 45 === e) {
                        if (88 === (r = A(c, 2)) || 120 === r) return NaN
                    } else if (48 === e) {
                    switch (A(c, 1)) {
                        case 66:
                        case 98:
                            n = 2, i = 49;
                            break;
                        case 79:
                        case 111:
                            n = 8, i = 55;
                            break;
                        default:
                            return +c
                    }
                    for (a = (s = C(c, 2)).length, o = 0; o < a; o++)
                        if ((u = A(s, o)) < 48 || u > i) return NaN;
                    return parseInt(s, n)
                }
                return +c
            };
        if (a("Number", !E(" 0o1") || !E("0b1") || E("+0x1"))) {
            for (var x, I = function(t) {
                    var e = arguments.length < 1 ? 0 : E(w(t)),
                        r = this;
                    return h(S, r) && p((function() {
                        v(r)
                    })) ? c(Object(e), r, I) : e
                }, B = n ? d(E) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","), F = 0; B.length > F; F++) u(E, x = B[F]) && !u(I, x) && y(I, x, g(E, x));
            I.prototype = S, S.constructor = I, o(i, "Number", I)
        }
    }, function(t, e, r) {
        var n = r(1),
            i = r(27),
            s = r(17),
            a = r(274),
            o = n("".replace),
            u = "[" + a + "]",
            c = RegExp("^" + u + u + "*"),
            h = RegExp(u + u + "*$"),
            l = function(t) {
                return function(e) {
                    var r = s(i(e));
                    return 1 & t && (r = o(r, c, "")), 2 & t && (r = o(r, h, "")), r
                }
            };
        t.exports = {
            start: l(1),
            end: l(2),
            trim: l(3)
        }
    }, function(t, e) {
        t.exports = "\t\n\v\f\r \u2028\u2029\ufeff"
    }, function(t, e, r) {
        var n = r(5),
            i = r(15),
            s = r(67);
        n({
            target: "Object",
            stat: !0,
            forced: r(3)((function() {
                s(1)
            }))
        }, {
            keys: function(t) {
                return s(i(t))
            }
        })
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(22).map;
        n({
            target: "Array",
            proto: !0,
            forced: !r(76)("map")
        }, {
            map: function(t) {
                return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        })
    }, function(t, e, r) {
        "use strict";

        function n(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function i(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }

        function s(t, e, r) {
            return e && i(t.prototype, e), r && i(t, r), t
        }
        var a = r(51).BigInteger,
            o = new a("3"),
            u = function() {
                function t(e, r) {
                    n(this, t), this.x = r, this.q = e
                }
                return s(t, [{
                    key: "equals",
                    value: function(t) {
                        return t === this || this.q.equals(t.q) && this.x.equals(t.x)
                    }
                }, {
                    key: "toBigInteger",
                    value: function() {
                        return this.x
                    }
                }, {
                    key: "negate",
                    value: function() {
                        return new t(this.q, this.x.negate().mod(this.q))
                    }
                }, {
                    key: "add",
                    value: function(e) {
                        return new t(this.q, this.x.add(e.toBigInteger()).mod(this.q))
                    }
                }, {
                    key: "subtract",
                    value: function(e) {
                        return new t(this.q, this.x.subtract(e.toBigInteger()).mod(this.q))
                    }
                }, {
                    key: "multiply",
                    value: function(e) {
                        return new t(this.q, this.x.multiply(e.toBigInteger()).mod(this.q))
                    }
                }, {
                    key: "divide",
                    value: function(e) {
                        return new t(this.q, this.x.multiply(e.toBigInteger().modInverse(this.q)).mod(this.q))
                    }
                }, {
                    key: "square",
                    value: function() {
                        return new t(this.q, this.x.square().mod(this.q))
                    }
                }]), t
            }(),
            c = function() {
                function t(e, r, i, s) {
                    n(this, t), this.curve = e, this.x = r, this.y = i, this.z = null == s ? a.ONE : s, this.zinv = null
                }
                return s(t, [{
                    key: "getX",
                    value: function() {
                        return null === this.zinv && (this.zinv = this.z.modInverse(this.curve.q)), this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))
                    }
                }, {
                    key: "getY",
                    value: function() {
                        return null === this.zinv && (this.zinv = this.z.modInverse(this.curve.q)), this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))
                    }
                }, {
                    key: "equals",
                    value: function(t) {
                        return t === this || (this.isInfinity() ? t.isInfinity() : t.isInfinity() ? this.isInfinity() : !!t.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(t.z)).mod(this.curve.q).equals(a.ZERO) && t.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(t.z)).mod(this.curve.q).equals(a.ZERO))
                    }
                }, {
                    key: "isInfinity",
                    value: function() {
                        return null === this.x && null === this.y || this.z.equals(a.ZERO) && !this.y.toBigInteger().equals(a.ZERO)
                    }
                }, {
                    key: "negate",
                    value: function() {
                        return new t(this.curve, this.x, this.y.negate(), this.z)
                    }
                }, {
                    key: "add",
                    value: function(e) {
                        if (this.isInfinity()) return e;
                        if (e.isInfinity()) return this;
                        var r = this.x.toBigInteger(),
                            n = this.y.toBigInteger(),
                            i = this.z,
                            s = e.x.toBigInteger(),
                            o = e.y.toBigInteger(),
                            u = e.z,
                            c = this.curve.q,
                            h = r.multiply(u).mod(c),
                            l = s.multiply(i).mod(c),
                            f = h.subtract(l),
                            p = n.multiply(u).mod(c),
                            d = o.multiply(i).mod(c),
                            g = p.subtract(d);
                        if (a.ZERO.equals(f)) return a.ZERO.equals(g) ? this.twice() : this.curve.infinity;
                        var y = h.add(l),
                            v = i.multiply(u).mod(c),
                            m = f.square().mod(c),
                            E = f.multiply(m).mod(c),
                            S = v.multiply(g.square()).subtract(y.multiply(m)).mod(c),
                            b = f.multiply(S).mod(c),
                            C = g.multiply(m.multiply(h).subtract(S)).subtract(p.multiply(E)).mod(c),
                            A = E.multiply(v).mod(c);
                        return new t(this.curve, this.curve.fromBigInteger(b), this.curve.fromBigInteger(C), A)
                    }
                }, {
                    key: "twice",
                    value: function() {
                        if (this.isInfinity()) return this;
                        if (!this.y.toBigInteger().signum()) return this.curve.infinity;
                        var e = this.x.toBigInteger(),
                            r = this.y.toBigInteger(),
                            n = this.z,
                            i = this.curve.q,
                            s = this.curve.a.toBigInteger(),
                            a = e.square().multiply(o).add(s.multiply(n.square())).mod(i),
                            u = r.shiftLeft(1).multiply(n).mod(i),
                            c = r.square().mod(i),
                            h = c.multiply(e).multiply(n).mod(i),
                            l = u.square().mod(i),
                            f = a.square().subtract(h.shiftLeft(3)).mod(i),
                            p = u.multiply(f).mod(i),
                            d = a.multiply(h.shiftLeft(2).subtract(f)).subtract(l.shiftLeft(1).multiply(c)).mod(i),
                            g = u.multiply(l).mod(i);
                        return new t(this.curve, this.curve.fromBigInteger(p), this.curve.fromBigInteger(d), g)
                    }
                }, {
                    key: "multiply",
                    value: function(t) {
                        if (this.isInfinity()) return this;
                        if (!t.signum()) return this.curve.infinity;
                        for (var e = t.multiply(o), r = this.negate(), n = this, i = e.bitLength() - 2; i > 0; i--) {
                            n = n.twice();
                            var s = e.testBit(i);
                            s !== t.testBit(i) && (n = n.add(s ? this : r))
                        }
                        return n
                    }
                }]), t
            }(),
            h = function() {
                function t(e, r, i) {
                    n(this, t), this.q = e, this.a = this.fromBigInteger(r), this.b = this.fromBigInteger(i), this.infinity = new c(this, null, null)
                }
                return s(t, [{
                    key: "equals",
                    value: function(t) {
                        return t === this || this.q.equals(t.q) && this.a.equals(t.a) && this.b.equals(t.b)
                    }
                }, {
                    key: "fromBigInteger",
                    value: function(t) {
                        return new u(this.q, t)
                    }
                }, {
                    key: "decodePointHex",
                    value: function(t) {
                        switch (parseInt(t.substr(0, 2), 16)) {
                            case 0:
                                return this.infinity;
                            case 2:
                            case 3:
                                return null;
                            case 4:
                            case 6:
                            case 7:
                                var e = (t.length - 2) / 2,
                                    r = t.substr(2, e),
                                    n = t.substr(e + 2, e);
                                return new c(this, this.fromBigInteger(new a(r, 16)), this.fromBigInteger(new a(n, 16)));
                            default:
                                return null
                        }
                    }
                }]), t
            }();
        t.exports = {
            ECPointFp: c,
            ECCurveFp: h
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(92).codeAt;
        n({
            target: "String",
            proto: !0
        }, {
            codePointAt: function(t) {
                return i(this, t)
            }
        })
    }, function(t, e, r) {
        "use strict";
        r(127), r(58);
        var n = r(77);

        function i() {
            this.sbox = new Array(214, 144, 233, 254, 204, 225, 61, 183, 22, 182, 20, 194, 40, 251, 44, 5, 43, 103, 154, 118, 42, 190, 4, 195, 170, 68, 19, 38, 73, 134, 6, 153, 156, 66, 80, 244, 145, 239, 152, 122, 51, 84, 11, 67, 237, 207, 172, 98, 228, 179, 28, 169, 201, 8, 232, 149, 128, 223, 148, 250, 117, 143, 63, 166, 71, 7, 167, 252, 243, 115, 23, 186, 131, 89, 60, 25, 230, 133, 79, 168, 104, 107, 129, 178, 113, 100, 218, 139, 248, 235, 15, 75, 112, 86, 157, 53, 30, 36, 14, 94, 99, 88, 209, 162, 37, 34, 124, 59, 1, 33, 120, 135, 212, 0, 70, 87, 159, 211, 39, 82, 76, 54, 2, 231, 160, 196, 200, 158, 234, 191, 138, 210, 64, 199, 56, 181, 163, 247, 242, 206, 249, 97, 21, 161, 224, 174, 93, 164, 155, 52, 26, 85, 173, 147, 50, 48, 245, 140, 177, 227, 29, 246, 226, 46, 130, 102, 202, 96, 192, 41, 35, 171, 13, 83, 78, 111, 213, 219, 55, 69, 222, 253, 142, 47, 3, 255, 106, 114, 109, 108, 91, 81, 141, 27, 175, 146, 187, 221, 188, 127, 17, 217, 92, 65, 31, 16, 90, 216, 10, 193, 49, 136, 165, 205, 123, 189, 45, 116, 208, 18, 184, 229, 180, 176, 137, 105, 151, 74, 12, 150, 119, 126, 101, 185, 241, 9, 197, 110, 198, 132, 24, 240, 125, 236, 58, 220, 77, 32, 121, 238, 95, 62, 215, 203, 57, 72), this.fk = new Array(2746333894, 1453994832, 1736282519, 2993693404), this.ck = new Array(462357, 472066609, 943670861, 1415275113, 1886879365, 2358483617, 2830087869, 3301692121, 3773296373, 4228057617, 404694573, 876298825, 1347903077, 1819507329, 2291111581, 2762715833, 3234320085, 3705924337, 4177462797, 337322537, 808926789, 1280531041, 1752135293, 2223739545, 2695343797, 3166948049, 3638552301, 4110090761, 269950501, 741554753, 1213159005, 1684763257)
        }

        function s(t, e, r) {
            for (var n = new Array(2 * r), i = new Array("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"), s = e, a = 0; s < r + e; s++, a++) n[a] = i[(255 & t[s]) >> 4], n[++a] = i[15 & t[s]];
            return n.join("")
        }

        function a(t) {
            if (null == t || "" == t) return null;
            if (t.length % 2 != 0) return null;
            for (var e = t.length / 2, r = function(t) {
                    for (var e = new Array(t.length), r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
                    return e
                }(t), n = new Array(e), i = 0; i < e; i++) {
                if (r[2 * i] >= 48 && r[2 * i] <= 57) n[i] = r[2 * i] - 48 << 4;
                else if (r[2 * i] >= 65 && r[2 * i] <= 70) n[i] = r[2 * i] - 65 + 10 << 4;
                else {
                    if (!(r[2 * i] >= 97 && r[2 * i] <= 102)) return null;
                    n[i] = r[2 * i] - 97 + 10 << 4
                }
                if (r[2 * i + 1] >= 48 && r[2 * i + 1] <= 57) n[i] = n[i] | r[2 * i + 1] - 48;
                else if (r[2 * i + 1] >= 65 && r[2 * i + 1] <= 70) n[i] = n[i] | r[2 * i + 1] - 65 + 10;
                else {
                    if (!(r[2 * i + 1] >= 97 && r[2 * i + 1] <= 102)) return null;
                    n[i] = n[i] | r[2 * i + 1] - 97 + 10
                }
            }
            return n
        }

        function o(t, e, r, n, i) {
            var s = i;
            s = e + i > t.length && n + i <= r.length ? t.length - e : n + i > r.length && e + i <= t.length ? r.length - n : e + i <= t.length && n + i <= r.length ? i : r.length < t.length ? r.length - n : t.length - n;
            for (var a = 0; a < s; a++) r[a + n] = t[a + e]
        }

        function u(t) {
            return new Array(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t)
        }

        function c(t, e) {
            return e + 3 < t.length ? t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3] : e + 2 < t.length ? t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3] : e + 1 < t.length ? t[e] << 8 | t[e + 1] : t[e]
        }

        function h(t) {
            for (var e = t, r = [], n = 0; n < e.length; n++) r.push(String.fromCharCode(e[n]));
            return decodeURIComponent(escape(r.join("")))
        }
        i.prototype = {
            expandKey: function(t) {
                var e = new Array(36),
                    r = function(t) {
                        for (var e = Math.ceil(t.length / 4), r = new Array(e), n = 0; n < t.length; n++) t[n] = 255 & t[n];
                        for (n = 0; n < r.length; n++) r[n] = c(t, 4 * n);
                        return r
                    }(t);
                e[0] = r[0] ^ this.fk[0], e[1] = r[1] ^ this.fk[1], e[2] = r[2] ^ this.fk[2], e[3] = r[3] ^ this.fk[3];
                for (var n = new Array(32), i = 0; i < 32; i++) e[i + 4] = e[i] ^ this.T1(e[i + 1] ^ e[i + 2] ^ e[i + 3] ^ this.ck[i]), n[i] = e[i + 4];
                return n
            },
            T1: function(t) {
                var e = new Array(4),
                    r = u(t);
                e[0] = this.sbox[255 & r[0]], e[1] = this.sbox[255 & r[1]], e[2] = this.sbox[255 & r[2]], e[3] = this.sbox[255 & r[3]];
                var n = c(e, 0);
                return n ^ (n << 13 | n >>> 19) ^ (n << 23 | n >>> 9)
            },
            one_encrypt: function(t, e) {
                var r = new Array(36);
                r[0] = c(e, 0), r[1] = c(e, 4), r[2] = c(e, 8), r[3] = c(e, 12);
                for (var n = 0; n < 32; n++) r[n + 4] = r[n] ^ this.T0(r[n + 1] ^ r[n + 2] ^ r[n + 3] ^ t[n]);
                var i = new Array(4);
                for (n = 35; n >= 32; n--) i[35 - n] = r[n];
                return function(t) {
                    for (var e = new Array(4 * t.length), r = 0; r < t.length; r++) o(u(t[r]), 0, e, 4 * r, 4);
                    return e
                }(i)
            },
            T0: function(t) {
                var e = u(t),
                    r = new Array(4);
                r[0] = this.sbox[255 & e[0]], r[1] = this.sbox[255 & e[1]], r[2] = this.sbox[255 & e[2]], r[3] = this.sbox[255 & e[3]];
                var n = c(r, 0);
                return n ^ (n << 2 | n >>> 30) ^ (n << 10 | n >>> 22) ^ (n << 18 | n >>> 14) ^ (n << 24 | n >>> 8)
            },
            pkcs7padding: function(t, e) {
                if (null == t) return null;
                var r = null;
                if (1 == e) {
                    var n = 16 - t.length % 16;
                    o(t, 0, r = new Array(t.length + n), 0, t.length);
                    for (var i = 0; i < n; i++) r[t.length + i] = n
                } else {
                    n = t[t.length - 1];
                    o(t, 0, r = new Array(t.length - n), 0, t.length - n)
                }
                return r
            },
            zero_padding: function(t, e) {
                if (null == t) return null;
                var r = null;
                if (1 == e) {
                    var n = 16 - t.length % 16;
                    o(t, 0, r = new Array(t.length + n), 0, t.length);
                    for (var i = 0; i < n; i++) r[t.length + i] = 0
                } else {
                    n = t[t.length - 1];
                    o(t, 0, r = new Array(t.length - (0 == n ? t.length : n)), 0, t.length - (0 == n ? t.length : n))
                }
                return r
            },
            encrypt_ecb: function(t, e, r) {
                if (null == (t = a(t)) || null == t || t.length % 16 != 0) return -1;
                if ("nopadding" == r && (null == e || null == e || e.length % 16 != 0)) return -1;
                for (var i = this.expandKey(t), u = parseInt(e.length / 16), c = new Array("nopadding" == r ? 16 * u : 16 * (u + 1)), h = new Array(16), l = 0; l < u; l++) o(e, 16 * l, h, 0, 16), o(this.one_encrypt(i, h), 0, c, 16 * l, 16);
                var f = new Array(e.length % 16);
                f.length > 0 && o(e, 16 * u, f, 0, e.length % 16);
                var p = null;
                if ("pkcs7padding" == r) return p = this.pkcs7padding(f, 1), o(this.one_encrypt(i, p), 0, c, 16 * u, 16), s(c, 0, c.length);
                if ("nopadding" == r) {
                    var d = null;
                    if (f.length > 0) {
                        var g = new Array(16);
                        o(f, 0, g, 0, 16), o(this.one_encrypt(i, g), 0, c, 16 * u, 16), d = c
                    } else d = c;
                    return n.arrayToHex(d)
                }
                return "zeropadding" == r ? (p = this.zero_padding(f, 1), o(this.one_encrypt(i, p), 0, c, 16 * u, 16), s(c, 0, c.length)) : void 0
            },
            decrypt_ecb: function(t, e, r) {
                if (t = a(t), e = a(e), null == t || null == t || t.length % 16 != 0) return -1;
                if ("nopadding" == r && (null == e || null == e || e.length % 16 != 0)) return -1;
                for (var n = this.expandKey(t), i = new Array(32), s = 0; s < n.length; s++) i[s] = n[32 - s - 1];
                var u, c = "nopadding" == r ? e.length / 16 : e.length / 16 - 1,
                    l = new Array(16),
                    f = null;
                o(e, 16 * c, l, 0, 16), f = this.one_encrypt(i, l);
                var p = null;
                if ("pkcs7padding" == r) p = this.pkcs7padding(f, 0);
                else if ("nopadding" == r) {
                    var d = new Array;
                    if (0 == f[f.length - 1])
                        for (var g = 0; g < f.length; g++) 0 != f[g] && d.push(f[g]);
                    p = d
                } else if ("zeropadding" == r) {
                    var y = new Array;
                    if (0 == f[f.length - 1])
                        for (var v = 0; v < f.length; v++) 0 != f[v] && y.push(f[v]);
                    p = y
                }
                o(p, 0, u = new Array(16 * c + p.length), 16 * c, p.length);
                for (s = 0; s < c; s++) o(e, 16 * s, l, 0, 16), o(f = this.one_encrypt(i, l), 0, u, 16 * s, 16);
                return h(u)
            },
            encrypt_ofb: function(t, e, r, i) {
                if (t = a(t), e = a(e), null == t || null == t || t.length % 16 != 0) return -1;
                if ("nopadding" == i && (null == r || null == r || r.length % 16 != 0)) return -1;
                if (null == e || null == e || e.length % 16 != 0) return -1;
                for (var u = this.expandKey(t), c = parseInt(r.length / 16), h = new Array("nopadding" == i ? 16 * c : 16 * (c + 1)), l = new Array(16), f = e.slice(0), p = 0; p < c; p++) {
                    f = this.one_encrypt(u, f), o(r, 16 * p, l, 0, 16);
                    for (var d = 0; d < 16; d++) l[d] = l[d] ^ f[d];
                    o(l, 0, h, 16 * p, 16)
                }
                var g = new Array(r.length % 16);
                g.length > 0 && o(r, 16 * c, g, 0, r.length % 16);
                var y = null;
                if ("pkcs7padding" == i) {
                    y = this.pkcs7padding(g, 1);
                    for (p = 0; p < 16; p++) y[p] = y[p] ^ e[p];
                    return o(this.one_encrypt(u, y), 0, h, 16 * c, 16), s(h, 0, h.length)
                }
                if ("nopadding" == i) {
                    var v = null;
                    if (g.length > 0) {
                        var m = new Array(16);
                        o(g, 0, m, 0, 16);
                        for (p = 0; p < m.length; p++) m[p] = m[p] ^ e[p];
                        o(this.one_encrypt(u, m), 0, h, 16 * c, 16), v = h
                    } else v = h;
                    return n.arrayToHex(v)
                }
                if ("zeropadding" == i) {
                    y = this.zero_padding(g, 1);
                    for (p = 0; p < 16; p++) y[p] = y[p] ^ e[p];
                    return o(this.one_encrypt(u, y), 0, h, 16 * c, 16), s(h, 0, h.length)
                }
            },
            decrypt_ofb: function(t, e, r, n) {
                if (t = a(t), e = a(e), r = a(r), null == t || null == t || t.length % 16 != 0) return -1;
                if ("nopadding" == n && (null == r || null == r || r.length % 16 != 0)) return -1;
                if (null == e || null == e || e.length % 16 != 0) return -1;
                for (var i = this.expandKey(t), s = new Array(32), u = 0; u < i.length; u++) s[u] = i[32 - u - 1];
                var c, l = r.length / 16,
                    f = new Array(16),
                    p = null,
                    d = e.slice(0);
                c = new Array(r.length), o(r, r.length - 16, f, 0, 16), p = this.one_encrypt(s, f);
                for (u = 0; u < 16; u++) p[u] = p[u] ^ e[u];
                var g = null;
                if ("pkcs7padding" == n) g = this.pkcs7padding(p, 0), l -= 1;
                else if ("nopadding" == n) {
                    g = new Array
                } else if ("zeropadding" == n) {
                    var y = new Array;
                    if (0 == p[p.length - 1])
                        for (var v = 0; v < p.length; v++) 0 != p[v] && y.push(p[v]);
                    g = y, l -= 1
                }
                for (u = 0; u < l; u++) {
                    o(r, 16 * u, f, 0, 16), d = this.one_encrypt(i, d);
                    for (var m = 0; m < 16; m++) f[m] = f[m] ^ d[m];
                    o(f, 0, c, 16 * u, 16)
                }
                var E = null;
                return "nopadding" == n ? (o(c, 0, E = new Array(c.length + g.length), 0, c.length), o(g, 0, E, c.length, g.length)) : (o(c, 0, E = new Array(c.length - 16 + g.length), 0, c.length - 16), o(g, 0, E, c.length - 16, g.length)), h(E)
            },
            encrypt_ctr: function(t, e, r, i) {
                if (t = a(t), e = a(e), null == t || null == t || t.length % 16 != 0) return -1;
                if ("nopadding" == i && (null == r || null == r || r.length % 16 != 0)) return -1;
                if (null == e || null == e || e.length % 16 != 0) return -1;
                var u = this.expandKey(t),
                    c = parseInt(r.length / 16),
                    h = new Array("nopadding" == i ? 16 * c : 16 * (c + 1)),
                    l = new Array(16),
                    f = null;
                f = e.slice(0);
                for (var p = 0; p < c; p++) {
                    var d = f.slice(0);
                    d = this.one_encrypt(u, d), f[15] = f[15] + 1 | 0, o(r, 16 * p, l, 0, 16);
                    for (var g = 0; g < 16; g++) l[g] = l[g] ^ d[g];
                    o(l, 0, h, 16 * p, 16)
                }
                var y = new Array(r.length % 16);
                y.length > 0 && o(r, 16 * c, y, 0, r.length % 16);
                var v = null;
                if ("pkcs7padding" == i) {
                    v = this.pkcs7padding(y, 1);
                    for (p = 0; p < 16; p++) v[p] = v[p] ^ e[p];
                    return o(this.one_encrypt(u, v), 0, h, 16 * c, 16), s(h, 0, h.length)
                }
                if ("nopadding" == i) {
                    var m = null;
                    if (y.length > 0) {
                        var E = new Array(16);
                        o(y, 0, E, 0, 16);
                        for (p = 0; p < E.length; p++) E[p] = E[p] ^ e[p];
                        o(this.one_encrypt(u, E), 0, h, 16 * c, 16), m = h
                    } else m = h;
                    return n.arrayToHex(m)
                }
                if ("zeropadding" == i) {
                    v = this.zero_padding(y, 1);
                    for (p = 0; p < 16; p++) v[p] = v[p] ^ e[p];
                    return o(this.one_encrypt(u, v), 0, h, 16 * c, 16), s(h, 0, h.length)
                }
            },
            decrypt_ctr: function(t, e, r, n) {
                if (t = a(t), e = a(e), r = a(r), null == t || null == t || t.length % 16 != 0) return -1;
                if ("nopadding" == n && (null == r || null == r || r.length % 16 != 0)) return -1;
                if (null == e || null == e || e.length % 16 != 0) return -1;
                for (var i = this.expandKey(t), s = new Array(32), u = 0; u < i.length; u++) s[u] = i[32 - u - 1];
                var c, l = r.length / 16,
                    f = new Array(16),
                    p = null,
                    d = null;
                c = new Array(r.length), o(r, r.length - 16, f, 0, 16), p = this.one_encrypt(s, f);
                for (u = 0; u < 16; u++) p[u] = p[u] ^ e[u];
                var g = null;
                if ("pkcs7padding" == n) g = this.pkcs7padding(p, 0), l -= 1;
                else if ("nopadding" == n) {
                    g = new Array
                } else if ("zeropadding" == n) {
                    var y = new Array;
                    if (0 == p[p.length - 1])
                        for (var v = 0; v < p.length; v++) 0 != p[v] && y.push(p[v]);
                    g = y, l -= 1
                }
                d = e.slice(0);
                for (u = 0; u < l; u++) {
                    var m = d.slice(0);
                    m = this.one_encrypt(i, m), d[15] = d[15] + 1 | 0, o(r, 16 * u, f, 0, 16);
                    for (var E = 0; E < 16; E++) f[E] = f[E] ^ m[E];
                    o(f, 0, c, 16 * u, 16)
                }
                var S = null;
                return "nopadding" == n ? (o(c, 0, S = new Array(c.length + g.length), 0, c.length), o(g, 0, S, c.length, g.length)) : (o(c, 0, S = new Array(c.length - 16 + g.length), 0, c.length - 16), o(g, 0, S, c.length - 16, g.length)), h(S)
            },
            encrypt_cbc: function(t, e, r, i) {
                if (t = a(t), e = a(e), null == t || null == t || t.length % 16 != 0) return -1;
                if ("nopadding" == i && (null == r || null == r || r.length <= 0)) return -1;
                if (null == e || null == e || e.length % 16 != 0) return -1;
                for (var u = this.expandKey(t), c = parseInt(r.length / 16), h = new Array("nopadding" == i ? 16 * c : 16 * (c + 1)), l = new Array(16), f = 0; f < c; f++) {
                    o(r, 16 * f, l, 0, 16);
                    for (var p = 0; p < 16; p++) l[p] = l[p] ^ e[p];
                    o(e = this.one_encrypt(u, l), 0, h, 16 * f, 16)
                }
                var d = new Array(r.length % 16);
                d.length > 0 && o(r, 16 * c, d, 0, r.length % 16);
                var g = null;
                if ("pkcs7padding" == i) {
                    g = this.pkcs7padding(d, 1);
                    for (f = 0; f < 16; f++) g[f] = g[f] ^ e[f];
                    return o(e = this.one_encrypt(u, g), 0, h, 16 * c, 16), s(h, 0, h.length)
                }
                if ("nopadding" == i) {
                    var y = null;
                    if (d.length > 0) {
                        var v = new Array(16);
                        o(d, 0, v, 0, 16);
                        for (f = 0; f < v.length; f++) v[f] = v[f] ^ e[f];
                        o(e = this.one_encrypt(u, v), 0, h, 16 * c, 16), y = h
                    } else y = h;
                    return n.arrayToHex(y)
                }
                if ("zeropadding" == i) {
                    g = this.zero_padding(d, 1);
                    for (f = 0; f < 16; f++) g[f] = g[f] ^ e[f];
                    return o(e = this.one_encrypt(u, g), 0, h, 16 * c, 16), s(h, 0, h.length)
                }
            },
            decrypt_cbc: function(t, e, r, n) {
                if (t = a(t), e = a(e), r = a(r), null == t || null == t || t.length % 16 != 0) return -1;
                if ("nopadding" == n && (null == r || null == r || r.length % 16 != 0)) return -1;
                if (null == e || null == e || e.length % 16 != 0) return -1;
                for (var i = this.expandKey(t), s = new Array(32), u = 0; u < i.length; u++) s[u] = i[32 - u - 1];
                var c, l = r.length / 16,
                    f = new Array(16),
                    p = null;
                c = new Array(r.length);
                for (u = 0; u < l; u++) {
                    o(r, 16 * u, f, 0, 16), p = this.one_encrypt(s, f);
                    for (var d = 0; d < 16; d++) p[d] = p[d] ^ e[d];
                    o(f, 0, e, 0, 16), o(p, 0, c, 16 * u, 16)
                }
                var g = null;
                if ("pkcs7padding" == n) g = this.pkcs7padding(p, 0);
                else if ("nopadding" == n) {
                    var y = new Array;
                    if (0 == p[p.length - 1])
                        for (var v = 0; v < p.length; v++) 0 != p[v] && y.push(p[v]);
                    g = y
                } else if ("zeropadding" == n) {
                    var m = new Array;
                    if (0 == p[p.length - 1])
                        for (var E = 0; E < p.length; E++) 0 != p[E] && m.push(p[E]);
                    g = m
                }
                var S = null;
                return "nopadding" == n ? (o(c, 0, S = new Array(c.length + g.length), 0, c.length), o(g, 0, S, c.length, g.length)) : (o(c, 0, S = new Array(c.length - 16 + g.length), 0, c.length - 16), o(g, 0, S, c.length - 16, g.length)), h(S)
            }
        }, t.exports = {
            SM4: i
        }
    }, function(t, e, r) {
        "use strict";

        function n(t, e) {
            if (t) {
                if ("string" == typeof t) return i(t, e);
                var r = Object.prototype.toString.call(t).slice(8, -1);
                return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? i(t, e) : void 0
            }
        }

        function i(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
            return n
        }
        r(281), r(187), r(291), r(57), r(68), r(69), r(70), r(31), r(73), r(292), r(30), r(38), r(129), r(293), r(294), r(295), r(66), r(137), r(127), r(78), r(58), r(188), r(194), r(154), r(298);
        r(200);
        var s = r(196),
            a = (r(195), r(77)),
            o = a.generateEcparam(),
            u = o.G,
            c = o.curve,
            h = o.n,
            l = (r(300), r(49), r(301)),
            f = l.encodeDer,
            p = l.decodeDer,
            d = r(184),
            g = r(51),
            y = g.BigInteger,
            v = (g.SecureRandom, r(197));
        r(198).SM4, r(306).Promise;

        function m(t, e) {
            var r = new s,
                n = (new s).getZ(u, e.substr(2, 128)),
                i = a.hexToArray(a.arrayToHex(n).toString()),
                o = t,
                c = a.hexToArray(o),
                h = new Array(r.getDigestSize());
            return r.blockUpdate(i, 0, i.length), r.blockUpdate(c, 0, c.length), r.doFinal(h, 0), a.arrayToHex(h).toString()
        }

        function E(t, e) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                n = r.pointPool,
                i = r.der,
                s = r.hash,
                o = r.publicKey,
                u = "string" == typeof t ? a.parseUtf8StringToHex(t) : a.parseArrayBufferToHex(t);
            s && (u = m(u, o = o || T(e)));
            var c = new y(e, 16),
                l = new y(u, 16),
                p = null,
                d = null,
                g = null;
            do {
                do {
                    var v = void 0;
                    p = (v = n && n.length ? n.pop() : x()).k, d = l.add(v.x1).mod(h)
                } while (d.equals(y.ZERO) || d.add(p).equals(h));
                g = c.add(y.ONE).modInverse(h).multiply(p.subtract(d.multiply(c))).mod(h)
            } while (g.equals(y.ZERO));
            return i ? f(d, g) : a.leftPad(d.toString(16), 64) + a.leftPad(g.toString(16), 64)
        }

        function S(t) {
            return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(t)
        }

        function b(t) {
            var e, r, n, i = "",
                s = 0;
            for (e = 0; e < t.length && "=" != t.charAt(e); ++e)(n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(t.charAt(e))) < 0 || (0 == s ? (i += S(n >> 2), r = 3 & n, s = 1) : 1 == s ? (i += S(r << 2 | n >> 4), r = 15 & n, s = 2) : 2 == s ? (i += S(r), i += S(n >> 2), r = 3 & n, s = 3) : (i += S(r << 2 | n >> 4), i += S(15 & n), s = 0));
            return 1 == s && (i += S(r << 2)), i
        }
        var C = function(t, e, r, n, i) {
            for (var s = 0; s < i; s++) r[n + s] = t[e + s]
        };

        function A(t, e) {
            var r = new s,
                n = e,
                i = 0,
                o = new Array(e);
            if (n < 1) return "";
            var u = (t = a.hexToArray(t)).length,
                c = new Array(u + 4),
                h = 0;
            for (C(t, 0, c, 0, t.length), h = 1; n > 0;) {
                var l = r.getDigestSize(),
                    f = new Array(l);
                c[u] = h >> 24 & 255, c[u + 1] = h >> 16 & 255, c[u + 2] = h >> 8 & 255, c[u + 3] = 255 & h, r.reset(), r.blockUpdate(c, 0, c.length), r.doFinal(f, 0), C(f, 0, o, i, n > l ? l : n), n -= l, i += l, h++
            }
            return a.arrayToHex(o).toString()
        }

        function w(t) {
            return d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.SEQUENCE, !0, [d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.OID, !1, d.asn1.oidToDer(t).getBytes()), d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.NULL, !1, "")])
        }

        function T(t) {
            var e = u.multiply(new y(t, 16));
            return "04" + a.leftPad(e.getX().toBigInteger().toString(16), 64) + a.leftPad(e.getY().toBigInteger().toString(16), 64)
        }

        function x() {
            var t = a.generateKeyPairHex(),
                e = c.decodePointHex(t.publicKey);
            return t.k = new y(t.privateKey, 16), t.x1 = e.getX().toBigInteger(), t
        }

        function I(t, e) {
            return new Date(t, e, 0).getDate()
        }

        function B(t) {
            return t < 10 ? "0" + t : t
        }

        function F(t) {
            return {
                code: "0",
                data: t
            }
        }

        function R() {
            return {
                paramError: {
                    code: "90001",
                    data: ""
                },
                decryptError: {
                    code: "90002",
                    data: ""
                },
                verifyError: {
                    code: "90003",
                    data: ""
                },
                cert1: {
                    code: "10002",
                    msg: ""
                },
                cert2: {
                    code: "10003",
                    msg: ""
                },
                cert3: {
                    code: "10004",
                    msg: ""
                },
                cert4: {
                    code: "10008",
                    msg: ""
                },
                sign1: {
                    code: "10005",
                    msg: ""
                },
                sign2: {
                    code: "10006",
                    msg: ""
                },
                sign3: {
                    code: "10007",
                    msg: ""
                },
                sign4: {
                    code: "10008",
                    msg: ""
                },
                seed: {
                    code: "10009",
                    msg: ""
                },
                draw: {
                    code: "10010",
                    msg: ""
                },
                seedkey: {
                    code: "10011",
                    msg: ""
                },
                envelopError: {
                    code: "10012",
                    msg: ","
                }
            }
        }
        t.exports = {
            SM2Signature: function(t, e) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    n = r.pointPool,
                    i = r.der,
                    s = r.hash,
                    o = r.publicKey,
                    u = t;
                s && (u = m(u, o = o || T(e)));
                var c = new y(e, 16),
                    l = new y(u, 16),
                    f = null,
                    p = null,
                    d = null;
                do {
                    do {
                        var g = void 0;
                        f = (g = n && n.length ? n.pop() : x()).k, p = l.add(g.x1).mod(h)
                    } while (p.equals(y.ZERO) || p.add(f).equals(h));
                    d = c.add(y.ONE).modInverse(h).multiply(f.subtract(p.multiply(c))).mod(h)
                } while (d.equals(y.ZERO));
                return i ? {
                    r: p,
                    s: d
                } : a.leftPad(p.toString(16), 64) + a.leftPad(d.toString(16), 64)
            },
            doSignature: E,
            doVerifySignature: function(t, e, r) {
                var n, i, s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                    o = s.der,
                    l = s.hash,
                    f = "string" == typeof t ? a.parseUtf8StringToHex(t) : a.parseArrayBufferToHex(t);
                if (l && (f = m(f, r)), o) {
                    var d = p(e);
                    n = d.r, i = d.s
                } else n = new y(e.substring(0, 64), 16), i = new y(e.substring(64), 16);
                var g = c.decodePointHex(r),
                    v = new y(f, 16),
                    E = n.add(i).mod(h);
                if (E.equals(y.ZERO)) return !1;
                var S = u.multiply(i).add(g.multiply(E)),
                    b = v.add(S.getX().toBigInteger()).mod(h);
                return n.equals(b)
            },
            b64tohex: b,
            doSM3KDF: A,
            doSm3ById: function(t, e) {
                new s;
                var r = (new s).getZ(u, e.substr(2, 128), t);
                return a.arrayToHex(r).toString()
            },
            onCreateSignData: function(t, e, r, i, s, a, o) {
                var u, c, h, l = "",
                    f = e,
                    p = "";
                if ("attach" == i && (p = d.util.createBuffer(r, "utf8").bytes()), "SM3withSM2" !== o) l = t, c = (u = d.pki.certificateFromPem(t)).issuer.attributes, h = u.serialNumber;
                else {
                    l = t;
                    var g, y = function(t, e) {
                        var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!r) {
                            if (Array.isArray(t) || (r = n(t)) || e && t && "number" == typeof t.length) {
                                r && (t = r);
                                var i = 0,
                                    s = function() {};
                                return {
                                    s: s,
                                    n: function() {
                                        return i >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[i++]
                                        }
                                    },
                                    e: function(t) {
                                        throw t
                                    },
                                    f: s
                                }
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                        }
                        var a, o = !0,
                            u = !1;
                        return {
                            s: function() {
                                r = r.call(t)
                            },
                            n: function() {
                                var t = r.next();
                                return o = t.done, t
                            },
                            e: function(t) {
                                u = !0, a = t
                            },
                            f: function() {
                                try {
                                    o || null == r.return || r.return()
                                } finally {
                                    if (u) throw a
                                }
                            }
                        }
                    }((u = "string" == typeof d.asn1.fromDer(d.pem.decode(l)[0].body).value[1].value[0].value[3] ? d.pki.certificateFromAsn1WithoutPubKey(d.asn1.fromDer(d.pem.decode(l)[0].body)) : d.pki.certificateFromAsn1WithoutPubKey(d.asn1.fromDer(d.pem.decode(l)[0].body).value[1].value[0].value[3].value[0])).issuer.attributes);
                    try {
                        for (y.s(); !(g = y.n()).done;) {
                            var v = g.value;
                            v.value = d.util.decodeUtf8(v.value)
                        }
                    } catch (t) {
                        y.e(t)
                    } finally {
                        y.f()
                    }
                    c = u.issuer.attributes, h = u.serialNumber
                }
                d.pem.decode(l)[0];
                var m = null;
                m = "string" == typeof d.asn1.fromDer(d.pem.decode(l)[0].body).value[1].value[0].value[3] ? d.asn1.fromDer(d.pem.decode(l)[0].body) : d.asn1.fromDer(d.pem.decode(l)[0].body).value[1].value[0].value[3].value[0];
                var E = w(s),
                    S = d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.SEQUENCE, !0, [d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.OID, !1, d.asn1.oidToDer(d.pki.oids.data).getBytes()), d.asn1.create(d.asn1.Class.CONTEXT_SPECIFIC, 0, !0, [d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.OCTETSTRING, !1, p)])]),
                    b = d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.SEQUENCE, !0, [d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.INTEGER, !1, d.asn1.integerToDer(1).getBytes()), d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.SEQUENCE, !0, [d.pki.distinguishedNameToAsn1({
                        attributes: c
                    }), d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.INTEGER, !1, d.util.hexToBytes(h))]), E, w(a), d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.OCTETSTRING, !1, d.util.decode64(f))]),
                    C = d.asn1.create(d.asn1.Class.CONTEXT_SPECIFIC, 0, !0, [d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.SEQUENCE, !0, [d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.INTEGER, !1, d.asn1.integerToDer(1).getBytes()), d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.SET, !0, [E]), S, d.asn1.create(d.asn1.Class.CONTEXT_SPECIFIC, 0, !0, [m]), d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.SET, !0, [b])])]),
                    A = d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.SEQUENCE, !0, [d.asn1.create(d.asn1.Class.UNIVERSAL, d.asn1.Type.OID, !1, d.asn1.oidToDer(d.pki.oids.signedData).getBytes()), C]);
                return d.util.encode64(d.asn1.toDer(A).getBytes())
            },
            hmacSM3: function(t, e) {
                var r = null,
                    n = [],
                    i = [];
                r = e.length > 32 ? v(e, "hex") : e;
                for (var s = 0; s < 64; s++) n[s] = 54, i[s] = 92;
                for (var o = [], u = 0; u < 64; u++) o[u] = 255 & (a.hexToArray(r)[u] ^ n[u]);
                var c = [];
                c = (c = c.concat(o)).concat(a.hexToArray(a.parseUtf8StringToHex(t)));
                for (var h = v(a.arrayToHex(c), "hex"), l = [], f = 0; f < 64; f++) l[f] = 255 & (a.hexToArray(r)[f] ^ i[f]);
                var p = [];
                return p = (p = p.concat(l)).concat(a.hexToArray(h)), v(a.arrayToHex(p), "hex")
            },
            timeFormate: function(t) {
                var e, r, n, i, s, a, o;
                return 13 == t.length ? (n = I(e = "20" + t.slice(0, 2), r = t.slice(2, 4)), i = t.slice(4, 6), s = 1 * t.slice(6, 8) + 8, a = t.slice(8, 10), o = t.slice(10, 12)) : (n = I(e = t.slice(0, 4), r = t.slice(4, 6)), i = t.slice(6, 8), s = 1 * t.slice(8, 10) + 8, a = t.slice(10, 12), o = t.slice(12, 14)), s >= 24 && ((i = 1 * i + 1) > n && (i -= n, (r = 1 * r + 1) < 10 && (r = "0" + r), daty < 10 && (i = "0" + i)), (s -= 24) < 10 && (s = "0" + s)), e + "-" + r + "-" + i + " " + s + ":" + a + ":" + o
            },
            RSATimeFormat: function(t) {
                var e = new Date(t);
                return e.getFullYear() + "-" + B(e.getMonth() + 1) + "-" + B(e.getDate()) + " " + B(e.getHours()) + ":" + B(e.getMinutes()) + ":" + B(e.getSeconds())
            },
            generateAlgorithmIdentifier: w,
            success: F,
            error: R
        }
    }, function(t, e, r) {
        "use strict";
        var n, i, s, a, o = r(5),
            u = r(54),
            c = r(0),
            h = r(28),
            l = r(10),
            f = r(282),
            p = r(19),
            d = r(143),
            g = r(48),
            y = r(47),
            v = r(97),
            m = r(32),
            E = r(9),
            S = r(14),
            b = r(74),
            C = r(83),
            A = r(283),
            w = r(144),
            T = r(90),
            x = r(152).set,
            I = r(284),
            B = r(287),
            F = r(288),
            R = r(199),
            D = r(289),
            N = r(25),
            _ = r(86),
            P = r(7),
            k = r(290),
            L = r(126),
            O = r(42),
            U = P("species"),
            V = N.get,
            H = N.set,
            j = N.getterFor("Promise"),
            M = f && f.prototype,
            K = f,
            q = M,
            z = c.TypeError,
            G = c.document,
            Y = c.process,
            W = R.f,
            X = W,
            Q = !!(G && G.createEvent && c.dispatchEvent),
            Z = E(c.PromiseRejectionEvent),
            J = !1,
            $ = _("Promise", (function() {
                var t = C(K),
                    e = t !== String(K);
                if (!e && 66 === O) return !0;
                if (u && !q.finally) return !0;
                if (O >= 51 && /native code/.test(t)) return !1;
                var r = new K((function(t) {
                        t(1)
                    })),
                    n = function(t) {
                        t((function() {}), (function() {}))
                    };
                return (r.constructor = {})[U] = n, !(J = r.then((function() {})) instanceof n) || !e && k && !Z
            })),
            tt = $ || !w((function(t) {
                K.all(t).catch((function() {}))
            })),
            et = function(t) {
                var e;
                return !(!S(t) || !E(e = t.then)) && e
            },
            rt = function(t, e) {
                if (!t.notified) {
                    t.notified = !0;
                    var r = t.reactions;
                    I((function() {
                        for (var n = t.value, i = 1 == t.state, s = 0; r.length > s;) {
                            var a, o, u, c = r[s++],
                                h = i ? c.ok : c.fail,
                                f = c.resolve,
                                p = c.reject,
                                d = c.domain;
                            try {
                                h ? (i || (2 === t.rejection && at(t), t.rejection = 1), !0 === h ? a = n : (d && d.enter(), a = h(n), d && (d.exit(), u = !0)), a === c.promise ? p(z("Promise-chain cycle")) : (o = et(a)) ? l(o, a, f, p) : f(a)) : p(n)
                            } catch (t) {
                                d && !u && d.exit(), p(t)
                            }
                        }
                        t.reactions = [], t.notified = !1, e && !t.rejection && it(t)
                    }))
                }
            },
            nt = function(t, e, r) {
                var n, i;
                Q ? ((n = G.createEvent("Event")).promise = e, n.reason = r, n.initEvent(t, !1, !0), c.dispatchEvent(n)) : n = {
                    promise: e,
                    reason: r
                }, !Z && (i = c["on" + t]) ? i(n) : "unhandledrejection" === t && F("Unhandled promise rejection", r)
            },
            it = function(t) {
                l(x, c, (function() {
                    var e, r = t.facade,
                        n = t.value;
                    if (st(t) && (e = D((function() {
                            L ? Y.emit("unhandledRejection", n, r) : nt("unhandledrejection", r, n)
                        })), t.rejection = L || st(t) ? 2 : 1, e.error)) throw e.value
                }))
            },
            st = function(t) {
                return 1 !== t.rejection && !t.parent
            },
            at = function(t) {
                l(x, c, (function() {
                    var e = t.facade;
                    L ? Y.emit("rejectionHandled", e) : nt("rejectionhandled", e, t.value)
                }))
            },
            ot = function(t, e, r) {
                return function(n) {
                    t(e, n, r)
                }
            },
            ut = function(t, e, r) {
                t.done || (t.done = !0, r && (t = r), t.value = e, t.state = 2, rt(t, !0))
            },
            ct = function(t, e, r) {
                if (!t.done) {
                    t.done = !0, r && (t = r);
                    try {
                        if (t.facade === e) throw z("Promise can't be resolved itself");
                        var n = et(e);
                        n ? I((function() {
                            var r = {
                                done: !1
                            };
                            try {
                                l(n, e, ot(ct, r, t), ot(ut, r, t))
                            } catch (e) {
                                ut(r, e, t)
                            }
                        })) : (t.value = e, t.state = 1, rt(t, !1))
                    } catch (e) {
                        ut({
                            done: !1
                        }, e, t)
                    }
                }
            };
        if ($ && (q = (K = function(t) {
                b(this, q), m(t), l(n, this);
                var e = V(this);
                try {
                    t(ot(ct, e), ot(ut, e))
                } catch (t) {
                    ut(e, t)
                }
            }).prototype, (n = function(t) {
                H(this, {
                    type: "Promise",
                    done: !1,
                    notified: !1,
                    parent: !1,
                    reactions: [],
                    rejection: !1,
                    state: 0,
                    value: void 0
                })
            }).prototype = d(q, {
                then: function(t, e) {
                    var r = j(this),
                        n = r.reactions,
                        i = W(T(this, K));
                    return i.ok = !E(t) || t, i.fail = E(e) && e, i.domain = L ? Y.domain : void 0, r.parent = !0, n[n.length] = i, 0 != r.state && rt(r, !1), i.promise
                },
                catch: function(t) {
                    return this.then(void 0, t)
                }
            }), i = function() {
                var t = new n,
                    e = V(t);
                this.promise = t, this.resolve = ot(ct, e), this.reject = ot(ut, e)
            }, R.f = W = function(t) {
                return t === K || t === s ? new i(t) : X(t)
            }, !u && E(f) && M !== Object.prototype)) {
            a = M.then, J || (p(M, "then", (function(t, e) {
                var r = this;
                return new K((function(t, e) {
                    l(a, r, t, e)
                })).then(t, e)
            }), {
                unsafe: !0
            }), p(M, "catch", q.catch, {
                unsafe: !0
            }));
            try {
                delete M.constructor
            } catch (t) {}
            g && g(M, q)
        }
        o({
            global: !0,
            wrap: !0,
            forced: $
        }, {
            Promise: K
        }), y(K, "Promise", !1, !0), v("Promise"), s = h("Promise"), o({
            target: "Promise",
            stat: !0,
            forced: $
        }, {
            reject: function(t) {
                var e = W(this);
                return l(e.reject, void 0, t), e.promise
            }
        }), o({
            target: "Promise",
            stat: !0,
            forced: u || $
        }, {
            resolve: function(t) {
                return B(u && this === s ? K : this, t)
            }
        }), o({
            target: "Promise",
            stat: !0,
            forced: tt
        }, {
            all: function(t) {
                var e = this,
                    r = W(e),
                    n = r.resolve,
                    i = r.reject,
                    s = D((function() {
                        var r = m(e.resolve),
                            s = [],
                            a = 0,
                            o = 1;
                        A(t, (function(t) {
                            var u = a++,
                                c = !1;
                            o++, l(r, e, t).then((function(t) {
                                c || (c = !0, s[u] = t, --o || n(s))
                            }), i)
                        })), --o || n(s)
                    }));
                return s.error && i(s.value), r.promise
            },
            race: function(t) {
                var e = this,
                    r = W(e),
                    n = r.reject,
                    i = D((function() {
                        var i = m(e.resolve);
                        A(t, (function(t) {
                            l(i, e, t).then(r.resolve, n)
                        }))
                    }));
                return i.error && n(i.value), r.promise
            }
        })
    }, function(t, e, r) {
        var n = r(0);
        t.exports = n.Promise
    }, function(t, e, r) {
        var n = r(0),
            i = r(39),
            s = r(10),
            a = r(11),
            o = r(64),
            u = r(145),
            c = r(20),
            h = r(29),
            l = r(100),
            f = r(75),
            p = r(192),
            d = n.TypeError,
            g = function(t, e) {
                this.stopped = t, this.result = e
            },
            y = g.prototype;
        t.exports = function(t, e, r) {
            var n, v, m, E, S, b, C, A = r && r.that,
                w = !(!r || !r.AS_ENTRIES),
                T = !(!r || !r.IS_ITERATOR),
                x = !(!r || !r.INTERRUPTED),
                I = i(e, A),
                B = function(t) {
                    return n && p(n, "normal", t), new g(!0, t)
                },
                F = function(t) {
                    return w ? (a(t), x ? I(t[0], t[1], B) : I(t[0], t[1])) : x ? I(t, B) : I(t)
                };
            if (T) n = t;
            else {
                if (!(v = f(t))) throw d(o(t) + " is not iterable");
                if (u(v)) {
                    for (m = 0, E = c(t); E > m; m++)
                        if ((S = F(t[m])) && h(y, S)) return S;
                    return new g(!1)
                }
                n = l(t, v)
            }
            for (b = n.next; !(C = s(b, n)).done;) {
                try {
                    S = F(C.value)
                } catch (t) {
                    p(n, "throw", t)
                }
                if ("object" == typeof S && S && h(y, S)) return S
            }
            return new g(!1)
        }
    }, function(t, e, r) {
        var n, i, s, a, o, u, c, h, l = r(0),
            f = r(39),
            p = r(53).f,
            d = r(152).set,
            g = r(185),
            y = r(285),
            v = r(286),
            m = r(126),
            E = l.MutationObserver || l.WebKitMutationObserver,
            S = l.document,
            b = l.process,
            C = l.Promise,
            A = p(l, "queueMicrotask"),
            w = A && A.value;
        w || (n = function() {
            var t, e;
            for (m && (t = b.domain) && t.exit(); i;) {
                e = i.fn, i = i.next;
                try {
                    e()
                } catch (t) {
                    throw i ? a() : s = void 0, t
                }
            }
            s = void 0, t && t.enter()
        }, g || m || v || !E || !S ? !y && C && C.resolve ? ((c = C.resolve(void 0)).constructor = C, h = f(c.then, c), a = function() {
            h(n)
        }) : m ? a = function() {
            b.nextTick(n)
        } : (d = f(d, l), a = function() {
            d(n)
        }) : (o = !0, u = S.createTextNode(""), new E(n).observe(u, {
            characterData: !0
        }), a = function() {
            u.data = o = !o
        })), t.exports = w || function(t) {
            var e = {
                fn: t,
                next: void 0
            };
            s && (s.next = e), i || (i = e, a()), s = e
        }
    }, function(t, e, r) {
        var n = r(36),
            i = r(0);
        t.exports = /ipad|iphone|ipod/i.test(n) && void 0 !== i.Pebble
    }, function(t, e, r) {
        var n = r(36);
        t.exports = /web0s(?!.*chrome)/i.test(n)
    }, function(t, e, r) {
        var n = r(11),
            i = r(14),
            s = r(199);
        t.exports = function(t, e) {
            if (n(t), i(e) && e.constructor === t) return e;
            var r = s.f(t);
            return (0, r.resolve)(e), r.promise
        }
    }, function(t, e, r) {
        var n = r(0);
        t.exports = function(t, e) {
            var r = n.console;
            r && r.error && (1 == arguments.length ? r.error(t) : r.error(t, e))
        }
    }, function(t, e) {
        t.exports = function(t) {
            try {
                return {
                    error: !1,
                    value: t()
                }
            } catch (t) {
                return {
                    error: !0,
                    value: t
                }
            }
        }
    }, function(t, e) {
        t.exports = "object" == typeof window
    }, function(t, e, r) {
        var n = r(5),
            i = r(191);
        n({
            target: "Array",
            stat: !0,
            forced: !r(144)((function(t) {
                Array.from(t)
            }))
        }, {
            from: i
        })
    }, function(t, e, r) {
        var n = function(t) {
            "use strict";
            var e = Object.prototype,
                r = e.hasOwnProperty,
                n = "function" == typeof Symbol ? Symbol : {},
                i = n.iterator || "@@iterator",
                s = n.asyncIterator || "@@asyncIterator",
                a = n.toStringTag || "@@toStringTag";

            function o(t, e, r) {
                return Object.defineProperty(t, e, {
                    value: r,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), t[e]
            }
            try {
                o({}, "")
            } catch (t) {
                o = function(t, e, r) {
                    return t[e] = r
                }
            }

            function u(t, e, r, n) {
                var i = e && e.prototype instanceof l ? e : l,
                    s = Object.create(i.prototype),
                    a = new A(n || []);
                return s._invoke = function(t, e, r) {
                    var n = "suspendedStart";
                    return function(i, s) {
                        if ("executing" === n) throw new Error("Generator is already running");
                        if ("completed" === n) {
                            if ("throw" === i) throw s;
                            return T()
                        }
                        for (r.method = i, r.arg = s;;) {
                            var a = r.delegate;
                            if (a) {
                                var o = S(a, r);
                                if (o) {
                                    if (o === h) continue;
                                    return o
                                }
                            }
                            if ("next" === r.method) r.sent = r._sent = r.arg;
                            else if ("throw" === r.method) {
                                if ("suspendedStart" === n) throw n = "completed", r.arg;
                                r.dispatchException(r.arg)
                            } else "return" === r.method && r.abrupt("return", r.arg);
                            n = "executing";
                            var u = c(t, e, r);
                            if ("normal" === u.type) {
                                if (n = r.done ? "completed" : "suspendedYield", u.arg === h) continue;
                                return {
                                    value: u.arg,
                                    done: r.done
                                }
                            }
                            "throw" === u.type && (n = "completed", r.method = "throw", r.arg = u.arg)
                        }
                    }
                }(t, r, a), s
            }

            function c(t, e, r) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, r)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }
            t.wrap = u;
            var h = {};

            function l() {}

            function f() {}

            function p() {}
            var d = {};
            o(d, i, (function() {
                return this
            }));
            var g = Object.getPrototypeOf,
                y = g && g(g(w([])));
            y && y !== e && r.call(y, i) && (d = y);
            var v = p.prototype = l.prototype = Object.create(d);

            function m(t) {
                ["next", "throw", "return"].forEach((function(e) {
                    o(t, e, (function(t) {
                        return this._invoke(e, t)
                    }))
                }))
            }

            function E(t, e) {
                var n;
                this._invoke = function(i, s) {
                    function a() {
                        return new e((function(n, a) {
                            ! function n(i, s, a, o) {
                                var u = c(t[i], t, s);
                                if ("throw" !== u.type) {
                                    var h = u.arg,
                                        l = h.value;
                                    return l && "object" == typeof l && r.call(l, "__await") ? e.resolve(l.__await).then((function(t) {
                                        n("next", t, a, o)
                                    }), (function(t) {
                                        n("throw", t, a, o)
                                    })) : e.resolve(l).then((function(t) {
                                        h.value = t, a(h)
                                    }), (function(t) {
                                        return n("throw", t, a, o)
                                    }))
                                }
                                o(u.arg)
                            }(i, s, n, a)
                        }))
                    }
                    return n = n ? n.then(a, a) : a()
                }
            }

            function S(t, e) {
                var r = t.iterator[e.method];
                if (void 0 === r) {
                    if (e.delegate = null, "throw" === e.method) {
                        if (t.iterator.return && (e.method = "return", e.arg = void 0, S(t, e), "throw" === e.method)) return h;
                        e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method")
                    }
                    return h
                }
                var n = c(r, t.iterator, e.arg);
                if ("throw" === n.type) return e.method = "throw", e.arg = n.arg, e.delegate = null, h;
                var i = n.arg;
                return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = void 0), e.delegate = null, h) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, h)
            }

            function b(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
            }

            function C(t) {
                var e = t.completion || {};
                e.type = "normal", delete e.arg, t.completion = e
            }

            function A(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], t.forEach(b, this), this.reset(!0)
            }

            function w(t) {
                if (t) {
                    var e = t[i];
                    if (e) return e.call(t);
                    if ("function" == typeof t.next) return t;
                    if (!isNaN(t.length)) {
                        var n = -1,
                            s = function e() {
                                for (; ++n < t.length;)
                                    if (r.call(t, n)) return e.value = t[n], e.done = !1, e;
                                return e.value = void 0, e.done = !0, e
                            };
                        return s.next = s
                    }
                }
                return {
                    next: T
                }
            }

            function T() {
                return {
                    value: void 0,
                    done: !0
                }
            }
            return f.prototype = p, o(v, "constructor", p), o(p, "constructor", f), f.displayName = o(p, a, "GeneratorFunction"), t.isGeneratorFunction = function(t) {
                var e = "function" == typeof t && t.constructor;
                return !!e && (e === f || "GeneratorFunction" === (e.displayName || e.name))
            }, t.mark = function(t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, p) : (t.__proto__ = p, o(t, a, "GeneratorFunction")), t.prototype = Object.create(v), t
            }, t.awrap = function(t) {
                return {
                    __await: t
                }
            }, m(E.prototype), o(E.prototype, s, (function() {
                return this
            })), t.AsyncIterator = E, t.async = function(e, r, n, i, s) {
                void 0 === s && (s = Promise);
                var a = new E(u(e, r, n, i), s);
                return t.isGeneratorFunction(r) ? a : a.next().then((function(t) {
                    return t.done ? t.value : a.next()
                }))
            }, m(v), o(v, a, "Generator"), o(v, i, (function() {
                return this
            })), o(v, "toString", (function() {
                return "[object Generator]"
            })), t.keys = function(t) {
                var e = [];
                for (var r in t) e.push(r);
                return e.reverse(),
                    function r() {
                        for (; e.length;) {
                            var n = e.pop();
                            if (n in t) return r.value = n, r.done = !1, r
                        }
                        return r.done = !0, r
                    }
            }, t.values = w, A.prototype = {
                constructor: A,
                reset: function(t) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(C), !t)
                        for (var e in this) "t" === e.charAt(0) && r.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = void 0)
                },
                stop: function() {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type) throw t.arg;
                    return this.rval
                },
                dispatchException: function(t) {
                    if (this.done) throw t;
                    var e = this;

                    function n(r, n) {
                        return a.type = "throw", a.arg = t, e.next = r, n && (e.method = "next", e.arg = void 0), !!n
                    }
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var s = this.tryEntries[i],
                            a = s.completion;
                        if ("root" === s.tryLoc) return n("end");
                        if (s.tryLoc <= this.prev) {
                            var o = r.call(s, "catchLoc"),
                                u = r.call(s, "finallyLoc");
                            if (o && u) {
                                if (this.prev < s.catchLoc) return n(s.catchLoc, !0);
                                if (this.prev < s.finallyLoc) return n(s.finallyLoc)
                            } else if (o) {
                                if (this.prev < s.catchLoc) return n(s.catchLoc, !0)
                            } else {
                                if (!u) throw new Error("try statement without catch or finally");
                                if (this.prev < s.finallyLoc) return n(s.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function(t, e) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var i = this.tryEntries[n];
                        if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                            var s = i;
                            break
                        }
                    }
                    s && ("break" === t || "continue" === t) && s.tryLoc <= e && e <= s.finallyLoc && (s = null);
                    var a = s ? s.completion : {};
                    return a.type = t, a.arg = e, s ? (this.method = "next", this.next = s.finallyLoc, h) : this.complete(a)
                },
                complete: function(t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), h
                },
                finish: function(t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var r = this.tryEntries[e];
                        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), C(r), h
                    }
                },
                catch: function(t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var r = this.tryEntries[e];
                        if (r.tryLoc === t) {
                            var n = r.completion;
                            if ("throw" === n.type) {
                                var i = n.arg;
                                C(r)
                            }
                            return i
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function(t, e, r) {
                    return this.delegate = {
                        iterator: w(t),
                        resultName: e,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = void 0), h
                }
            }, t
        }(t.exports);
        try {
            regeneratorRuntime = n
        } catch (t) {
            "object" == typeof globalThis ? globalThis.regeneratorRuntime = n : Function("r", "regeneratorRuntime = r")(n)
        }
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(1),
            s = r(32),
            a = r(15),
            o = r(20),
            u = r(17),
            c = r(3),
            h = r(148),
            l = r(56),
            f = r(177),
            p = r(178),
            d = r(42),
            g = r(179),
            y = [],
            v = i(y.sort),
            m = i(y.push),
            E = c((function() {
                y.sort(void 0)
            })),
            S = c((function() {
                y.sort(null)
            })),
            b = l("sort"),
            C = !c((function() {
                if (d) return d < 70;
                if (!(f && f > 3)) {
                    if (p) return !0;
                    if (g) return g < 603;
                    var t, e, r, n, i = "";
                    for (t = 65; t < 76; t++) {
                        switch (e = String.fromCharCode(t), t) {
                            case 66:
                            case 69:
                            case 70:
                            case 72:
                                r = 3;
                                break;
                            case 68:
                            case 71:
                                r = 4;
                                break;
                            default:
                                r = 2
                        }
                        for (n = 0; n < 47; n++) y.push({
                            k: e + n,
                            v: r
                        })
                    }
                    for (y.sort((function(t, e) {
                            return e.v - t.v
                        })), n = 0; n < y.length; n++) e = y[n].k.charAt(0), i.charAt(i.length - 1) !== e && (i += e);
                    return "DGBEFHACIJK" !== i
                }
            }));
        n({
            target: "Array",
            proto: !0,
            forced: E || !S || !b || !C
        }, {
            sort: function(t) {
                void 0 !== t && s(t);
                var e = a(this);
                if (C) return void 0 === t ? v(e) : v(e, t);
                var r, n, i = [],
                    c = o(e);
                for (n = 0; n < c; n++) n in e && m(i, e[n]);
                for (h(i, function(t) {
                        return function(e, r) {
                            return void 0 === r ? -1 : void 0 === e ? 1 : void 0 !== t ? +t(e, r) || 0 : u(e) > u(r) ? 1 : -1
                        }
                    }(t)), r = i.length, n = 0; n < r;) e[n] = i[n++];
                for (; n < c;) delete e[n++];
                return e
            }
        })
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(65).includes,
            s = r(172);
        n({
            target: "Array",
            proto: !0
        }, {
            includes: function(t) {
                return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        }), s("includes")
    }, function(t, e, r) {
        "use strict";
        var n = r(5),
            i = r(1),
            s = r(296),
            a = r(27),
            o = r(17),
            u = r(297),
            c = i("".indexOf);
        n({
            target: "String",
            proto: !0,
            forced: !u("includes")
        }, {
            includes: function(t) {
                return !!~c(o(a(this)), o(s(t)), arguments.length > 1 ? arguments[1] : void 0)
            }
        })
    }, function(t, e, r) {
        var n = r(0),
            i = r(138),
            s = n.TypeError;
        t.exports = function(t) {
            if (i(t)) throw s("The method doesn't accept regular expressions");
            return t
        }
    }, function(t, e, r) {
        var n = r(7)("match");
        t.exports = function(t) {
            var e = /./;
            try {
                "/./" [t](e)
            } catch (r) {
                try {
                    return e[n] = !1, "/./" [t](e)
                } catch (t) {}
            }
            return !1
        }
    }, function(t, e, r) {
        var n = r(5),
            i = r(299).entries;
        n({
            target: "Object",
            stat: !0
        }, {
            entries: function(t) {
                return i(t)
            }
        })
    }, function(t, e, r) {
        var n = r(13),
            i = r(1),
            s = r(67),
            a = r(23),
            o = i(r(79).f),
            u = i([].push),
            c = function(t) {
                return function(e) {
                    for (var r, i = a(e), c = s(i), h = c.length, l = 0, f = []; h > l;) r = c[l++], n && !o(i, r) || u(f, t ? [r, i[r]] : i[r]);
                    return f
                }
            };
        t.exports = {
            entries: c(!0),
            values: c(!1)
        }
    }, function(t, e, r) {
        var n;
        t.exports = (n = r(4), r(150), r(125), n.HmacSHA256)
    }, function(t, e, r) {
        "use strict";

        function n(t) {
            return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }

        function i(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && s(t, e)
        }

        function s(t, e) {
            return (s = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function a(t) {
            var e = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                } catch (t) {
                    return !1
                }
            }();
            return function() {
                var r, n = u(t);
                if (e) {
                    var i = u(this).constructor;
                    r = Reflect.construct(n, arguments, i)
                } else r = n.apply(this, arguments);
                return o(this, r)
            }
        }

        function o(t, e) {
            if (e && ("object" === n(e) || "function" == typeof e)) return e;
            if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            return function(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }(t)
        }

        function u(t) {
            return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }

        function c(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }

        function h(t, e) {
            for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }

        function l(t, e, r) {
            return e && h(t.prototype, e), r && h(t, r), t
        }
        r(302), r(303), r(304), r(68), r(69), r(70), r(31), r(57), r(73), r(30), r(38), r(66), r(154), r(186);
        var f = r(51).BigInteger;
        var p = function() {
                function t() {
                    c(this, t), this.isModified = !0, this.hTLV = null, this.hT = "00", this.hL = "00", this.hV = ""
                }
                return l(t, [{
                    key: "getLengthHexFromValue",
                    value: function() {
                        var t = this.hV.length / 2,
                            e = t.toString(16);
                        return e.length % 2 == 1 && (e = "0" + e), t < 128 ? e : (128 + e.length / 2).toString(16) + e
                    }
                }, {
                    key: "getEncodedHex",
                    value: function() {
                        return (null == this.hTLV || this.isModified) && (this.hV = this.getFreshValueHex(), this.hL = this.getLengthHexFromValue(), this.hTLV = this.hT + this.hL + this.hV, this.isModified = !1), this.hTLV
                    }
                }, {
                    key: "getFreshValueHex",
                    value: function() {
                        return ""
                    }
                }]), t
            }(),
            d = function(t) {
                i(r, t);
                var e = a(r);

                function r(t) {
                    var n;
                    return c(this, r), (n = e.call(this)).hT = "02", t && t.bigint && (n.hTLV = null, n.isModified = !0, n.hV = function(t) {
                        var e = t.toString(16);
                        if ("-" !== e.substr(0, 1)) e.length % 2 == 1 ? e = "0" + e : e.match(/^[0-7]/) || (e = "00" + e);
                        else {
                            var r = e.substr(1).length;
                            r % 2 == 1 ? r += 1 : e.match(/^[0-7]/) || (r += 2);
                            for (var n = "", i = 0; i < r; i++) n += "f";
                            e = new f(n, 16).xor(t).add(f.ONE).toString(16).replace(/^-/, "")
                        }
                        return e
                    }(t.bigint)), n
                }
                return l(r, [{
                    key: "getFreshValueHex",
                    value: function() {
                        return this.hV
                    }
                }]), r
            }(p),
            g = function(t) {
                i(r, t);
                var e = a(r);

                function r(t) {
                    var n;
                    return c(this, r), (n = e.call(this)).hT = "30", n.asn1Array = [], t && t.array && (n.asn1Array = t.array), n
                }
                return l(r, [{
                    key: "getFreshValueHex",
                    value: function() {
                        for (var t = "", e = 0; e < this.asn1Array.length; e++) {
                            t += this.asn1Array[e].getEncodedHex()
                        }
                        return this.hV = t, this.hV
                    }
                }]), r
            }(p);

        function y(t, e) {
            if ("8" !== t.substring(e + 2, e + 3)) return 1;
            var r = parseInt(t.substring(e + 3, e + 4), 10);
            return 0 === r ? -1 : r > 0 && r < 10 ? r + 1 : -2
        }

        function v(t, e) {
            var r = function(t, e) {
                var r = y(t, e);
                return r < 1 ? "" : t.substring(e + 2, e + 2 + 2 * r)
            }(t, e);
            return "" === r ? -1 : (parseInt(r.substring(0, 1), 10) < 8 ? new f(r, 16) : new f(r.substring(2), 16)).intValue()
        }

        function m(t, e) {
            var r = y(t, e);
            return r < 0 ? r : e + 2 * (r + 1)
        }

        function E(t, e) {
            var r = m(t, e),
                n = v(t, e);
            return t.substring(r, r + 2 * n)
        }

        function S(t, e) {
            return m(t, e) + 2 * v(t, e)
        }
        t.exports = {
            encodeDer: function(t, e) {
                var r = new d({
                        bigint: t
                    }),
                    n = new d({
                        bigint: e
                    });
                return new g({
                    array: [r, n]
                }).getEncodedHex()
            },
            decodeDer: function(t) {
                var e = function(t, e) {
                        var r = [],
                            n = m(t, e);
                        r.push(n);
                        for (var i = v(t, e), s = n, a = 0;;) {
                            var o = S(t, s);
                            if (null == o || o - n >= 2 * i) break;
                            if (a >= 200) break;
                            r.push(o), s = o, a++
                        }
                        return r
                    }(t, 0),
                    r = e[0],
                    n = e[1],
                    i = E(t, r),
                    s = E(t, n);
                return {
                    r: new f(i, 16),
                    s: new f(s, 16)
                }
            }
        }
    }, function(t, e, r) {
        r(5)({
            target: "Object",
            stat: !0
        }, {
            setPrototypeOf: r(48)
        })
    }, function(t, e, r) {
        var n = r(5),
            i = r(3),
            s = r(15),
            a = r(71),
            o = r(169);
        n({
            target: "Object",
            stat: !0,
            forced: i((function() {
                a(1)
            })),
            sham: !o
        }, {
            getPrototypeOf: function(t) {
                return a(s(t))
            }
        })
    }, function(t, e, r) {
        var n = r(5),
            i = r(28),
            s = r(34),
            a = r(305),
            o = r(139),
            u = r(11),
            c = r(14),
            h = r(37),
            l = r(3),
            f = i("Reflect", "construct"),
            p = Object.prototype,
            d = [].push,
            g = l((function() {
                function t() {}
                return !(f((function() {}), [], t) instanceof t)
            })),
            y = !l((function() {
                f((function() {}))
            })),
            v = g || y;
        n({
            target: "Reflect",
            stat: !0,
            forced: v,
            sham: v
        }, {
            construct: function(t, e) {
                o(t), u(e);
                var r = arguments.length < 3 ? t : o(arguments[2]);
                if (y && !g) return f(t, e, r);
                if (t == r) {
                    switch (e.length) {
                        case 0:
                            return new t;
                        case 1:
                            return new t(e[0]);
                        case 2:
                            return new t(e[0], e[1]);
                        case 3:
                            return new t(e[0], e[1], e[2]);
                        case 4:
                            return new t(e[0], e[1], e[2], e[3])
                    }
                    var n = [null];
                    return s(d, n, e), new(s(a, t, n))
                }
                var i = r.prototype,
                    l = h(c(i) ? i : p),
                    v = s(t, l, e);
                return c(v) ? v : l
            }
        })
    }, function(t, e, r) {
        "use strict";
        var n = r(0),
            i = r(1),
            s = r(32),
            a = r(14),
            o = r(12),
            u = r(21),
            c = n.Function,
            h = i([].concat),
            l = i([].join),
            f = {},
            p = function(t, e, r) {
                if (!o(f, e)) {
                    for (var n = [], i = 0; i < e; i++) n[i] = "a[" + i + "]";
                    f[e] = c("C,a", "return new C(" + l(n, ",") + ")")
                }
                return f[e](t, r)
            };
        t.exports = c.bind || function(t) {
            var e = s(this),
                r = e.prototype,
                n = u(arguments, 1),
                i = function() {
                    var r = h(n, u(arguments));
                    return this instanceof i ? p(e, r.length, r) : e.apply(t, r)
                };
            return a(r) && (i.prototype = r), i
        }
    }, function(t, e, r) {
        (function(e, r) {
            /*!
             * @overview es6-promise - a tiny implementation of Promises/A+.
             * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
             * @license   Licensed under MIT license
             *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
             * @version   v4.2.8+1e68dce6
             */
            var n;
            n = function() {
                "use strict";

                function t(t) {
                    return "function" == typeof t
                }
                var n = Array.isArray ? Array.isArray : function(t) {
                        return "[object Array]" === Object.prototype.toString.call(t)
                    },
                    i = 0,
                    s = void 0,
                    a = void 0,
                    o = function(t, e) {
                        d[i] = t, d[i + 1] = e, 2 === (i += 2) && (a ? a(g) : S())
                    },
                    u = "undefined" != typeof window ? window : void 0,
                    c = u || {},
                    h = c.MutationObserver || c.WebKitMutationObserver,
                    l = "undefined" == typeof self && void 0 !== e && "[object process]" === {}.toString.call(e),
                    f = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel;

                function p() {
                    var t = setTimeout;
                    return function() {
                        return t(g, 1)
                    }
                }
                var d = new Array(1e3);

                function g() {
                    for (var t = 0; t < i; t += 2)(0, d[t])(d[t + 1]), d[t] = void 0, d[t + 1] = void 0;
                    i = 0
                }
                var y, v, m, E, S = void 0;

                function b(t, e) {
                    var r = this,
                        n = new this.constructor(w);
                    void 0 === n[A] && P(n);
                    var i = r._state;
                    if (i) {
                        var s = arguments[i - 1];
                        o((function() {
                            return N(i, n, s, r._result)
                        }))
                    } else R(r, n, t, e);
                    return n
                }

                function C(t) {
                    if (t && "object" == typeof t && t.constructor === this) return t;
                    var e = new this(w);
                    return x(e, t), e
                }
                l ? S = function() {
                    return e.nextTick(g)
                } : h ? (v = 0, m = new h(g), E = document.createTextNode(""), m.observe(E, {
                    characterData: !0
                }), S = function() {
                    E.data = v = ++v % 2
                }) : f ? ((y = new MessageChannel).port1.onmessage = g, S = function() {
                    return y.port2.postMessage(0)
                }) : S = void 0 === u ? function() {
                    try {
                        var t = Function("return this")().require("vertx");
                        return void 0 !== (s = t.runOnLoop || t.runOnContext) ? function() {
                            s(g)
                        } : p()
                    } catch (t) {
                        return p()
                    }
                }() : p();
                var A = Math.random().toString(36).substring(2);

                function w() {}

                function T(e, r, n) {
                    r.constructor === e.constructor && n === b && r.constructor.resolve === C ? function(t, e) {
                        1 === e._state ? B(t, e._result) : 2 === e._state ? F(t, e._result) : R(e, void 0, (function(e) {
                            return x(t, e)
                        }), (function(e) {
                            return F(t, e)
                        }))
                    }(e, r) : void 0 === n ? B(e, r) : t(n) ? function(t, e, r) {
                        o((function(t) {
                            var n = !1,
                                i = function(t, e, r, n) {
                                    try {
                                        t.call(e, r, n)
                                    } catch (t) {
                                        return t
                                    }
                                }(r, e, (function(r) {
                                    n || (n = !0, e !== r ? x(t, r) : B(t, r))
                                }), (function(e) {
                                    n || (n = !0, F(t, e))
                                }), t._label);
                            !n && i && (n = !0, F(t, i))
                        }), t)
                    }(e, r, n) : B(e, r)
                }

                function x(t, e) {
                    if (t === e) F(t, new TypeError("You cannot resolve a promise with itself"));
                    else if (i = typeof(n = e), null === n || "object" !== i && "function" !== i) B(t, e);
                    else {
                        var r = void 0;
                        try {
                            r = e.then
                        } catch (e) {
                            return void F(t, e)
                        }
                        T(t, e, r)
                    }
                    var n, i
                }

                function I(t) {
                    t._onerror && t._onerror(t._result), D(t)
                }

                function B(t, e) {
                    void 0 === t._state && (t._result = e, t._state = 1, 0 !== t._subscribers.length && o(D, t))
                }

                function F(t, e) {
                    void 0 === t._state && (t._state = 2, t._result = e, o(I, t))
                }

                function R(t, e, r, n) {
                    var i = t._subscribers,
                        s = i.length;
                    t._onerror = null, i[s] = e, i[s + 1] = r, i[s + 2] = n, 0 === s && t._state && o(D, t)
                }

                function D(t) {
                    var e = t._subscribers,
                        r = t._state;
                    if (0 !== e.length) {
                        for (var n = void 0, i = void 0, s = t._result, a = 0; a < e.length; a += 3) n = e[a], i = e[a + r], n ? N(r, n, i, s) : i(s);
                        t._subscribers.length = 0
                    }
                }

                function N(e, r, n, i) {
                    var s = t(n),
                        a = void 0,
                        o = void 0,
                        u = !0;
                    if (s) {
                        try {
                            a = n(i)
                        } catch (t) {
                            u = !1, o = t
                        }
                        if (r === a) return void F(r, new TypeError("A promises callback cannot return that same promise."))
                    } else a = i;
                    void 0 !== r._state || (s && u ? x(r, a) : !1 === u ? F(r, o) : 1 === e ? B(r, a) : 2 === e && F(r, a))
                }
                var _ = 0;

                function P(t) {
                    t[A] = _++, t._state = void 0, t._result = void 0, t._subscribers = []
                }
                var k = function() {
                        function t(t, e) {
                            this._instanceConstructor = t, this.promise = new t(w), this.promise[A] || P(this.promise), n(e) ? (this.length = e.length, this._remaining = e.length, this._result = new Array(this.length), 0 === this.length ? B(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(e), 0 === this._remaining && B(this.promise, this._result))) : F(this.promise, new Error("Array Methods must be provided an Array"))
                        }
                        return t.prototype._enumerate = function(t) {
                            for (var e = 0; void 0 === this._state && e < t.length; e++) this._eachEntry(t[e], e)
                        }, t.prototype._eachEntry = function(t, e) {
                            var r = this._instanceConstructor,
                                n = r.resolve;
                            if (n === C) {
                                var i = void 0,
                                    s = void 0,
                                    a = !1;
                                try {
                                    i = t.then
                                } catch (t) {
                                    a = !0, s = t
                                }
                                if (i === b && void 0 !== t._state) this._settledAt(t._state, e, t._result);
                                else if ("function" != typeof i) this._remaining--, this._result[e] = t;
                                else if (r === L) {
                                    var o = new r(w);
                                    a ? F(o, s) : T(o, t, i), this._willSettleAt(o, e)
                                } else this._willSettleAt(new r((function(e) {
                                    return e(t)
                                })), e)
                            } else this._willSettleAt(n(t), e)
                        }, t.prototype._settledAt = function(t, e, r) {
                            var n = this.promise;
                            void 0 === n._state && (this._remaining--, 2 === t ? F(n, r) : this._result[e] = r), 0 === this._remaining && B(n, this._result)
                        }, t.prototype._willSettleAt = function(t, e) {
                            var r = this;
                            R(t, void 0, (function(t) {
                                return r._settledAt(1, e, t)
                            }), (function(t) {
                                return r._settledAt(2, e, t)
                            }))
                        }, t
                    }(),
                    L = function() {
                        function e(t) {
                            this[A] = _++, this._result = this._state = void 0, this._subscribers = [], w !== t && ("function" != typeof t && function() {
                                throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")
                            }(), this instanceof e ? function(t, e) {
                                try {
                                    e((function(e) {
                                        x(t, e)
                                    }), (function(e) {
                                        F(t, e)
                                    }))
                                } catch (e) {
                                    F(t, e)
                                }
                            }(this, t) : function() {
                                throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")
                            }())
                        }
                        return e.prototype.catch = function(t) {
                            return this.then(null, t)
                        }, e.prototype.finally = function(e) {
                            var r = this.constructor;
                            return t(e) ? this.then((function(t) {
                                return r.resolve(e()).then((function() {
                                    return t
                                }))
                            }), (function(t) {
                                return r.resolve(e()).then((function() {
                                    throw t
                                }))
                            })) : this.then(e, e)
                        }, e
                    }();
                return L.prototype.then = b, L.all = function(t) {
                    return new k(this, t).promise
                }, L.race = function(t) {
                    var e = this;
                    return n(t) ? new e((function(r, n) {
                        for (var i = t.length, s = 0; s < i; s++) e.resolve(t[s]).then(r, n)
                    })) : new e((function(t, e) {
                        return e(new TypeError("You must pass an array to race."))
                    }))
                }, L.resolve = C, L.reject = function(t) {
                    var e = new this(w);
                    return F(e, t), e
                }, L._setScheduler = function(t) {
                    a = t
                }, L._setAsap = function(t) {
                    o = t
                }, L._asap = o, L.polyfill = function() {
                    var t = void 0;
                    if (void 0 !== r) t = r;
                    else if ("undefined" != typeof self) t = self;
                    else try {
                        t = Function("return this")()
                    } catch (t) {
                        throw new Error("polyfill failed because global object is unavailable in this environment")
                    }
                    var e = t.Promise;
                    if (e) {
                        var n = null;
                        try {
                            n = Object.prototype.toString.call(e.resolve())
                        } catch (t) {}
                        if ("[object Promise]" === n && !e.cast) return
                    }
                    t.Promise = L
                }, L.Promise = L, L
            }, t.exports = n()
        }).call(this, r(151), r(52))
    }])
}));